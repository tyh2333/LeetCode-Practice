# DFS/BFS

[TOC]

## Flood Fill Series:

#### [733. Flood Fill](https://leetcode-cn.com/problems/flood-fill/)

An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.

You are also given three integers `sr`, `sc`, and `newColor`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.

To perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `newColor`.

Return *the modified image after performing the flood fill*. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)

```c++
Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.	
```



```c++
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        if(image.empty() || image[0].empty()) return image;
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0,1,0,-1};
        int oldColor = image[sr][sc]; // 保存旧颜色用来判断
        image[sr][sc] = newColor; 
        if(oldColor == newColor) return image;// 如果颜色一致，就不用换了
        for(int i = 0; i < 4; i++){
            int x = sr + dx[i];
            int y = sc + dy[i];
            // inboard + (image == oldColor)
            if(x >= 0 && x < image.size() && y >= 0 && y < image[0].size() 
                && image[x][y] == oldColor)
                floodFill(image, x, y, newColor);
        }
        return image;
    }
};
```



#### [130. Surrounded Regions](https://leetcode-cn.com/problems/surrounded-regions/)

Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions that are 4-directionally surrounded by* `'X'`.

A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```c++
Input: board = [["X","X","X","X"],
                ["X","O","O","X"],
                ["X","X","O","X"],
                ["X","O","X","X"]]
Output: [["X","X","X","X"],
         ["X","X","X","X"],
         ["X","X","X","X"],
         ["X","O","X","X"]]
Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```

```c++
class Solution {
public:
    // change all O that are not connected to the bounds to X:
    // so traverse all bounds and use Flood Fill to mark all connect O as *
    // then change all left O to X and all * to O;
    int n,m;
    void solve(vector<vector<char>>& board) {
        if(board.empty() || board[0].empty()) return;
        n = board.size();
        m = board[0].size();
        // traverse all bounds
        for(int i = 0; i < n; i++){ // left and right bound:
            if(board[i][0] == 'O') dfs(board, i, 0);
            if(board[i][m-1] == 'O') dfs(board, i, m-1);
        }
        for(int i = 1; i < m-1; i++){ // upper and lower bound:
            if(board[0][i] == 'O') dfs(board, 0, i);
            if(board[n-1][i] == 'O') dfs(board, n-1, i);
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j <  m; j++){
                if(board[i][j] == 'X') continue;
                if(board[i][j] == 'O') board[i][j] = 'X';
                else if(board[i][j] == '*') board[i][j] = 'O';
            }
        }
    }
    // mark all connnected O to *;
    void dfs(vector<vector<char>>& board, int x , int y){
        int dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0};
        // operation:
        board[x][y] = '*';
        for(int i = 0; i < 4; i++){
            int a = x + dx[i], b = y + dy[i];
            if(a < n && a >= 0 && b >=0 && b < m && board[a][b] == 'O')
                dfs(board, a, b);
        }
    }
};
```



#### [200. Number of Islands](https://leetcode-cn.com/problems/number-of-islands/)

Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

 

**Example 1:**

```c++
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```



**(1) method 1: DFS method: dfs for every '1' and chang to '0':**

```c++
class Solution {
public:
    int n,m;
    int dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        if(grid.empty()|| grid[0].empty()) return 0;
        n = grid.size(), m = grid[0].size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j]== '0') continue;
                else{
                    // update ans
                    ans++; 
                    // change adjacent '1' to '0'
                    dfs(grid, i, j);
                }
            }
        }
        return ans; // numbet of '1' meets
    }
    
    void dfs(vector<vector<char>>& grid, int x, int y){
        // Warning!  it's char '0' not a int 0:
        grid[x][y]='0';
        for(int i = 0; i < 4; i++){
            int a = x + dx[i], b = y + dy[i];
            if(a>=0 && a<n && b>=0 && b<m && grid[a][b]=='1'){
                dfs(grid, a, b);
            }
        }
    }
};
```



**(2)  method 2: BFS method:**

```c++
class Solution {
public:
    int n, m;
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        n = grid.size();
        m = grid[0].size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == '1'){
                    ans ++;
                    bfs(grid, i, j);
                }
            }
        }
        return ans;
    }

    void bfs(vector<vector<char>>& grid, int r, int c)
    {
        queue<pair<int, int>> q;
        q.push(make_pair(r,c));
        grid[r][c] = '0';
        while(!q.empty()){
            auto [x,y]= q.front(); q.pop();
            for(int i = 0; i < 4; i++){
                int a  = x + dx[i], b = y + dy[i];
                if(0 <= a && a < n && b >= 0 && b < m && grid[a][b]== '1'){
                    grid[a][b] = '0';
                    q.push(make_pair(a,b));
                }
            }
        }
    }
};
```



#### [463. Island Perimeter](https://leetcode-cn.com/problems/island-perimeter/)

You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.

Grid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/12/island.png)

```c++
Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
```

**(1) method 1: DFS: expand from left-top to bottom-right, **

**every box +4 and every overlapped side -2;**

```c++
  class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int num = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                if(grid[i][j] == 1) {
                    num += 4; // one more box, +4 lines;
                    // from top to bot: if cur's top box is 1: will cover 2 lines: so -2;
                    if(i + 1 < grid.size() && grid[i + 1][j] == 1) num -= 2;
                    // from left to right: if cur's left box is 1: will cover 2 lines: so -2;
                    if(j + 1 < grid[0].size()  && grid[i][j + 1] == 1) num -= 2;
                }
            }
        }
        return num;
    }
};
```



#### [694. Number of Distinct Islands](https://leetcode-cn.com/problems/number-of-distinct-islands/)

You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.

Return *the number of **distinct** islands*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/01/distinctisland1-1-grid.jpg)

```c++
Input: grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]
Output: 1 // The two lands are same shape
```



**(1) method 1: DFS: **

```c++
How to check if the islands have same shape:	  
		Most of code similar to 200 number of islands, only needs use set to recode every path;
   	set<vector<vector<int>>> st;
   	bc we can shift the islands, so decrease the start point coordinate;
    for (auto& s : shape){
      s[0] -= i;
      s[1] -= j;
		}
```



```c++
class Solution {
public: 
    // set<vector of points in 1 island> 
    set<vector<vector<int>> > st;
    int n,m;
    int dx[4]={-1, 0, 1, 0}, dy[4]={0, 1, 0, -1};
    int numDistinctIslands(vector<vector<int>>& grid) {
        n = grid.size(); 
        m = grid[0].size();
        if(n==0 || m==0) return 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j]==1){
                    vector<vector<int>> shape;
                    dfs(grid, i, j, shape);
                    for(auto& s:  shape){
                        s[0] -= i;
                        s[1] -= j;
                    }
                    st.insert(shape);
                }
            }
        }
        return st.size();
    }
    void dfs(vector<vector<int>>& grid, int x, int y, 
        vector<vector<int>>& shape){
        grid[x][y]=0;
        shape.push_back({x,y});
        for(int i = 0; i < 4; i++){
            int a = x + dx[i];
            int b = y + dy[i];
            if(a >=0 && a<n && b >=0 && b < m && grid[a][b] == 1){
                dfs(grid, a, b, shape);
            }
        }
    }
};
```





#### [695. Max Area of Island](https://leetcode-cn.com/problems/max-area-of-island/)

You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The **area** of an island is the number of cells with a value `1` in the island.

Return *the maximum **area** of an island in* `grid`. If there is no island, return `0`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)

```c++
Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],
							 [0,0,0,0,0,0,0,1,1,1,0,0,0],
							 [0,1,1,0,1,0,0,0,0,0,0,0,0],
							 [0,1,0,0,1,1,0,0,1,0,1,0,0],
							 [0,1,0,0,1,1,0,0,1,1,1,0,0],
							 [0,0,0,0,0,0,0,0,0,0,1,0,0],
							 [0,0,0,0,0,0,0,1,1,1,0,0,0],
							 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
```



**(1) DFS, only difference with 200 number of islands is use : cnt+=dfs(grid,a,b);**

```c++
class Solution {
public:
    int ans = INT_MIN, cur = 0;
    int n, m;
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        n = grid.size(), m = grid[0].size();
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                if(grid[i][j] == 1) 
                    ans = max(ans, dfs(grid, i, j));
        return ans == INT_MIN ? 0 : ans;
    }
  	// return the max area can be expanded from (x, y)
    int dfs(vector<vector<int>>& grid, int x , int y){
        // 1. current round operation 
        grid[x][y] = 0;
        // 2. check if can move to surrounded four boxes:
        int cnt = 1;
        for(int i = 0; i < 4; i++){
            int a = x + dx[i], b = y + dy[i];
            if(a >= 0 && a < n && b >= 0 && b < m && grid[a][b] == 1)  
                cnt += dfs(grid, a, b);
        }
        return cnt;
    }
};
```



#### [934. Shortest Bridge](https://leetcode-cn.com/problems/shortest-bridge/)

In a given 2D binary array `grid`, there are two islands. (An island is a 4-directionally connected group of `1`s not connected to any other 1s.)

Now, we may change `0`s to `1`s so as to connect the two islands together to form 1 island.

Return the smallest number of `0`s that must be flipped. (It is guaranteed that the answer is at least 1.) 

**Example 1:**

```c++
Input: grid = [[0,1],[1,0]]
Output: 1		
```

**Always use BFS to search shortest path!!! **

```c++
class Solution {
public:
    // bc we need shortest path, so BFS:
    int n, m;
    int dx[4]={-1,0,1,0}, dy[4]={0,1,0,-1};
    void print(vector<vector<int>>& A){
        for(auto x : A){
            for(auto y : x)
                cout<< y <<" ";
            cout<<endl;
        }
    }
    int shortestBridge(vector<vector<int>>& A) {
        int startPos = 2;
        int num1 = 0, num2 = 0;
        n = A.size(), m = A[0].size();// use global n and m for convenience;
        // (1) only two islands; so mark first islands as 2, second islands as 3;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(A[i][j] == 1){
                    // (1) for first islands
                    if(startPos == 2){
                        num1 += dfs(A, i, j, 2);
                        startPos++;
                    }
                    // (2) for first islands
                    else{
                        num2 += dfs(A, i, j, 3);
                    }
                }
            }
        }
        // print(A);
        // cout<< num1 <<" "<< num2<<endl;
        // num1 bigger, should start from num2: start from 3 to find 2
        if(num1 >= num2) startPos = 3;
        else startPos = 2;
        return bfs(A, startPos) - 1;
    }
    int bfs(vector<vector<int>>& A, int startPos){
        // from startPos to find target
        int target;
        if(startPos == 3) target = 2;
        else if(startPos == 2) target = 3;
        queue<pair<int,int>> q; // pair queue for coordinates
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                if(A[i][j]==startPos)
                    q.push({i,j}); // push all startPos into queue:
        int ans = 0; // shortest length
        while(!q.empty()){
            ans ++;
            int size = q.size();
            for(int i = 0; i < size; i++){
                auto cur = q.front(); q.pop();
                int x = cur.first; // row
                int y = cur.second; // column
                for(int i = 0; i < 4; i++){
                    int a = x + dx[i];
                    int b = y + dy[i];
                    if(a >= 0 && a < n && b >=0 && b < m){
                        //only expand on water
                        if(A[a][b]==0) {
                            q.push({a,b});
                            // set cur as any value except 0,1,2,3
                            // bc later visit cur box will not be shorted in BFS:
                            A[a][b] = 4; 
                        }
                        else if(A[a][b] == target) return ans;
                    }
                }
            }
        }
        return -1;
    }
    int dfs(vector<vector<int>>& A, int x, int y, int startPos){
        // todo for every startPos
        A[x][y] = startPos;
        int cnt = 1;
        for(int i = 0; i < 4; i++){
            int a = x + dx[i];
            int b = y + dy[i];
            if(a >= 0 && a < n && b >=0 && b < m && A[a][b] == 1){
                cnt += dfs(A, a, b, startPos);
            }
        }
        return cnt;
    }
};
```





## Memorization recursion

```c++
Why use Memorization recursion:
	if use normal dfs, the time complexity will be expoential so must be optimized:
```



#### [329. Longest Increasing Path in a Matrix](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

Given an `m x n` integers `matrix`, return *the length of the longest increasing path in* `matrix`.

From each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed). 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

```c++
Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
```



```c++
if use normal dfs, the time complexity will be expoential so must be optimized:
The key point of memoization recursion: 
    Return the answer directly when you encounter the searched path: if(f[x][y] != -1) return f[x][y];
```

**(1) method 1: memorization recusion: **

```c++
class Solution {
public:
    vector<vector<int>> f;
    int n, m;
    int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};
    // return the longest path length start from (x, y):
    int dfs(int x, int y, vector<vector<int>>& matrix){
        if(f[x][y] != -1) return f[x][y];
        f[x][y] = 1; 
        for(int i = 0; i < 4; i++){
            int a = x + dx[i], b = y + dy[i];
            if(a < 0 || a >= n || b < 0 || b >= m) continue; 
            if(matrix[a][b] > matrix[x][y]){ // update f[x][y]:
                f[x][y] = max(f[x][y], dfs(a, b, matrix) + 1);
            }
        }
        return f[x][y];
    }
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        n = matrix.size();
        m = matrix[0].size();
        // init all as -1, if(f[x][y]!=-1) during recursion means already searched:
        f = vector<vector<int>>(n, vector<int>(m, -1));
        int res = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                res = max(res, dfs(i, j, matrix));
            }
        }
        return res;
    }
};
```





#### [1462. Course Schedule IV](https://leetcode-cn.com/problems/course-schedule-iv/)

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `ai` first if you want to take course `bi`.

- For example, the pair `[0, 1]` indicates that you have to take course `0` before you can take course `1`.

Prerequisites can also be **indirect**. If course `a` is a prerequisite of course `b`, and course `b` is a prerequisite of course `c`, then course `a` is a prerequisite of course `c`.

You are also given an array `queries` where `queries[j] = [uj, vj]`. For the `jth` query, you should answer whether course `uj` is a prerequisite of course `vj` or not.

Return *a boolean array* `answer`*, where* `answer[j]` *is the answer to the* `jth` *query.*

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg)

```c++
Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
Output: [false,true]
Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
```

```c++
class Solution {
public:
    //e.g. if we have already know 3->4 is true for 3->2->4, 
    //when search (1,4) for 1->3->2->4, we can use the result 3->4 is true:
    vector<vector<int>> graph, mem;
    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& pre, vector<vector<int>>& queries){
        graph = vector<vector<int>>(n, vector<int>());
        // record if mem[a][b]: if a is b's pre;
        mem = vector<vector<int>> (n, vector<int>(n, 0)); 
        for(auto p : pre){
            graph[p[0]].push_back(p[1]);
        }
        vector<bool> ans;
        // bc will call dfs many times, so must use memo to optimize:
        for (auto query : queries)
            ans.push_back(dfs(query[0], query[1]));
        return ans;
    }
    bool dfs(int start, int end) {
        if (mem[start][end] == 1) return true;//means searched 
        if (mem[start][end] == -1) return false;//means can not reach
        if (start == end) return true;
        // search all start's neighbors, if neighbor 
        // can reach end means start can reach end:
        for (auto neighbor : graph[start]) {
            if (dfs(neighbor, end)) {
                mem[start][end] = 1;
                return true;
            }
        }
        // if all neighbor can not reach end, then start can not reach end:
        mem[start][end] = -1;
        return false;
    }
};
```







## Backtracking:

#### [17. Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

 

**Example 1:**

```c++
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
```



```c++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return {};
        vector<string> letters = {"abc", "def", "ghi","jkl","mno","pqrs","tuv", "wxyz"};
        // 2,3 abc def
        // state 1: a,b,c
        // state 2: ad,ae,af,bd,be,bf,cd,ce,cf;
        vector<string> state(1, "");
        // (1) for loop all digits:
        for(auto d : digits){  // O(4)
            vector<string> now;
            // (2) bc 0,1 are't used, so start from 2:
            for(auto c : letters[d-'2']){ // O(3) 
                // add cur letter after every state
                for(auto s : state){
                    now.push_back(s+c);
                }
            }
            state = now;
        }
        return state;
    }
};
```



#### [36. Valid Sudoku](https://leetcode-cn.com/problems/valid-sudoku/)

Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

1. Each row must contain the digits `1-9` without repetition.
2. Each column must contain the digits `1-9` without repetition.
3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

**Note:**

- A Sudoku board (partially filled) could be valid but is not necessarily solvable.
- Only the filled cells need to be validated according to the mentioned rules.

**Example 1:**

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```c++
Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true
```

**Example 2:**

```c++
Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
```

 **Constraints:**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` is a digit `1-9` or `'.'`.

```c++
// Time complexity: worst case O(9*9)=O(1)
// space complexity: O(9*9*3) = O(1)
class Solution {
public:
    // map or array to check if the initial board 
    bool isValidSudoku(vector<vector<char>>& board) {
        bool rows[9][9]; // 1st D : 9 rows, 2nd D: 9 numbers;
        bool cols[9][9];// 1st D : 9 cols, 2nd D: 9 numbers;
        bool subboxes[3][3][9]; // 1st D : 3 rows, 2nd D: 3 cols, 3rd D : 9 subBoxes
        memset(rows,0,sizeof(rows));
        memset(cols,0,sizeof(cols));
        memset(subboxes,0,sizeof(subboxes));

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') { // only check numbers:
                    // bc 0-index, so -1:
                    int num = c - 1 -'0';
                    
                    if (rows[i][num] 
                        || cols[j][num]  
                        || subboxes[i / 3][j / 3][num]) {
                        return false;
                    }
                    rows[i][num] = cols[j][num] = subboxes[i / 3][j / 3][num] = true;
                }
            }
        }
        return true;
    }
};
```



#### [37. Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver/)

Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy **all of the following rules**:

1. Each of the digits `1-9` must occur exactly once in each row.
2. Each of the digits `1-9` must occur exactly once in each column.
3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

The `'.'` character indicates empty cells.

**Example 1:**

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```c++
Input: board = 
[["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:
```

 

**Constraints:**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` is a digit or `'.'`.
- It is **guaranteed** that the input board has only one solution.

```c++
// Time complexity: worst case is when the board is blank, so O(9*9*9)=O(1)
// space complexity: O(9*9*3) = O(1)
class Solution {
private:
    bool rows[9][9];
    bool cols[9][9];
    bool subBoxes[3][3][9];
    bool valid;
    vector<pair<int, int>> blanks;
public:
    // try to fill all the blanks one by one, so pos start from 0
    void backtrack(vector<vector<char>>& board, int pos) {
        // when finished filling all the blanks, return;
        if (pos == blanks.size()) {
            valid = true; // stop backtrack if find one possible solution:
            return;
        }
        auto [i, j] = blanks[pos];
        // try to fill every digit on position [i,j]:
        for (int digit = 0; digit < 9 && !valid; ++digit) {
            // if can fill digit to cur position:
            if (!rows[i][digit] && !cols[j][digit] && !subBoxes[i/3][j/3][digit]) {
                // (1) fill board:
                rows[i][digit] = cols[j][digit] = subBoxes[i / 3][j / 3][digit] = true;
                board[i][j] = digit + 1 + '0';// bc array is 0-index so add 1;
                // (2) backtrack to next level:
                backtrack(board, pos + 1);
                // (3) revert changes:
                rows[i][digit] = cols[j][digit] = subBoxes[i / 3][j / 3][digit] = false;
            }
        }
    }

    void solveSudoku(vector<vector<char>>& board) {
        memset(rows, false, sizeof(rows));
        memset(cols, false, sizeof(cols));
        memset(subBoxes, false, sizeof(subBoxes));
        valid = false;
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    blanks.emplace_back(i, j);
                }
                else {
                    int digit = board[i][j] - 1 -'0';
                    rows[i][digit] = cols[j][digit] = subBoxes[i / 3][j / 3][digit] = true;
                }
            }
        }
        backtrack(board, 0);
    }
};
```



#### [39. Combination Sum](https://leetcode-cn.com/problems/combination-sum/)

Given an array of **distinct** integers `candidates` and a target integer `target`, return *a list of all **unique combinations** of* `candidates` *where the chosen numbers sum to* `target`*.* You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

It is **guaranteed** that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input. 

**Example 1:**

```c++
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```



```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path; 
  
    vector<vector<int>> combinationSum(vector<int>& c, int target) {
        // can use sum+c[i]<=traget to trim, so must sort:
        sort(c.begin(), c.end());
        dfs(c, target, 0, 0);
        return ans;
    }

    void dfs(const vector<int> & c, int target, int pos, int sum){
        if(sum > target) return;
        if(target == sum){
            ans.push_back(path);
            return;
        }
        for(int i = pos; i < c.size() && sum + c[i] <= target;i++){
            path.push_back(c[i]);
            //bc can be choose unlimited times, so dfs(i) not dfs(i+1);
            dfs(c, target, i, sum+c[i]); 
            path.pop_back();
        }
    }
};
```



#### [40. Combination Sum II](https://leetcode-cn.com/problems/combination-sum-ii/)

Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:** The solution set must not contain duplicate combinations.

**Example 1:**

```c++
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```



```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
  
    void dfs(int pos, int sum, int target, const vector<int>& c){
        if(sum == target){
            ans.push_back(path);
            return;
        }
        for(int i = pos; i < c.size(); i++){
            if(sum+c[i] > target) break; // trim
            if(i > pos && c[i] == c[i-1]) continue; // ignore dup
            path.push_back(c[i]); // choose cur
            dfs(i+1, sum+c[i], target,c); // choose cur value and keep dfs:
            path.pop_back(); // don't choose
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& c, int target) {
        sort(c.begin(),c.end()); // sort for delete dup  
        dfs(0,0,target,c);
        return ans;
    }
};
```





#### [216. Combination Sum III](https://leetcode-cn.com/problems/combination-sum-iii/)

Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:

- Only numbers `1` through `9` are used.
- Each number is used **at most once**.

Return *a list of all possible valid combinations*. The list must not contain the same combination twice, and the combinations may be returned in any order. 

**Example 1:**

```c++
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
```

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;

    vector<vector<int>> combinationSum3(int k, int n) {
        // dfs(k numbers left，start index, sum==n)
        dfs(k, 1, n);
        return ans;
    }
    void dfs(int k, int start, int sum){
        if(!k){
            if(!sum) ans.push_back(path);
            return;
        }
        // can optimize i <= 9: if there are less than k left, break.
        // if 9-i+1 >= k: ==> i <= 10 - k; so can use i<=9 or i<=10-k;
        for(int i = start; i <= 9; i++){
            path.push_back(i);
            // pass sum-i as parameter, so sum will not be changed.
            dfs(k-1, i+1, sum-i);
            path.pop_back();
        }
    }
};
```





#### [46. Permutations](https://leetcode-cn.com/problems/permutations/)

Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

**Example 1:**

```c++
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```



```c++
class Solution {
public:
    int n;
    vector<bool> st;
    vector<vector<int>> ans; 
    vector<int> path; 
    vector<vector<int>> permute(vector<int>& nums) {
        n = nums.size();
        st = vector<bool>(n);
        dfs(nums, 0);
        return ans;
    }
    void dfs(vector<int>& nums, int pos){
        // u is cur number
        if(pos == n){
            ans.push_back(path);
            return;
        }
        for(int i = 0; i < n; i++){
            // st[i]==false: index i can be choose:
            if(st[i] == false){
                // use current value
                st[i] = true;
                path.push_back(nums[i]);
                // dfs with current value:
                dfs(nums, pos + 1);
                // Rollback: not choose cur value: path.pop and reset st[i]: 
                path.pop_back();
                st[i] = false;
            }
        }
    }
};
```



#### [47. Permutations II](https://leetcode-cn.com/problems/permutations-ii/)

Given a collection of numbers, `nums`, that might contain duplicates, return *all possible unique permutations **in any order**.*

**Example 1:**

```c++
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

```c++
How to deal with the same number?
	Give order for same value by index:
  	Only use the first unused value for same number:
  For example For 1,1,1,2: 
  	If the first hasn't chosen, can not choose other 1s
```

```c++
class Solution {
private:
    vector<vector<int>> ans;
    vector<int> path;
    // bc will search from the begining for every round, 
    // so st record which value has not been used
    vector<bool> st; 
public:
    // pos: cur chosen number in path
    void dfs(vector<int>& nums, int pos) {
        if (pos == nums.size()) {
            ans.push_back(path);
            return;
        }
        for (int i = 0; i < (int)nums.size(); ++i) {
            if (st[i]) continue; // if nums[i] has been chosen
            // how to deal with the same number?
            // give order for same value by index:
            //   only use the first unused value for same number:
            // for example For 1,1,1,2: 
            // if the first hasn't chosen, can not choose other 1s
            if ((i > 0 && nums[i] == nums[i - 1] && st[i - 1]==false)) {
                continue;
            }
            path.push_back(nums[i]);
            st[i] = true;
            dfs(nums, pos + 1);
            st[i] = false;
            path.pop_back();
        }
    }

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        st.resize(nums.size());
        sort(nums.begin(), nums.end());
        dfs(nums, 0);
        return ans;
    }
};
```



#### [51. N-Queens](https://leetcode-cn.com/problems/n-queens/)

The **n-queens** puzzle is the problem of placing `n` queens on an `n x n`chessboard such that no two queens attack each other.

Given an integer `n`, return *all distinct solutions to the **n-queens puzzle***. You may return the answer in **any order**.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```c++
Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
```

**Example 2:**

```c++
Input: n = 1
Output: [["Q"]]
```

**Constraints:**

- `1 <= n <= 9`

```c++
class Solution {
private:
vector<vector<string>> ans;
// row is number of row during recursion:
void backtracking(int n, int row, vector<string>& chessboard) {
    if (row == n) {
        ans.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) {
        // check if can put Q at [row][col]:
        if (isValid(row, col, chessboard, n)) {  
            chessboard[row][col] = 'Q'; // put Q
            backtracking(n, row + 1, chessboard);
            chessboard[row][col] = '.'; // revert Q
        }
    }
}
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    // check if has other Qs on cur col:
    for (int i = 0; i < row; i++) 
        if (chessboard[i][col] == 'Q') 
            return false;
    // check if has other Qs on top-left
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) 
        if (chessboard[i][j] == 'Q') 
            return false;
    // check if has other Qs on top-right
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) 
        if (chessboard[i][j] == 'Q') 
            return false;
    return true;
}
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<string> chessboard(n, string(n, '.'));
        backtracking(n, 0, chessboard);
        return ans;
    }
};
```



#### [77. Combinations](https://leetcode-cn.com/problems/combinations/)

Given two integers `n` and `k`, return *all possible combinations of* `k` *numbers out of the range* `[1, n]`. You may return the answer in **any order**. 

**Example 1:**

```c++
Input: n = 4, k = 2
Output:
[[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]
```

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;

    vector<vector<int>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }
    // k is numbers still can be truth 
    void dfs(int pos, int n, int k){
        // when k==0: can not choose more numbers:
        if(!k){
            ans.push_back(path);
            return;
        }
        // can choose from pos to n:
        for(int i = pos; i <= n; i++){
            // choose cur value:
            path.push_back(i);
            // dfs(index in nums++, n still n, num can be chosen--)
            dfs(i+1, n, k-1);
            // rollback, not choose cur value:
            path.pop_back();
        }
    }
};
```



#### [78. Subsets](https://leetcode-cn.com/problems/subsets/)

Given an integer array `nums` of **unique** elements, return *all possible subsets (the power set)*.

The solution set **must not** contain duplicate subsets. Return the solution in **any order**. 

**Example 1:**

```c++
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

````c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    // pos: position in nums:
    void dfs(vector<int> &nums, int pos){
        if(pos == nums.size()) return;
        for(int i = pos; i < nums.size(); i++){
            path.push_back(nums[i]);
            ans.push_back(path); 
            dfs(nums, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        ans.push_back({});
        dfs(nums, 0);
        return ans;
    }
};
````



#### [90. Subsets II](https://leetcode-cn.com/problems/subsets-ii/)

Given an integer array `nums` that may contain duplicates, return *all possible subsets (the power set)*. The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

**Example 1:**

```c++
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
```

```c++
Compared to 78 Subset I:
	Only need to sort and add if(i > pos && nums[i] == nums[i-1]) continue;
```

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;

    void dfs(vector<int>& nums, int pos){
        if(pos == nums.size()) return;
        for(int i = pos; i < nums.size(); i++){
            if(i > pos && nums[i] == nums[i-1]) continue;
            path.push_back(nums[i]);
            ans.push_back(path); 
            dfs(nums, i+1);
            path.pop_back();
        }
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        // must sort to deal with dup situation;
        sort(nums.begin(), nums.end());
        ans.push_back({});
        dfs(nums, 0);
        return ans;
    }
};
```



#### [131. Palindrome Partitioning](https://leetcode-cn.com/problems/palindrome-partitioning/)

Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.

A **palindrome** string is a string that reads the same backward as forward.

**Example 1:**

```c++
Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]
```



```c++
class Solution {
private:
    vector<vector<int>> f;  // f[i][j]: if s[i] to s[j] is a Palindrome
    vector<vector<string>> ans; 
    vector<string> path;
    int n;
public:
    // enum all the spilt point:
    void dfs(const string & s, int i){
        if(i == n){
            ans.push_back(path);
            return;
        }
        for(int j = i; j < n; j++){
            // trim: only when from i to j is Palindrome, spilt
            if(f[i][j]){
                path.push_back(s.substr(i, j-i+1));
                // keep enuming the rest of spilt points from j+1:
                dfs(s,j+1);
                // rollback
                path.pop_back();
            }
        }
    }
    vector<vector<string>> partition(string s) {
        n = s.size();
        f = vector<vector<int>> (n, vector<int>(n, 1));
        // DP to get if s[i] to s[j] is Palindrome:
        // bc need i+1 to update i, so i from n-1 to 0:
        // bc need j-1 to update j, so j from i+1 to n:
        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = ((s[i] == s[j]) && f[i + 1][j - 1]);
            }
        }
        // backtracking to get all possible path
        dfs(s, 0);
        return ans;
    }
};
```

#### [489. Robot Room Cleaner](https://leetcode-cn.com/problems/robot-room-cleaner/)

You are controlling a robot that is located somewhere in a room. The room is modeled as an `m x n` binary grid where `0`represents a wall and `1` represents an empty slot.

The robot starts at an unknown location in the root that is guaranteed to be empty, and you do not have access to the grid, but you can move the robot using the given API `Robot`.

You are tasked to use the robot to clean the entire room (i.e., clean every empty cell in the room). The robot with the four given APIs can move forward, turn left, or turn right. Each turn is `90`degrees.

When the robot tries to move into a wall cell, its bumper sensor detects the obstacle, and it stays on the current cell.

Design an algorithm to clean the entire room using the following APIs:

```c++
interface Robot {
  // returns true if next cell is open and robot moves into the cell.
  // returns false if next cell is obstacle and robot stays on the current cell.
  boolean move();

  // Robot will stay on the same cell after calling turnLeft/turnRight.
  // Each turn will be 90 degrees.
  void turnLeft();
  void turnRight();

  // Clean the current cell.
  void clean();
}
```

**Note** that the initial direction of the robot will be facing up. You can assume all four edges of the grid are all surrounded by a wall.

**Custom testing:**

The input is only given to initialize the room and the robot's position internally. You must solve this problem "blindfolded". In other words, you must control the robot using only the four mentioned APIs without knowing the room layout and the initial robot's position.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/07/17/lc-grid.jpg)

```c++
Input: room = [[1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1],[1,0,1,1,1,1,1,1],[0,0,0,1,0,0,0,0],[1,1,1,1,1,1,1,1]], row = 1, col = 3
Output: Robot cleaned all rooms.
Explanation: All grids in the room are marked by either 0 or 1.
0 means the cell is blocked, while 1 means the cell is accessible.
The robot initially starts at the position of row=1, col=3.
From the top left corner, its position is one row below and three columns right.
```

**Constraints:**

- `m == room.length`
- `n == room[i].length`
- `1 <= m <= 100`
- `1 <= n <= 200`
- `room[i][j]` is either `0` or `1`.
- `0 <= row < m`
- `0 <= col < n`
- `room[row][col] == 1`
- All the empty cells can be visited from the starting position.

```c++
/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * class Robot {
 *   public:
 *     // Returns true if the cell in front is open and robot moves into the cell.
 *     // Returns false if the cell in front is blocked and robot stays in the current cell.
 *     bool move();
 *
 *     // Robot will stay in the same cell after calling turnLeft/turnRight.
 *     // Each turn will be 90 degrees.
 *     void turnLeft();
 *     void turnRight();
 *
 *     // Clean the current cell.
 *     void clean();
 * };
 */
```



```c++
// (1) method 1: 
class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = { 0, 1, 0, -1};
    void dfs(Robot& robot, set<pair<int, int>>& visited, int x, int y, int dir){
        robot.clean(); 
        for(int i = 1; i <= 4; i++){ 
            robot.turnRight(); // why turn right here???
            int new_dir = (dir + i) % 4; 
            int xx = x + dr[new_dir]; 
            int yy = y + dc[new_dir]; 
            if(visited.find({xx, yy}) != visited.end()) continue;
            visited.insert({xx, yy}); 
            // if can clean() keep moving in same dir
            // call robot.move() when it's ture, the robot will move forward:
            if(robot.move()){ 
                dfs(robot, visited, xx, yy, new_dir); 
                // backtrack to last position:
                robot.turnRight();
                robot.turnRight(); 
                robot.move(); 
                robot.turnRight();
                robot.turnRight();
            }
        }
    }
    void cleanRoom(Robot& robot) {
        set<pair<int, int>> visited;
        visited.insert({0, 0});
        dfs(robot, visited, 0, 0, 0);
    }
};
```



```c++
// (2) method 2: 
class Solution {
public:
    int dirs[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    set<pair<int, int>> visited;

    void cleanRoom(Robot& robot) {
        dfs(robot, 0, 0, 0);
    }
    void dfs (Robot& robot, int r, int c, int di){ 
        visited.insert({r, c});
        robot.clean();
        for (int d = 0; d < 4; d ++) {
            int ndi = (di + d) % 4;
            int dr = dirs[ndi][0];
            int dc = dirs[ndi][1];
            int nr = r + dr;
            int nc = c + dc;
            if (visited.find({nr,nc}) == visited.end() && robot.move() == true) {
                dfs(robot, nr, nc, ndi);
                robot.turnRight();
                robot.turnRight();
                robot.move();
                robot.turnRight();
                robot.turnRight();
            }
            robot.turnRight(); // why turn right here
        }
    }
};
```

#### [784. Letter Case Permutation](https://leetcode-cn.com/problems/letter-case-permutation/)

Given a string `s`, we can transform every letter individually to be lowercase or uppercase to create another string.

Return *a list of all possible strings we could create*. You can return the output in **any order**.

**Example 1:**

```c++
Input: s = "a1b2"
Output: ["a1b2","a1B2","A1b2","A1B2"]
```



````c++
class Solution {
public:
    vector<string> ans; 
    vector<string> letterCasePermutation(string S) {
        dfs(S, 0);
        return ans;
    }
    void dfs(string& S, int cur){
        if(cur == S.size()){
            ans.push_back(S);
            return;
        }
        // branch 1: don't modify cur
        dfs(S, cur+1);
        // branch 2: if isalpha to check if cur is a letter
        if(isalpha(S[cur])){
            S[cur] ^= 32; // letter ^= 32: switch between upper and lower
            dfs(S, cur+1);
        }
    }
};
````





## Spiral Matrixs:

#### [54. Spiral Matrix](https://leetcode-cn.com/problems/spiral-matrix/)

Given an `m x n` `matrix`, return *all elements of the* `matrix` *in spiral order*. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```



```c++
class Solution {
public:
    int dx[4] = {0, -1, 0, 1}, dy[4] = {1, 0, -1, 0};
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return {};
        int n = matrix.size(), m = matrix[0].size();
        vector<int>  ans(n*m, 0);
        vector<vector<int>> mem(n, vector<int>(m, 0));
        // (1) init:
        ans[0] = matrix[0][0];
        mem[0][0] = 1; 
        int x = 0, y = 0; // cur point (x, y)
        int dir = 0; // trav dir
        int cnt = 1; // count
        // (2) trav:
        while(cnt < n*m){
            int a = x + dx[dir];
            int b = y + dy[dir];
            if(a >=0 && a < n && b >=0 && b < m && mem[a][b]==0){
                ans[cnt] = matrix[a][b];
                mem[a][b] = 1;
                cnt ++;
                // must update new position of (x, y) !!!!
                x = a;
                y = b;

            } else{
                dir = (dir+1) % 4;
            }

        }
        return ans;
    }
};
```



#### [59. Spiral Matrix II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

```c++
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
```



```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int dx[4] = {0, -1, 0, 1}, dy[4] = {1, 0, -1, 0};
        if(n == 0) return {{}};
        vector<vector<int>> mem(n, vector<int>(n, 0));
        vector<vector<int>> ans(n, vector<int>(n, 0));
        // (1) init:
        ans[0][0] = 1;
        mem[0][0] = 1; 
        int x = 0, y = 0; // cur point (x, y)
        int dir = 0; // trav dir
        int cnt = 1; // count
        // (2) trav:
        while(cnt < n*n){
            int a = x + dx[dir];
            int b = y + dy[dir];
            if(a >=0 && a < n && b >=0 && b < n && mem[a][b]==0){
                ans[a][b] = cnt+1;
                mem[a][b] = 1;
                cnt ++;
                // must update new position of (x, y) !!!!
                x = a;
                y = b;

            } else{
                dir = (dir+1) % 4;
            }

        }
        return ans;
    }
};
```



#### [885. Spiral Matrix III](https://leetcode-cn.com/problems/spiral-matrix-iii/)

You start at the cell `(rStart, cStart)` of an `rows x cols` grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.

You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all `rows * cols` spaces of the grid.

Return *an array of coordinates representing the positions of the grid in the order you visited them*.

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png)

```c++
Input: rows = 1, cols = 4, rStart = 0, cStart = 0
Output: [[0,0],[0,1],[0,2],[0,3]]
```



```c++
class Solution {
public:
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};
    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {
        vector<vector<int>> res{{x, y}};
        for (int i = 0; res.size() < R * C; ++i) {
          	// every 2 round will change dir and step size++
          	// so every round step size = i/2+1;
            for (int j = 0; j < i / 2 + 1; ++j) {  
                // next point(x, y)
                x += dx[i%4];
                y += dy[i%4];
                // only add when in matrix:
                if (0 <= x && x < R && 0 <= y && y < C) { 
                    res.push_back({x, y});
                }
            }
        }
        return res;
    }
};
```





## Normal DFS:

#### [529. Minesweeper](https://leetcode-cn.com/problems/minesweeper/)

Let's play the minesweeper game ([Wikipedia](https://en.wikipedia.org/wiki/Minesweeper_(video_game)), [online game](http://minesweeperonline.com/))!

You are given an `m x n` char matrix `board` representing the game board where:

- `'M'` represents an unrevealed mine,
- `'E'` represents an unrevealed empty square,
- `'B'` represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),
- digit (`'1'` to `'8'`) represents how many mines are adjacent to this revealed square, and
- `'X'` represents a revealed mine.

You are also given an integer array `click` where `click = [clickr, clickc]` represents the next click position among all the unrevealed squares (`'M'` or `'E'`).

Return *the board after revealing this position according to the following rules*:

1. If a mine `'M'` is revealed, then the game is over. You should change it to `'X'`.
2. If an empty square `'E'` with no adjacent mines is revealed, then change it to a revealed blank `'B'` and all of its adjacent unrevealed squares should be revealed recursively.
3. If an empty square `'E'` with at least one adjacent mine is revealed, then change it to a digit (`'1'` to `'8'`) representing the number of adjacent mines.
4. Return the board when no more squares will be revealed.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png)

```c++
Input: board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]], click = [3,0]
Output: [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png)

```c++
Input: board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]], click = [1,2]
Output: [["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
```



```c++
class Solution {
public:
    // dfs to reveal all the rest blank square to 'B'
    int n, m;
    int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        // we only have 2 situations:
        // (1) click M, change M to 'X' return board
        int x = click[0], y = click[1];
        n = board.size(), m = board[0].size();
        if(board[x][y] == 'M'){
            board[x][y] = 'X'; 
            return board;
        }
        // (2) click an empty square E with no adjacent mines, change all adj unrevealed square : dfs
        if(board[x][y] == 'E') dfs(board, x, y);
        return board;
    }   

    char itoa(int cnt){
        vector<char> ans = {'1','2','3','4','5', '6', '7', '8'};
        return ans[cnt-1];
    }

    void dfs(vector<vector<char>>& board, int x, int y){
        if(board[x][y] != 'E') return;
        int cnt = 0; // count how many mines around
        for(int i = 0; i < 8; i++){
            int x1 = x + dx[i], y1 = y + dy[i];
            if(x1 >= 0 && x1 < n && y1 >= 0 && y1 < m){
                if(board[x1][y1] == 'M') cnt++;
            }
        }
        if(cnt == 0) board[x][y] = 'B';
        else{
            board[x][y] = itoa(cnt);
            return;
        }
        for(int i = 0; i < 8; i++){
            int a = x + dx[i], b = y + dy[i];
            if(a >= 0 && a < n && b >= 0 && b < m){
                if(board[a][b] == 'E')
                    dfs(board, a, b); 
            }
        }
    }
};
```



#### [661. Image Smoother](https://leetcode-cn.com/problems/image-smoother/)

An **image smoother** is a filter of the size `3 x 3` that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).

![img](https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg)

Given an `m x n` integer matrix `img` representing the grayscale of an image, return *the image after applying the smoother on each cell of it*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg)

```c++
Input: img = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[0,0,0],[0,0,0],[0,0,0]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
```



```c++
class Solution {
public:
    int dx[8] = {1 , -1 , 0 , 0 , 1 , 1 , -1 , -1};
    int dy[8] = {0 , 0 , 1 , -1 , -1 , 1 , -1 , 1};
    vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
        int n = M.size(), m = M[0].size();
        // calculate avg of surround 8 grids
        vector<vector<int>> num(n, vector<int>(m, 0));
        for(int i = 0 ; i < n ; i++){
            for(int j = 0 ; j < m ; j++){
                int count = 1;// not all
                int sum = M[i][j]; 
                for(int k = 0 ; k < 8 ; k++){
                    int x = i + dx[k];
                    int y = j + dy[k];
                    if(x >= 0 && x < n && y >= 0 && y < m){
                        count++;           
                        sum += M[x][y];
                    }
                }
                num[i][j] = sum / count;
            }
        }
        return num;
    }
};
```







# BFS:

## Double-ended BFS: 

**Double-ended BFS used when know start and end point: **

|                  | Time Complexity       | Space Complexity | Data Structure     | when stop searching                   |
| ---------------- | --------------------- | ---------------- | ------------------ | ------------------------------------- |
| Normal BFS       | O(2^n)                | O(n)             | Queue              | find end point                        |
| Double-ended BFS | O(2^(n/2) * log(n/2)) | O(n)             | Set, unordered_set | beginSet has intersection with endSet |

2 ^ 10 ==> 10^3, so 2 ^ 30 will be 10^9

so when n > 30, 2^n is not acceptable.

#### [1755. Closest Subsequence Sum](https://leetcode-cn.com/problems/closest-subsequence-sum/)

You are given an integer array `nums` and an integer `goal`.

You want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to **minimize the absolute difference** `abs(sum - goal)`.

Return *the **minimum** possible value of* `abs(sum - goal)`.

Note that a subsequence of an array is an array formed by removing some elements **(possibly all or none)** of the original array.

**Example 1:**

```c++
Input: nums = [5,-7,3,5], goal = 6
Output: 0
Explanation: Choose the whole array as a subsequence, with a sum of 6.
This is equal to the goal, so the absolute difference is 0.
```



```c++
const int N = 2000010;
int q[N];
class Solution {
public:
    // 爆搜, 因为数据范围是40，所以单项dfs: 2^40 会超时，
    // 采用双向dfs，2^20 * log(2^20) = 2^20 * 20 可以通过
    int n; // nums 数组长度
    int cnt; // q[N]中的子序列和的数量
    int goal; // goal
    int ans;
    // u: 当前搜到第几个元素了，搜到nums的一半停止
    // s: 当前搜索的子序列和是多少(nums左半部分); 
    void dfs1(vector<int> &nums, int u, int s){
        // 如果搜到了nums的中点，return
        if(u == (n+1)/2) {
            // 每搜出来一个结果就存到q[cnt]中，然后把cnt++
            q[cnt++] = s;
            return;
        } 
        dfs1(nums, u+1, s);
        dfs1(nums, u+1, s+nums[u]);
    }
    // u: 当前搜到第几个元素了，搜到nums的一半停止
    // s: 当前搜索的子序列和是多少(nums右半部分);
    void dfs2(vector<int> &nums, int u, int s){
        if(u == n){
            // 如果右半边也搜索完成了， 那么我们就是找左边和右边的子序列和与goal的关系
            // 对左边排好序的 0 - cnt进行2分，
            int l = 0, r = cnt-1;
            while(l < r){
                int mid = (l + r + 1) >> 1;
                if(q[mid] + s <= goal) l = mid;
                else r = mid - 1;
            }
            // 二分完，q[r]应该是小于goal最大的数
            // q[r+1]如果存在，就是大于goal最小的数
            ans = min(ans, abs(q[r]+s-goal));
            // 如果r不是 前一半的最后一个元素，要检查最后一个元素
            if(r != cnt-1)
                ans = min(ans, abs(q[r+1]+s-goal));
            return;
        }
        dfs2(nums, u+1, s);
        dfs2(nums, u+1, s+nums[u]);
    }
    int minAbsDifference(vector<int>& nums, int _goal) {
        n = nums.size(), cnt = 0, goal = _goal, ans = INT_MAX;
        dfs1(nums, 0, 0);
        sort(q, q+cnt);
        dfs2(nums, (n+1)/2, 0);
        return ans;
    }
};
```



#### [127. Word Ladder](https://leetcode-cn.com/problems/word-ladder/)

A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:

- Every adjacent pair of words differs by a single letter.
- Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
- `sk == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *the **number of words** in the **shortest transformation sequence** from* `beginWord` *to* `endWord`*, or* `0` *if no such sequence exists.*

**Example 1:**

```c++
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

Constraints:
1 <= beginWord.length <= 10
endWord.length == beginWord.length
1 <= wordList.length <= 5000
wordList[i].length == beginWord.length
beginWord, endWord, and wordList[i] consist of lowercase English letters.
beginWord != endWord
All the words in wordList are unique.
```

**1. Double-ended BFS: if n is more than 30, normal BFS is not acceptable: **

```c++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // unordered_set to check if word in wordList
        unordered_set<string> wordSet(wordList.begin(), wordList.end());
        if(wordSet.find(endWord) == wordSet.end()) return 0; // endWord must in wordList;
        unordered_set<string> beginSet{beginWord};
        unordered_set<string> endSet{endWord};
        int steps = 1; // bc when find in end return, so init to 1;
        // do double-ended BFS, so use two set: beginSet, endSet;
        while(!beginSet.empty())
        {
            steps++;
            unordered_set<string> nextSet;
            for(auto word : beginSet) wordSet.erase(word);
            // try to change every single char in word, to do BFS
            for(auto word : beginSet){
                for(int i = 0; i < word.size(); i++)
                {
                    string nextWord = word;

                    for(char j = 'a'; j <= 'z'; j++)
                    {
                        nextWord[i] = j;
                        if(endSet.count(nextWord)) return steps;
                        if(wordSet.count(nextWord)){
                            nextSet.insert(nextWord);
                        }
                    }
                }
            }
            beginSet = nextSet;
            if(beginSet.size() > endSet.size()){
                swap(beginSet, endSet);
            }
        }
        return 0; // no such sequence
    }
};
```

**2. normal BFS, when n < 30, O(2^n) is acceptable**

```c++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        queue<string> q; q.push(beginWord);
        int min_dis = 0;
        while(!q.empty())
        {
            min_dis++; 
            int size = q.size();
            for(int sz = 0; sz < size; sz++)
            {
                string node = q.front(); q.pop();
                if(node == endWord) return min_dis;
                for(auto & w: wordList)
                {
                    if(w.size() != beginWord.size()) continue;
                    int diff = 0;
                    for(int i = 0; i < w.size() && diff <= 1; i++)
                    {
                        if(w[i] != node[i]){
                            ++diff;
                            if(diff > 1) break;
                        }
                    }
                    // if diff == 1: possible for next step
                    if(diff == 1)
                    {
                        q.push(w);
                        w = ""; // BFS rule: no search on same word
                    }
                }
            }
        }
        return 0;
    }
};
```



## Normal BFS:

#### [126. Word Ladder II](https://leetcode-cn.com/problems/word-ladder-ii/)

A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:

- Every adjacent pair of words differs by a single letter.
- Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
- `sk == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *all the **shortest transformation sequences** from* `beginWord` *to* `endWord`*, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words* `[beginWord, s1, s2, ..., sk]`.

**Example 1:**

```c++
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
Explanation: There are 2 shortest transformation sequences:
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"
```



```c++
class Solution {
public:
vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> correct(wordList.begin(),wordList.end());
        vector<vector<string>> ans;
        queue<vector<string>> paths;
        paths.push({beginWord});
        int level = 1;
        int len;
        int minLevel = INT_MAX;
        unordered_set<string> visited;
        while(!paths.empty()) {
            vector<string> path = paths.front(); paths.pop();
            if (path.size() > level) {
                for (string w : visited) 
                    correct.erase(w);
                visited.clear();
                if (path.size() > minLevel) return ans;
                else level = path.size();
            }
            string last = path.back();
            len = last.size();
            for (int i = 0; i < len;i++) 
            {
                string news = last;
                for (char c = 'a'; c <= 'z';c++) 
                {
                    news[i] = c;
                    if (correct.count(news)) 
                    {
                        vector<string> newpath = path;
                        newpath.push_back(news);
                        visited.insert(news);
                        if (news == endWord) {
                            minLevel = level;
                            ans.push_back(newpath);
                        } else {
                            paths.push(newpath);
                        }
                    }
                }
            }
        }
        return ans;
    }
};
```



```c++
class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList) {
        vector<vector<string>> ans;
        unordered_set<string> dict = {wordList.begin(), wordList.end()};
        if (dict.find(endWord) == dict.end()) return ans;
        // 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层
        unordered_map<string, int> steps = {{beginWord, 0}};
        //记录单词是从哪些单词扩展而来,key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系
        unordered_map<string, set<string>> from = {{beginWord, {}}};
        int step = 0;
        bool found = false;
        queue<string> q;
        q.push(beginWord);
        dict.erase(beginWord); // beginWord does not need to be in wordList. 
        int wordLen = beginWord.length();
        while (!q.empty()) {
            step++;
            int size = q.size();
            for (int i = 0; i < size; i++) {
                string currWord = move(q.front());q.pop();
                for (int j = 0; j < wordLen; ++j) { // change every letter to another
                    string nextWord = currWord;
                    for (char c = 'a'; c <= 'z'; ++c) {
                        nextWord[j] = c;
                        // key-val : word-step, if steps[nextWord]!=step: not shortest;
                        if (steps[nextWord] == step) {
                            from[nextWord].insert(currWord);
                        }
                        if (dict.find(nextWord) == dict.end()) continue;
                        dict.erase(nextWord);
                        q.push(nextWord);
                        // 记录 nextWord 从 currWord 而来
                        from[nextWord].insert(currWord);
                        // 记录 nextWord 的 step
                        steps[nextWord] = step;
                        if (nextWord == endWord) found = true;
                    }
                }
            }
            if (found) break;
        }
        // step 2: dfs to find all paths: from endWord to beginWord 
        if (found) {
            vector<string> path = {endWord};
            dfs(ans, endWord, from, path);
        }
        return ans;
    }

    void dfs(vector<vector<string>> &ans, const string &Node, 
        unordered_map<string, set<string>> &from,
             vector<string> &path) {
        if (from[Node].empty()) {
            ans.push_back({path.rbegin(), path.rend()});
            return;
        }
        for (const string &Parent: from[Node]) {
            path.push_back(Parent);
            dfs(ans, Parent, from, path);
            path.pop_back();
        }
    }
};
```



#### [279. Perfect Squares](https://leetcode-cn.com/problems/perfect-squares/)

Given an integer `n`, return *the least number of perfect square numbers that sum to* `n`.

A **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.

 **Example 1:**

```c++
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
```

**Example 2:**

```
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

**Constraints:**

- `1 <= n <= 104`

```c++
class Solution {
public: 
    // this is a graph problem, assume there are n+1 points:
    // 0, 1, 2, 3, ... n;
    // if a + b = c: a has one path to c that weight==1;
    // so BFS to get shortest distance from 0 to n;
    int numSquares(int n) {
        queue<int> q;
        // dist[i] : distance from 0 to i,dist[n] is answer;
        vector<int> dist(n+1, INT_MAX); 
        q.push(0);
        dist[0] = 0;
        while(q.size()){
            int t = q.front(); q.pop();
            if(t == n) return dist[t];  
            // enum from 1^2 to i*i + t<=n and update dist[t];
            // e.g. n = 13, 0 can reach 1，4，9 in one step
            // so dist[1] = dist[4] = dist[9] = 1;
            // then push 1，4，9 in queue
            // bc only need to check the node that 
            // can reach from last round
            for(int i = 1; i*i + t <= n; i++){
                int j = t + i * i;
                // update when old value in dist[j] is bigger
                if(dist[j] > dist[t]+1){
                    dist[j] = dist[t] + 1;
                    q.push(j);
                }
            }
        }
        return 0;
    }
};
```

#### [407. Trapping Rain Water II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

难度困难386

Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return *the volume of water it can trap after raining*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg)

```
Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation: After the rain, water is trapped between the blocks.
We have two small pounds 1 and 3 units trapped.
The total volume of water trapped is 4.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg)

```c++
Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
Output: 10
```

**Constraints:**

- `m == heightMap.length`
- `n == heightMap[i].length`
- `1 <= m, n <= 200`
- `0 <= heightMap[i][j] <= 2 * 104`

```c++
class Solution {
public:
    // BFS + priority_queue :
    int trapRainWater(vector<vector<int>>& height) {
        int n = height.size(), m = height[0].size();
        using Pair = pair<int, int>;
        priority_queue<Pair, vector<Pair>, greater<Pair>> que;
        // first push all boundaries to minHeap;
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < m; ++j){
                if(i == 0 || j == 0 || i == n-1 || j == m-1){
                    que.push({height[i][j], i*m + j});
                    height[i][j] = -1; // after visited, mark as -1;
                }
            }
        }
        int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
        int ans = 0, maxH = INT_MIN;
        while(!que.empty()){
            auto cur = que.top(); que.pop();
            int h = cur.first, i = cur.second/m, j = cur.second%m;
            if(h > maxH) maxH = h;
            for(int k = 0; k < 4; ++k) {
                int a = i + dx[k];
                int b = j + dy[k];
                if(a >= 0 && a < n && b >= 0 && b < m && height[a][b] != -1) {
                    que.push({height[a][b], a*m + b});
                    if(height[a][b] < maxH) ans += maxH - height[a][b];
                    height[a][b] = -1;
                }
            }
        }
        return ans;
    }
};
```



#### [490. The Maze](https://leetcode-cn.com/problems/the-maze/)

There is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the `m x n` `maze`, the ball's `start` position and the `destination`, where `start = [startrow, startcol]` and `destination = [destinationrow, destinationcol]`, return `true` if the ball can stop at the destination, otherwise return `false`.

You may assume that **the borders of the maze are all walls** (see examples).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/31/maze1-1-grid.jpg)

```c++
Input: maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]
Output: true
Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.
```

**(1) BFS**

```c++
class Solution {
public:
    int dx[4] = {-1, 0, 1 , 0}, dy[4] = {0, 1, 0, -1};
    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) 
    {   
        int Row = maze.size(),  Col = maze[0].size();
        vector<vector<bool>> visited(Row, vector<bool>(Col, false));
        queue<pair<int,int>> Q;
        Q.push({start[0], start[1]});  // search from start
        visited[start[0]][start[1]] = true;
        while (Q.size())
        {
            auto [x, y] = Q.front(); Q.pop();
            // if reach the dest, return true;
            if (x == destination[0] && y == destination[1])  return true;
            for(int i = 0; i < 4; i++)
            {
                int a = x + dx[i];
                int b = y + dy[i];
                while (0 <= a && a < Row && 0 <= b && b < Col && maze[a][b] == 0)  //can move in cur direction
                {
                    a += dx[i];    
                    b += dy[i];   
                }
                // hit the wall, go back one step
                a -= dx[i];   
                b -= dy[i];   
                // if point(a,b) has been visited, no need to go further
                // whatever (a, b) lead to dest, it will be sloved in other branch
                if (visited[a][b] == false)   
                {
                    Q.push({a, b});
                    visited[a][b] = true;    
                }
            }
        }
        return false;    
    }
};
```



#### [582. Kill Process](https://leetcode-cn.com/problems/kill-process/): find all children and grandchildren of node

You have `n` processes forming a rooted tree structure. You are given two integer arrays `pid` and `ppid`, where `pid[i]` is the ID of the `ith` process and `ppid[i]` is the ID of the `ith` process's parent process.

Each process has only **one parent process** but may have multiple children processes. Only one process has `ppid[i] = 0`, which means this process has **no parent process** (the root of the tree).

When a process is **killed**, all of its children processes will also be killed.

Given an integer `kill` representing the ID of a process you want to kill, return *a list of the IDs of the processes that will be killed. You may return the answer in **any order**.*

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/24/ptree.jpg)

```c++
Input: pid = [1,3,10,5], ppid = [3,0,5,3], kill = 5
Output: [5,10]
Explanation: The processes colored in red are the processes that should be killed.
```

**Example 2:**

```c++
Input: pid = [1], ppid = [0], kill = 1
Output: [1]
```

**Constraints:**

- `n == pid.length`
- `n == ppid.length`
- `1 <= n <= 5 * 104`
- `1 <= pid[i] <= 5 * 104`
- `0 <= ppid[i] <= 5 * 104`
- Only one process has no parent.
- All the values of `pid` are **unique**.
- `kill` is **guaranteed** to be in `pid`.

 

**(1) method 1:  unordered_map<int, vector<int>> ump + DFS:**

```c++
class Solution {
public:
    unordered_map<int, vector<int>> ump;
    vector<int> ans;

    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        int n = pid.size();
        for(int i = 0; i < n; i++){
            ump[ppid[i]].push_back(pid[i]);
        }
        dfs(kill);
        ans.push_back(kill);
        return ans;
    }
    void dfs(int kill){
        for(auto child : ump[kill]){
            dfs(child);
            ans.push_back(child);
        }
    }
};


```



**(1) method 1: unordered_multimap<int, int> + BFS**

```c++
class Solution {
public:
    // bc every pid may has a few children, so use unordered_multimap<int, int>
    unordered_multimap<int, int> ump; // <ppid, pid>
    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        queue<int> q;
        q.push(kill);
        vector<int> ans;
        ans.push_back(kill);
        for(int i = 0; i < pid.size(); i++){
            ump.insert({ppid[i], pid[i]});
        }
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                int cur = q.front(); q.pop();
                // unordered_multimap<int,int> ump.equal_range(x):
                // return the boundary of the range containing all key elements 
                // in the container which is equal to x.
                // return type: pair<multimap<int, int>::iterator,multimap<int, int>::iterator> 
                auto child = ump.equal_range(cur);
                for(auto it = child.first; it != child.second; it++){
                    q.push(it->second);
                    ans.push_back(it->second);
                }
            }
        }
        return ans;
    }
};
```

**(2) unordered_multimap<int, int> + DFS  **

```c++
or use core is to use 

class Solution {
public:
    // bc every pid may has a few children, so use unordered_multimap<int, int>
    unordered_multimap<int, int> ump; // <ppid, pid>
    vector<int> ans;
    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        ans.push_back(kill);
        for(int i = 0; i < pid.size(); i++){
            ump.insert({ppid[i], pid[i]});
        }
        dfs(kill);
        return ans;
    }
    void dfs(int kill){
        auto child = ump.equal_range(kill);
        for(auto it = child.first; it != child.second; it++){
            dfs(it->second);
            ans.push_back(it->second);
        }
    }
};
```



#### [752. Open the Lock](https://leetcode-cn.com/problems/open-the-lock/)

You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'`. The wheels can rotate freely and wrap around: for example we can turn `'9'` to be `'0'`, or `'0'` to be `'9'`. Each move consists of turning one wheel one slot.

The lock initially starts at `'0000'`, a string representing the state of the 4 wheels.

You are given a list of `deadends` dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a `target` representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

**Example 1:**

```c++
Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
Output: 6
Explanation:
A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".
Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end "0102".
```

**(1) BFS **

```c++
class Solution {
public:
    string plusOne(string str,int i){ //num +1: str[i] is char!!!
        str[i] = (str[i]=='9') ?'0':str[i]+1;
        return str;
    }
    string downOne(string str,int i){ //num -1: str[i] is char!!!
        str[i] = str[i]=='0'?'9':str[i]-1;
        return str;
    }

    int openLock(vector<string>& deadends, string target) {
        // set: O(1) check if it's deadcode
        unordered_set<string> deadset(deadends.begin(),deadends.end()); 
        unordered_set<string> visited; // code visited
        visited.insert("0000"); // start from "0000"
        queue<string> q;
        q.push("0000");
        int step=0;
        while(!q.empty())
        {
            int size = q.size(); 
            for(int i = 0;i < size;i++)
            {
                string cur = q.front(); q.pop();
                if(deadset.count(cur)) continue; // no further bfs
                if(cur==target) return step; //reach target, return steps;
                for(int i = 0;i < 4;i++) // (up,down)*4 = 8 possibles
                {
                    // check going up
                    string up = plusOne(cur,i); 
                    if(!visited.count(up))      
                    {
                        q.push(up);              
                        visited.insert(up);      
                    }
                    // check going down
                    string down = downOne(cur,i);  
                    if(!visited.count(down))       
                    {
                        q.push(down);
                        visited.insert(down);
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```



#### [994. Rotting Oranges](https://leetcode-cn.com/problems/rotting-oranges/)

You are given an `m x n` `grid` where each cell can have one of three values:

- `0` representing an empty cell,
- `1` representing a fresh orange, or
- `2` representing a rotten orange.

Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.

Return *the minimum number of minutes that must elapse until no cell has a fresh orange*. If *this is impossible, return* `-1`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)

```c++
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
```



```c++
class Solution {
public:
    int dx[4] = {-1, 0 , 1, 0}, dy[4] = {0, 1, 0, -1};
    int n, m, time;
    int orangesRotting(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        queue<pair<int, int>> q;
        // (1) trav grid, calculate fresh_num and push all rotten oranges in q;
        int fresh_num = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) fresh_num++;
                else if(grid[i][j] == 2) q.push(make_pair(i,j));
            }
        }
        if(fresh_num == 0) return 0; // if no fresh oranges, return 0;
        // (2) BFS
        while(!q.empty()){
            int size = q.size(); 
            for(int k = 0; k < size; k++){
                auto [x,y] = q.front(); q.pop();
                for(int i = 0; i < 4; i++){
                    int a = x + dx[i], b = y + dy[i];
                    if(a >= 0 && a < n && b>=0 && b < m 
                        && grid[a][b] == 1){
        // (3) {a,b} on the board and grid[a][b]==1: fresh;
                        q.push(make_pair(a, b));
                        // (4) change grid, 
                        // or use vecotr<vector<int>> mem 
                        // to record visited blocks;
                        grid[a][b] = 2;
                        // (5) fresh count --;
                        fresh_num --;
                    }
                }
            }
            if(!q.empty()) time ++;// time ++ for every round
        }
        // (6) if fresh_num == 0 in the end, return time: 
        return fresh_num == 0 ? time : -1; 
    }
};
```



#### [1091. Shortest Path in Binary Matrix](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

Given an `n x n` binary matrix `grid`, return *the length of the shortest **clear path** in the matrix*. If there is no clear path, return `-1`.

A **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:

- All the visited cells of the path are `0`.
- All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).

The **length of a clear path** is the number of visited cells of this path.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)

```c++
Input: grid = [[0,1],[1,0]]
Output: 2
```



```c++
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n = grid.size(); // grid is n * n 
        if(grid[0][0] == 1 || grid[n-1][n-1] == 1) return -1;
        if(n == 1 && grid[0][0] == 0) return 1;
        vector<vector<int>> mem(n, vector<int>(n, 0)); mem[0][0] = 1; 
        queue<vector<int>> q; q.push({0,0});
        // from top to top in clockwise
        int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
        int dy[8] = {0,   1, 1, 1, 0,-1,-1, -1};
        int len = 1;
        // pattern of BFS:
        while(!q.empty()){
            int size = q.size();
            for(int i = 1; i <= size; i++){
                auto node = q.front(); q.pop();
                int x = node[0], y = node[1];
                for(int i = 0; i < 8; i++){
                    // check adjacent 8 blocks:
                    int a = x + dx[i], b = y + dy[i];
                    if(a>=0 && a < n && b >=0 && b < n 
                        && mem[a][b] == 0 && grid[a][b] == 0){
                        // blocks can be reached only 
                        // when fulfill all above conditions
                        mem[a][b] = 1; // update mem
                        q.push({a, b}); // update queue
                    }
                }
                // cur loop reach the end, return len + 1;
                if(mem[n-1][n-1] == 1) return len+1;
            }
            len++;
        }
        // no solution after BFS, return -1;
        return -1;
    }
};
```



#### [1129. Shortest Path with Alternating Colors](https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/)

Consider a directed graph, with nodes labelled `0, 1, ..., n-1`. In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.

Each `[i, j]` in `red_edges` denotes a red directed edge from node `i` to node `j`. Similarly, each `[i, j]` in `blue_edges` denotes a blue directed edge from node `i` to node `j`.

Return an array `answer` of length `n`, where each `answer[X]` is the length of the shortest path from node `0` to node `X` such that the edge colors alternate along the path (or `-1` if such a path doesn't exist). 

**Example 1:**

```c++
Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
Output: [0,1,-1]
```

**Example 2:**

```c++
Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
Output: [0,1,-1]
```

**Constraints:**

- `1 <= n <= 100`
- `red_edges.length <= 400`
- `blue_edges.length <= 400`
- `red_edges[i].length == blue_edges[i].length == 2`
- `0 <= red_edges[i][j], blue_edges[i][j] < n`

```c++
class Solution {
public:
  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& red_edges, vector<vector<int>>& blue_edges) {
    vector<unordered_set<int>> edges_r(n); // edge_red
    vector<unordered_set<int>> edges_b(n); // edge_blue
    for (const auto& e : red_edges)
      edges_r[e[0]].insert(e[1]);
    for (const auto& e : blue_edges)
      edges_b[e[0]].insert(e[1]);
    unordered_set<int> seen_r;
    unordered_set<int> seen_b;
    vector<int> ans(n, -1);
    queue<pair<int, int>> q; // (node, last_color)
    // pair first is 0: start from index 0: 
    // pair second is 0/1, last node is red or blue, 0 for red, 1 for blue
    q.push({0, 0}); // red 
    q.push({0, 1}); // blue
    seen_r.insert(0);
    seen_b.insert(0);
    // BFS for shortest path:
    int steps = 0;
    while (!q.empty()) {
      int size = q.size();
      while (size--) {
        int p = q.front().first;
        // if second = 0, last is red, cur is blue, so is_cur_red=0;
        int is_cur_red = q.front().second;      
        q.pop();      
        // bc ans[p] init to -1, so check if >= 0 then use min to get smaller one:  
        ans[p] = (ans[p] >= 0) ? min(ans[p], steps) : steps;     
        const auto& edges = is_cur_red ? edges_r : edges_b;
        auto& seen = is_cur_red ? seen_r : seen_b;
        for (int nxt : edges[p]) {
          if (seen.find(nxt) != seen.end()) continue; // BFS, only for shortest path
          seen.insert(nxt);
          // use 1-is_cur_red to get opposite value:
          q.push({nxt, 1 - is_cur_red});
        }
      }
      ++steps;
    }
    return ans;
  }
};
```



#### [1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

You are given an `m x n` integer matrix `grid` where each cell is either `0` (empty) or `1` (obstacle). You can move up, down, left, or right from and to an empty cell in **one step**.

Return *the minimum number of **steps** to walk from the upper left corner* `(0, 0)` *to the lower right corner* `(m - 1, n - 1)` *given that you can eliminate **at most*** `k` *obstacles*. If it is not possible to find such walk return `-1`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg)

```c++
Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
Output: 6
Explanation: 
The shortest path without eliminating any obstacle is 10.
The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg)

```c++
Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
Output: -1
Explanation: We need to eliminate at least two obstacles to find such a walk. 
```

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 40`
- `1 <= k <= m * n`
- `grid[i][j]` is either `0` **or** `1`.
- `grid[0][0] == grid[m - 1][n - 1] == 0`

```c++
class Solution {
public:
    // (Trim 1: !!!) if k > m-1 + n-1 - 1 = m+n-3, the shortest path should be m+n-2;
    // (Trim 2: !!!) if k = 0, the shortest path should be m+n-2;
    int m, n;
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    int shortestPath(vector<vector<int>>& grid, int k) {
        m = grid.size();
        n = grid[0].size();
        if(k == 0 || k > m+n-3) return m+n-2;
        return bfs(grid, k);
    }
    
    int bfs(vector<vector<int>>& grid, int k) {
        // !!! must have visited to avoid dup nodes in BFS: 3D here: x, y, rest:
        bool visited[m][n][k + 1];
        memset(visited, false, sizeof(visited));
        queue<tuple<int, int, int>> Q; // <x, y, rest>;
        Q.emplace(0, 0, k);
        int steps = 0;
        while(!Q.empty()) {
            steps++;
            int size = Q.size();
            while(size --) {
                auto node = Q.front(); Q.pop();
                int x = get<0>(node);
                int y = get<1>(node);
                int rest = get<2>(node);
                for(int i = 0; i < 4; i++) {
                    int a = x + dx[i];
                    int b = y + dy[i];
                    if (a >= 0 && a < m && b >= 0 && b < n) {
                        if (grid[a][b] == 0 && !visited[a][b][rest]) {
                            if (a == m - 1 && b == n - 1) {
                                return steps;
                            }
                            Q.emplace(a, b, rest);
                            visited[a][b][rest] = true;
                        }
                        else if (grid[a][b] == 1 && rest > 0 && !visited[a][b][rest - 1]) {
                            Q.emplace(a, b, rest - 1);
                            visited[a][b][rest - 1] = true;
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```



#### [1765. Map of Highest Peak](https://leetcode-cn.com/problems/map-of-highest-peak/)

You are given an integer matrix `isWater` of size `m x n` that represents a map of **land** and **water** cells.

- If `isWater[i][j] == 0`, cell `(i, j)` is a **land** cell.
- If `isWater[i][j] == 1`, cell `(i, j)` is a **water** cell.

You must assign each cell a height in a way that follows these rules:

- The height of each cell must be non-negative.
- If the cell is a **water** cell, its height must be `0`.
- Any two adjacent cells must have an absolute height difference of **at most** `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).

Find an assignment of heights such that the maximum height in the matrix is **maximized**.

Return *an integer matrix* `height` *of size* `m x n` *where* `height[i][j]` *is cell* `(i, j)`*'s height. If there are multiple solutions, return **any** of them*.

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png)**

```c++
Input: isWater = [[0,1],[0,0]]
Output: [[1,0],[2,1]]
Explanation: The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
```



```c++
class Solution {
public:
    // BFS: start from all water nodes:
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {
        if(isWater.empty() || isWater[0].empty()) return {{}};
        int n = isWater.size(), m = isWater[0].size();
        vector<vector<int>> ans(n, vector<int>(m, -1));
        queue<pair<int, int>> q;
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                if(isWater[i][j] == 1){
                    ans[i][j] = 0; 
                    q.push({i, j});
                }

        while(!q.empty()){
            auto [x, y] = q.front(); q.pop();
            for(int i = 0; i < 4; i++){
                int a = x + dx[i];
                int b = y + dy[i];
                if(a >= 0 && a < n && b >= 0 && b < m 
                    && ans[a][b] == -1){
                    ans[a][b] = ans[x][y] + 1;
                    q.push({a, b});
                } 
            }
        }
        return ans;
    }
};
```













































