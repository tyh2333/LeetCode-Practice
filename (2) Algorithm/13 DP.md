# 1. Linear DP

## (1) single string:

### (i) basic:

#### [32. Longest Valid Parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses/)

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```c++
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".
```

**Example 2:**

```c++
Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".
```

**Example 3:**

```c++
Input: s = ""
Output: 0
```

 **Constraints:**

- `0 <= s.length <= 3 * 104`
- `s[i]` is `'('`, or `')'`. 

```c++
(1) dp[i]: longest string ends at index i;
(2) ans = max(dp[0 ~ n-1]);
(3) transition function:
if s[i] == '(' :    dp[i] = 0
if s[i] == ')' :
    if s[i - 1] == '(' && i - 2 >= 0:
        dp[i] = dp[i - 2] + 2;
    if s[i - 1] == ')' && s[i - dp[i - 1] - 1] == '(' && i - dp[i - 1] - 2 >= 0:
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;

pre = i - dp[i-1] - 1;
 ( ...  )     (     (  ...   )    )   
      pre-1  pre    |       i-1   i
                    |
            match with i-1 bracket
            dp[i-1]== i-1 to this bracket;
```

```c++

class Solution {
public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);
        int ans = 0;
        for(int i = 1; i < size; i++) {
            // s[i] = '(', dp[i] = 0 (init = 0);
            if (s[i] == '(') continue;
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    // need to make sure i-2>=0, when use dp[i-2]
                    if (i - 2 >= 0) dp[i] = dp[i - 2] + 2;
                    else dp[i] = 2;
                } 
                else if (s[i - 1] == ')' && dp[i - 1] > 0) {
                    // find s[i]'s match : pre must valid index
                    // dp[i-1]: len from i-1 to its match:
                    // e.g. ()), for the last ')', pre is -1;
                    int pre = i - 1 - dp[i - 1];
                    if (pre >= 0 && s[pre] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        // e.g. "()(())"
                        // consider first two and last four:
                        // the final len should be 2+4=6;
                        // so after finding pre, add dp[pre-1]:
                        if ((pre - 1) >= 0) {
                            dp[i] += dp[pre-1];
                        }
                    }
                }
            }
            ans = max(ans, dp[i]); 
        }
        return ans;
    }
};
```



#### [42. Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/)

Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

```c++
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
```

**Constraints:**

- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> left(n, 0), right(n, 0);
        // get biggest on the left
        for(int i = 1; i < n; i++){
            left[i] = max(left[i-1], height[i-1]);
        }
        // get biggest on the right
        for(int i = n-2; i >=0 ; i--){
            right[i] = max(right[i+1],height[i+1]);
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
            ans += max(0, min(left[i],right[i])-height[i]);
        return ans;
    }
};
```



#### [62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/)

A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```c++
Input: m = 3, n = 7
Output: 28
```

**Constraints:**

- `1 <= m, n <= 100`
- It's guaranteed that the answer will be less than or equal to `2 * 10^9`.

```c++
class Solution {
public:
    // dp[y][x] = dp[y-1][x] + dp[y][x-1];
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1) return 1;
        // add 1 row and 1 column to solve 
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for(int y = 1; y <= m; y++){
            for(int x = 1; x <= n; x++){
                // bc dp[1][1] is start point:
                if(x == 1 && y == 1) dp[y][x] = 1; 
                else dp[y][x] = dp[y-1][x] + dp[y][x-1];
            }        
        }
        return dp[m][n];
    }
};
```



#### [63. Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/)

A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and space is marked as `1` and `0` respectively in the grid.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```c++
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

**Constraints:**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` is `0` or `1`.

```c++
// dp[i][j]: ways to reach (i, j); 
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& g) {
        int row = g.size(); // row
        int col = g[0].size(); // col
        vector<vector<int>> dp(row+1, vector<int>(col+1, 0));
        for(int y = 1; y <= row; y++){
            for(int x = 1; x <= col; x++){
                if(y == 1 && x == 1) {
                    // if the start point is a obstacle, return 0;
                    if(g[0][0] == 1) return 0;
                    else dp[y][x] = 1;
                }
                else if(g[y-1][x-1] != 1){ 
                    // this is not a obstacle
                    dp[y][x] = dp[y-1][x] + dp[y][x-1];
                }
                else{
                    // do nothing
                    // bc already initilized obstacles to 0; 
                }
            }
        }
        return dp[row][col];
    }
};
```

#### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

**Example 1:**

```c++
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

 **Constraints:**

- `1 <= n <= 45`

```c++
// dp[i]: ways to reach step i;
// dp[n]: ways to reach step n;
// init dp[0] and dp[1] to 1;

class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n;i++)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
};
```

```c++
// optimization for space complexity:
class Solution {
public:
    int climbStairs(int n) {
        int two = 1;
        int one = 1;
        int curr = 1;
        for(int i = 2; i <= n; i++){
           curr = two + one;
           two = one;
           one = curr;
        }
        return curr;
    }
};
```



#### [91. Decode Ways](https://leetcode-cn.com/problems/decode-ways/)

A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

To **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `"11106"` can be mapped into:

- `"AAJF"` with the grouping `(1 1 10 6)`
- `"KJF"` with the grouping `(11 10 6)`

Note that the grouping `(1 11 06)` is invalid because `"06"` cannot be mapped into `'F'` since `"6"` is different from `"06"`.

Given a string `s` containing only digits, return *the **number** of ways to **decode** it*.

The answer is guaranteed to fit in a **32-bit** integer. 

**Example 1:**

```c++
Input: s = "12"
Output: 2
Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
```

**Example 2:**

```c++
Input: s = "226"
Output: 3
Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6). 
```

**Constraints:**

- `1 <= s.length <= 100`
- `s` contains only digits and may contain leading zero(s).

```c++
// dp[i]: ways to decode for first i;
// transition function:
// (1) if cur char can decode independently,
// only 0 can not, bc 'A'->'1':
//     dp[i] += dp[i-1];
// (2) if cur char can decode with other:
// need: i>=2 && (s[i-2]-'0')*10+s[i-1]-'0' in [10, 26]
// dp[i] += dp[i-2];
class Solution {
public:
    int numDecodings(string s) {
        int cnt = 0;
        int n = s.size();
        vector<int> f(n + 1, 0);
        f[0] = 1;
        for(int i = 1; i <= n; i++){
            if(s[i-1] != '0') f[i] += f[i-1];
            if(i-2 >= 0){
                int t = (s[i-2] -'0') * 10 + s[i-1]-'0';
                if(t>=10 && t <= 26) f[i] += f[i-2];
            }
        }
        return f[n];
    } 
};
```



### (ii) longest increasing subsequence

#### [300. Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

Given an integer array `nums`, return the length of the longest strictly increasing subsequence. A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.

 **Example 1:**

```c++
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```

**Constraints:**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 **Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?

```c++
p.s something we need to notice if we choose to use greedy algorithm：
	e.g. 0，1，0，3，2，3
	when we operate the first 0, the next bigger num of 1 is the first 3, but what we want is 2, so greedy is not a good choice here
```

```c++
// dp[i]: the length of LIS ending at nums[i]
// return max(dp[i])
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(),1);
        int res = 0;
        for(int i = 0; i < nums.size(); ++i){
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = max(dp[i], dp[j]+ 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int len = 1; // len start from 1
        int n = (int)nums.size();
        if (n == 0) return 0;
        vector<int> d(n + 1, 0);
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) 
        {
            // if nums[i] bigger than the last value in d, append directly:
            if (nums[i] > d[len]) {
                d[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0; 
                // binary search to find a pos to exchange the one
                // just bigger than it d[pos]
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
};
```



#### [354. Russian Doll Envelopes](https://leetcode-cn.com/problems/russian-doll-envelopes/)

You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return *the maximum number of envelopes you can Russian doll (i.e., put one inside the other)*.

**Note:** You cannot rotate an envelope. 

**Example 1:**

```c++
Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). 
```

**Constraints:**

- `1 <= envelopes.length <= 5000`
- `envelopes[i].length == 2`
- `1 <= wi, hi <= 104`

```c++
// transform to longest increasing subsequence:
// dp[i]: LIS ends at index i;
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        if(envelopes.empty()) return 0;
        int n = envelopes.size();
        int ans = 0;
        sort(envelopes.begin(), envelopes.end());
        vector<int> dp(n, 1); 
        // envelopes[i][0]: width
        // envelopes[i][1]: height
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                if(envelopes[j][0] < envelopes[i][0]
                && envelopes[j][1] < envelopes[i][1]){
                    dp[i] = max(dp[i], dp[j]+1);
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```



#### [673. Number of Longest Increasing Subsequence](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

Given an integer array `nums`, return *the number of longest increasing subsequences.*

**Notice** that the sequence has to be **strictly** increasing.

**Example 1:**

```
Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
```

**Example 2:**

```
Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
```

**Constraints:**

- `1 <= nums.length <= 2000`
- `-106 <= nums[i] <= 106`

```c++
// (1) method 1:
//  	this is similar to the question 300, at first I thought just find how many num that equal to ans in the vector dp, but it is wrong
//  	e.g. nums = [1,3,5,4,7] 
//  		dp[0] = 4 only shows once in dp, but it could be [1, 3, 4, 7] or [1, 3, 5, 7]
class Solution {
public:
    // similar to question 300: 
    //    Just need to find the number that equal to ans of question 300
    // and use extra vector to update the longest 
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int ans = 0;
        vector<int> dp(n, 1); //   dp[i]: lengeh of LIS ends with nums[i]
        vector<int> count(n,1); // count[i]: number of LIS ends with nums[i]
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j++){
                if(nums[i] <= nums[j]) continue;

                if(dp[j] + 1 > dp[i]){
                    // update the LIS length and count
                    dp[i] = dp[j] + 1;
                    count[i] = count[j]; 
                }
                else if(dp[j] + 1 == dp[i]){
                    // same length LIS, so add count[j] to count[i]; 
                    count[i] += count[j];
                }
            }
        }
        int max_len = *max_element(dp.begin(), dp.end()); // get the max_len
        for(int i = 0; i < n; i++) // add together to get ans
            if(dp[i] == max_len)
                ans += count[i];
        return ans;
    }
};
```



#### [674. Longest Continuous Increasing Subsequence](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

Given an unsorted array of integers `nums`, return *the length of the longest **continuous increasing subsequence** (i.e. subarray)*. The subsequence must be **strictly** increasing.

A **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.

**Example 1:**

```
Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
4.
```

**Example 2:**

```
Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly
increasing.
```

 **Constraints:**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

```c++
// dp or two pointers:
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return 0;
        vector<int> dp(n+1,1);
        int ans = 1;
        for(int i = 1; i < n; i++){
            if(nums[i-1] < nums[i]) dp[i] = dp[i-1] + 1;
            else dp[i] = 1;
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

```c++
// optimization: Only use O (1) space:
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.empty()) return 0;
        int n = nums.size();
        int ans = 1; // shortest length is 1
        int cur = 1;
        for(int i = 1; i < n; i++){
            if(nums[i-1] < nums[i])
                cur++;
            else
                cur = 1;
            ans = max(ans, cur);
        }
        return ans;
    }
};
```



#### [978. Longest Turbulent Subarray](https://leetcode-cn.com/problems/longest-turbulent-subarray/)

Given an integer array `arr`, return *the length of a maximum size turbulent subarray of* `arr`.

A subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.

More formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:

- For i <= k < j :
  - `arr[k] > arr[k + 1]` when `k` is odd, and
  - `arr[k] < arr[k + 1]` when `k` is even.
- Or, for i <= k < j:
  - `arr[k] > arr[k + 1]` when `k` is even, and
  - `arr[k] < arr[k + 1]` when `k` is odd.

**Example 1:**

```c++
Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
```

**Constraints:**

- `1 <= arr.length <= 4 * 104`
- `0 <= arr[i] <= 109`

```c++
(1) f[i]: longest ends at arr[i];
(2) transition:
(i) if(((arr[i-2] < arr[i-1]) && (arr[i-1] > arr[i])) 
    || ((arr[i-2] > arr[i-1]) && (arr[i-1] < arr[i])))  
        f[i] = f[i-1] + 1;
(ii)  else if(arr[i] != arr[i-1]) f[i] = 2; // check if can build len==2
(iii) else if(arr[i] == arr[i-1]) f[i] = 0; // check if can build len==0
(3) return max(dp[i]);
```

```c++
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        int n = arr.size();
        if(n==1) return 1;
        vector<int> f(n, 0);
        f[0] = 0; f[1] = (arr[1] != arr[0])+1;
        int ans = f[1];
        for(int i = 2; i < n; i++){
            if(((arr[i-2] < arr[i-1]) && (arr[i-1] > arr[i])) 
            || ((arr[i-2] > arr[i-1]) && (arr[i-1] < arr[i]))) 
                f[i] = f[i-1] + 1;
            else if(arr[i] != arr[i-1]) f[i] = 2;
            else if(arr[i] == arr[i-1]) f[i] = 0;
            ans = max(ans, f[i]);
        }
        return ans;
    }
};
```

```c++
// optimization: O(1) space:
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        int n = arr.size();
        if(n==1) return 1;
        int first = 0, second = (arr[1] != arr[0])+1;
        int ans = second;
        int cur = 0;
        for(int i = 2; i < n; i++){
            if(((arr[i-2] < arr[i-1]) && (arr[i-1] > arr[i])) 
            || ((arr[i-2] > arr[i-1]) && (arr[i-1] < arr[i])))
                cur = second + 1;
            else if(arr[i] != arr[i-1]) cur = 2;
            else if(arr[i] == arr[i-1]) cur = 0;
            ans = max(ans, cur);
            second = cur;
            first = second;
        }
        return ans;
    }
};
```

#### [1048. Longest String Chain](https://leetcode-cn.com/problems/longest-string-chain/)

You are given an array of `words` where each word consists of lowercase English letters.

`wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly one** letter anywhere in `wordA` **without changing the order of the other characters** to make it equal to `wordB`.

- For example, `"abc"` is a **predecessor** of `"abac"`, while `"cba"` is not a **predecessor** of `"bcad"`.

A **word chain** is a sequence of words `[word1, word2, ..., wordk]` with `k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a **predecessor** of `word3`, and so on. A single word is trivially a **word chain** with `k == 1`.

Return *the **length** of the **longest possible word chain** with words chosen from the given list of* `words`.

 **Example 1:**

```
Input: words = ["a","b","ba","bca","bda","bdca"]
Output: 4
Explanation: One of the longest word chains is ["a","ba","bda","bdca"].
```

**Constraints:**

- `1 <= words.length <= 1000`
- `1 <= words[i].length <= 16`
- `words[i]` only consists of lowercase English letters.

```c++
class Solution {
public:
    // check if str1 is predecessor of str2:
    bool check(string& str1,string& str2){
        if(str2.size()-str1.size()!=1) return false;
        int pos = 0;
        for(int i=0; i<str2.size(); i++)
            if(str2[i]==str1[pos])
                pos++;
        return pos==str1.size();
    }
    // similar to LIS: only difference: treat str1 is predecessor of str2 as str1 < str2 in LIS
    int longestStrChain(vector<string>& words) {
        int n = words.size();
        // sort by length:
        sort(words.begin(),words.end(),[&](const auto& str1,const auto& str2){
            return str1.size() < str2.size();
        });
        vector<int>dp(n, 1);
        for(int i=1; i<n; i++)
            for(int j=0; j<i; j++)
                if(check(words[j],words[i]))
                    dp[i]=max(dp[i], dp[j]+1);
      // else do nothing, bc init to 1;  
      	return *max_element(dp.begin(),dp.end());
    }
};
```



### (iii) max sum for subarray

#### [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*. A **subarray** is a **contiguous** part of an array.

**Example 1:**

```c++
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104` 

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

```c++
// dp[i]: max sum ends at nums[i]; TC:O(n)
```

```c++
class Solution {
public:
    // f[i]: longest subarray ends by nums[i];
    // f[i] = max(f[i-1], 0) + nums[i];
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        vector<int> f(n, 0);
        f[0]= nums[0];
        int ans = f[0];
        for(int i = 1; i < n; i++){
            f[i] = max(f[i-1], 0) + nums[i];
            ans = max(ans, f[i]);
        }
        return ans;
    }
};
```

```c++
// O(1) space optimization:
class Solution {
public:
    
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int res = nums[0];
        int last = nums[0];
        for(int i = 1; i < n; ++i){
            int now = max(last, 0) + nums[i];
            res = max(res, now);
            last = now;
        }
        return res;
    }
};
```



#### [152. Maximum Product Subarray](https://leetcode-cn.com/problems/maximum-product-subarray/)

Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return *the product*.

It is **guaranteed** that the answer will fit in a **32-bit** integer.

A **subarray** is a contiguous subsequence of the array.

**Example 1:**

```
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

```c++
// dp[i]: max product ends at nums[i];
// bc product can be positive and negative
// so save both smallest and biggest:
```

```c++
class Solution {
public:
   
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int min_val = 1, max_val = 1;
        int ans = INT_MIN;
        for(int i = 0; i < n; i++){
            int aa = min_val * nums[i];  
            int bb = max_val * nums[i]; 
            min_val = min(nums[i], min(aa, bb));
            max_val = max(nums[i], max(aa, bb));
            ans = max(ans, max_val);
        }
        return ans;
    }
};
```



#### [363. Max Sum of Rectangle No Larger Than K](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

Given an `m x n` matrix `matrix` and an integer `k`, return *the max sum of a rectangle in the matrix such that its sum is no larger than* `k`.

It is **guaranteed** that there will be a rectangle with a sum no larger than `k`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg)

```c++
Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2
Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).
```

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-100 <= matrix[i][j] <= 100`
- `-105 <= k <= 105`

**Follow up:** What if the number of rows is much larger than the number of columns?

```c++
class Solution
{
    vector<vector<int>> sums;
public:
    int maxSumSubmatrix(vector<vector<int>> &matrix, int k)
    {
        /*~~ 304. 2D prefixed sum ~~*/
        int m = matrix.size(), n = matrix[0].size();
        sums = vector<vector<int>>(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sums[i][j] = sums[i][j - 1] 
                           + sums[i - 1][j] 
                           - sums[i - 1][j - 1] 
                           + matrix[i - 1][j - 1];
            }
        }
        auto sumRange = [&](int row1, int col1, int row2, int col2) {
            return sums[row2][col2] - sums[row2][col1] - sums[row1][col2] + sums[row1][col1];
        };
        int ans = INT_MIN;
        /*~~560 subarray that sum==k ~~*/
        for (int col1 = 0; col1 < n; col1++) {
            // there is one test case that  row >> col;
            for (int col2 = col1+1; col2 <= n; col2++) {
                set<int> st;
                st.insert(0);
                for (int row = 1; row <= m; row++) {
                    int sum = sumRange(0, col1, row, col2);
                    auto it = st.lower_bound(sum-k);
                    if (it != st.end()) ans = max(ans, sum-*it);
                    st.insert(sum);
                }
            }
        }
        return ans;
    }
};
```



#### [918. Maximum Sum Circular Subarray](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

Given a **circular integer array** `nums` of length `n`, return *the maximum possible sum of a non-empty **subarray** of* `nums`.

A **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.

A **subarray** may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.

**Example 1:**

```
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3
```

**Constraints:**

- `n == nums.length`
- `1 <= n <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`

```c++
// (1) first assume it's not circular, get max
// (2) then assume it's circular, then A[0], A[n-1] will be chosen, so find min in the middle and use sum-min to get max.
// (3) choose the bigger max;
```

```c++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& A) {
        int n = A.size();
        // dp[i]: max sum ends at nums[i]:
        vector<int> dp(n, A[0]); 
        int sum = A[0];  
        int maxVal1 = A[0];
        for (int i = 1; i < A.size(); i++){
            sum += A[i];
            dp[i] = max(dp[i - 1] + A[i], A[i]);
            maxVal1 = max(maxVal1, dp[i]);
        }
        int minVal2 = 0;
        for (int i = 1; i < A.size()-1; i++){
            dp[i] = min(dp[i - 1] + A[i], A[i]);
            minVal2 = min(minVal2, dp[i]);
        }
        return max(maxVal1, sum-minVal2);
    }
};
```

#### [1800. Maximum Ascending Subarray Sum](https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/)

Given an array of positive integers `nums`, return the *maximum possible sum of an **ascending** subarray in* `nums`. A subarray is defined as a contiguous sequence of numbers in an array.

A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**. 

**Example 1:**

```c++
Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65. 
```

**Constraints:**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

```c++
class Solution {
public:
//     f[i] : maxnum ends at nums[i]
    int maxAscendingSum(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 0);
        dp[0] = nums[0];
        int ans = nums[0];
        for(int i = 1; i < n; i++){
            if(nums[i] > nums[i-1]){
                dp[i] = dp[i-1] + nums[i];
            }
            else dp[i] = nums[i];
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

#### [面试题 17.24. Max Submatrix LCCI](https://leetcode-cn.com/problems/max-submatrix-lcci/)

Given an NxM matrix of positive and negative integers, write code to find the submatrix with the largest possible sum.

Return an array `[r1, c1, r2, c2]`, where `r1`, `c1` are the row number and the column number of the submatrix's upper left corner respectively, and `r2`, `c2` are the row number of and the column number of lower right corner. If there are more than one answers, return any one of them.

**Note:** This problem is slightly different from the original one in the book.

**Example:**

```
Input:
[
   [-1,0],
   [0,-1]
]
Output: [0,1,0,1]
```

**Note:**

- `1 <= matrix.length, matrix[0].length <= 200`

```c++
class Solution {
public:
    // (1) enum i,j to use two pointers to traversal all possible height for the matrix: 
    // (2) 918.column prefixSum(treat column sum as one value)+ 53. Maximum Subarray:
    vector<int> getMaxMatrix(vector<vector<int>>& matrix) {
        int n = matrix.size(), m = matrix[0].size();
        if (n == 0) return {0,0,0,0} ;
        int r1 = 0, r2 = 0, c1 = 0, c2 = 0;
        int max_sum = matrix[0][0];
        // prefix_sum_col[i][j] : sum of column from matrix[0][j] to matrix[i][j]:
        vector<vector<int>> prefix_sum_col(n, vector<int>(m, 0));
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
            {
                if(i == 0) prefix_sum_col[i][j] = matrix[i][j];
                else prefix_sum_col[i][j] = prefix_sum_col[i-1][j] + matrix[i][j];
            }
        r1 = 0; r2 = 0; c1 = 0; c2 = 0;
        //======== 53 Maximum Subarray: =========//
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j <= i; j++)
            {    
                vector<int> dp(m, 0); // dp[i]: max sum ends at column i
                dp[0] = prefix_sum_col[i][0] - prefix_sum_col[j][0] + matrix[j][0];
                int cur_c1 = 0, cur_c2 = 0;
                for(int k = 1; k < m; k++){
                    int cur_sum = prefix_sum_col[i][k] - prefix_sum_col[j][k] + matrix[j][k];
                    if(dp[k-1] < 0){   
                        dp[k] = cur_sum;  
                        cur_c1 = k; 
                        cur_c2 = k;
                    }
                    else{
                        dp[k] = dp[k-1] + cur_sum;    
                        cur_c2 = k;
                    }
                    if(dp[k] > max_sum) /// only update r and c when bigger than max_sum:
                    {
                        r1 = j; // rows update to current upper and lower bound
                        r2 = i; 
                        c1 = cur_c1; 
                        c2 = cur_c2;
                        max_sum = dp[k]; // update max_sum
                    }
                }
            }
        }
        return {r1,c1, r2,c2};
    }
};
```



### (iv) house robbery

#### [198. House Robber](https://leetcode-cn.com/problems/house-robber/)

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```c++
// dp[i]: max profit for first i houses:
// dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
// dp[0] = nums[0]; // only have one house
// dp[1] = max(nums[0], nums[1]); // choose 1
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        vector<int> dp(n, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < n; i++){
            dp[i] = max(dp[i-2] + nums[i], dp[i-1]);
        }
        return dp[n-1];
    }
};
```

```c++
// O(1) space optimization:
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int minus2 = nums[0];
        int minus1 = max(nums[0], nums[1]);
        int cur = 0;
        for(int i = 2; i < n; i++){
            cur = max(minus2 + nums[i], minus1);
            minus2 = minus1;
            minus1 = cur;
        }
        return minus1;
    }
};
```



#### [213. House Robber II](https://leetcode-cn.com/problems/house-robber-ii/)

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

**Example 1:**

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

```c++
// circular: can't choose first and last together:
// so check from 0 to n-1
// then check from 1 to n, the rest is sames as 198. House Robber I
```

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int ans = 0;
        vector<int> dp(n+1, 0);
        dp[0] = 0;
        dp[1] = nums[0]; // can choose to rob first
        // rob from 0 to n-1
        for(int i = 2; i < n; i++){
            dp[i] = max( dp[i-2]+nums[i-1], dp[i-1]);
        }
        ans = dp[n-1]; // nums can steal from 0 to n-1
        dp.clear();
        
        dp[0] = 0; 
        dp[1] = 0; // can't choose to rob first
        dp[2] = nums[1]; // start from 2nd house, so i init to 3
        for(int i = 3; i <= n; i++){
            dp[i] = max(dp[i-2]+ nums[i-1], dp[i-1]);
        }
        return max(ans, dp[n]); // choose biggest profit
    }
};
```

```c++
// can also optimize to O(1) space same as in 198. House robber I, bc dp[i] only depends on dp[i-2] and dp[i-1];
```



#### [337. House Robber III](https://leetcode-cn.com/problems/house-robber-iii/)

The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.

Besides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.

Given the `root` of the binary tree, return *the maximum amount of money the thief can rob **without alerting the police***.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
```

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `0 <= Node.val <= 104`

```c++
(1) method 1:  
   use pair<steal, not steal> to save result;
   e.g. [2,1,3,null,4]
        2
       / \
      1   3
       \
        4
can rob both 3 and 4 at the same time:
So not just sum every other layer.
```

```c++
class Solution {
public:
    // every node only have two status: steal or not
    // first  : sum when not steal
    // second : sum when steal
    // return the max sum for stealing or not stealing:
    int rob(TreeNode* root) {
        pair<int, int> res = dfs(root);
        return max(res.first, res.second);
    }
    // dfs return max profit for steal or not steal root:
    // first: not steal, second: steal;
    pair<int, int> dfs(TreeNode* root){
        if(root == nullptr) return {0, 0};
        pair<int, int> l = dfs(root->left);
        pair<int, int> r = dfs(root->right);
        return make_pair(
            /// first: not steal root, decide subtree seperately:
            max(l.first, l.second) + max(r.first, r.second),
            // second: choose to steal root + not steal children
            root->val + l.first + r.first
        );
    }
};
```



```c++
// (2) method 2: Memorization recursion
    Use map to store the max the thief can get from cur node;
    sum[root] = val; 
    if(sum.find(root) != sum.end()) 
        return sum[root];
```

```c++

class Solution {
public:
    unordered_map<TreeNode*, int> sum;
    int rob(TreeNode* root) {
        // got nothing on nullptr node
        if (root == nullptr) return 0;
        if(sum.find(root) != sum.end()) return sum[root];
        // val1 : amount of cur node
        int val1 = root->val;
        // first plan: 
        // (1) cur root has left child: get his left->left and left->right
        if (root->left != nullptr) 
            val1 += rob(root->left->left) + rob(root->left->right);
        // (2) cur root has right child: get his right->left and right->right
        if (root->right != nullptr) 
            val1 += rob(root->right->left) + rob(root->right->right);
        // second plan: we don't want cur node
        //  then we can have cur node->left and node->right
        int val2 = rob(root->left) + rob(root->right);
        // At last cmp first plan and second plan, we choose a better one;
        sum[root] = max(val1, val2);
        return sum[root];
    }
};
```



#### [740. Delete and Earn](https://leetcode-cn.com/problems/delete-and-earn/)

You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:

- Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.

Return *the **maximum number of points** you can earn by applying the above operation some number of times*. 

**Example 1:**

```c++
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
```

**Example 2:**

```c++
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
```

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `1 <= nums[i] <= 104`

```c++
// e.g. [2,2,3,3,3,4]
// delete 3 will not have influence on other 3
// so can delete all 3 in one operation:
// and rob nums[i], need to delete nums[i]-1 and nums[i]+1:
// so transform to house robbery problems:
```

```c++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
    // can't use max_element for empty vector
        if(nums.size()==0) return 0; 
        int max_num = *max_element(nums.begin(), nums.end());
    // vector sum only need to have max_num+1 length:
        vector<int> sum(max_num+1, 0); 
        for (int i = 0; i < nums.size(); i ++) {
            sum[nums[i]] += nums[i];
        }
      // following part can be optimized to O(1) space, same as Leetcode 198.
        vector<int> dp(max_num+1, 0);
        dp[0] = 0;
        dp[1] = sum[1]; 
        for (int i = 2; i < sum.size(); i ++) {
            dp[i] = max(dp[i-1], dp[i-2] + sum[i]);
        }
        return dp[max_num];
    }
};
```



#### [1235. Maximum Profit in Job Scheduling](https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/)

We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png)**

```
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png)**

```
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.
```

**Example 3:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png)**

```
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6
```

**Constraints:**

- `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`
- `1 <= startTime[i] < endTime[i] <= 109`
- `1 <= profit[i] <= 104`

```c++
// (1) method 1:
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size();
        vector<int> job(n+1);
        for(int i = 0; i <= n; i++){
            job[i] = i;
        }
        // sort job id by 
        sort(job.begin()+1, job.end(), [&](int& a, int& b) {
            return endTime[a-1]< endTime[b-1]; 
        });
        vector<int> prev(n + 1);
        for (int i = 1; i <= n; i++){
            for (int j = i - 1; j >= 1; j--){
                if (endTime[job[j]-1] <= startTime[job[i]-1])
                {
                    prev[i] = j;
                    break;
                }
            }
        }
        vector<int>dp(n + 1);
        dp[1] = profit[job[1]-1];
        for (int i = 1; i <= n; i++)
            dp[i] = max(dp[i - 1], profit[job[i]-1] + dp[prev[i]]);
        return dp[n];
    }
};
```

```c++
// optimization: use binary search to accelerate find pre: O(nlogn):
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size();
        vector<int> index(n);
        iota(index.begin(), index.end(), 0);
        sort(index.begin(), index.end(), [&](int i, int j) {
            return endTime[i] < endTime[j];
        });
        vector<int> dp(n+1);
        int left, right, mid;
        for (int i = 0; i < n; ++i) {
            left = 0, right = i;
            while (left < right) {
                mid = left + (right - left) / 2;
                if (endTime[index[mid]] <= startTime[index[i]]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            dp[i+1] = max(dp[i], dp[left] + profit[index[i]]);
        }
        return dp[n];
    }
};
```



#### [1388. Pizza With 3n Slices](https://leetcode-cn.com/problems/pizza-with-3n-slices/)

There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:

- You will pick **any** pizza slice.
- Your friend Alice will pick next slice in anti clockwise direction of your pick. 
- Your friend Bob will pick next slice in clockwise direction of your pick.
- Repeat until there are no more slices of pizzas.

Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/02/18/sample_3_1723.png)

```c++
Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2020/02/18/sample_4_1723.png)**

```c++
Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.
```

**Constraints:**

- `1 <= slices.length <= 500`
- `slices.length % 3 == 0`
- `1 <= slices[i] <= 1000`

```c++
(1) similar to House Robbery II, circular array can not choose the first and last element at the same time.
  so dp twice and choose bigger one: 0 ~ n-1 + 1 ~ n;

(2) dp[i][j]: choose j elements from first i elements;
    dp[i][j] = max(dp[i-2][j-1]+slices[i-1], dp[i-1][j]);

(3) why i-1 in slices[i-1]: i,j are numbers start from 1 but for slices is index, start from 0, so use i-1:
```

```c++
class Solution {
public:
    int calculate(const vector<int>& slices) {
        int n = slices.size();
        int choose = (n+1)/3; // how many slices need to choose
        vector<vector<int>> dp(n+1, vector<int> (choose + 1,0));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= min(choose, i); j++){
                // (1) dp[i-1][j]: not select current;
                // (2) dp[i-2][j-1] + slices[i-1]: select current;
                dp[i][j] = max(dp[i-1][j], 
                               ((i-2>=0)?dp[i-2][j-1]:0) + slices[i-1]);
            }
        }
        return dp[n][choose];  
    }
    int maxSizeSlices(vector<int>& slices) {
        vector<int> v1(slices.begin() + 1, slices.end());
        vector<int> v2(slices.begin(), slices.end() - 1);
        int ans1 = calculate(v1);
        int ans2 = calculate(v2);
        return max(ans1, ans2);
    }
};
```



## (2) double strings:

## (3) matrix:

## (4) K strings:

## (5) other linear:

# 2. interval DP:

## (0) Intro of interval DP:

```c++
区间动态规划:

区间 DP 是状态的定义和转移都与区间有关，其中区间用两个端点表示。
状态定义 dp[i][j] = [i...j] 上原问题的解。i 变大，j 变小都可以得到更小规模的子问题。
对于单串上的问题，我们可以对比一下线性动态规划和区间动态规划。线性动态规划, 一般是定义 dp[i]， 
表示考虑到前 i 个元素，原问题的解，i 变小即得到更小规模的子问题，推导状态时候是从前往后，即 i 从小到大推的。
区间动态规划，一般是定义 dp[i][j]，表示考虑 [i...j] 范围内的元素，原问题的解增加 i，减小 j 
都可以得到更小规模的子问题。推导状态一般是按照区间长度从短到长推的。
区间动态规划的状态设计，状态转移都与线性动态规划有明显区别，但是由于这两种方法都经常用在单串问题上，
拿到一个单串的问题时，往往不能快速地判断到底是用线性动态规划还是区间动态规划，这也是区间动态规划的难点之一。

状态转移，推导状态 dp[i][j] 时，有两种常见情况:

1. dp[i][j] 仅与常数个更小规模子问题有关
一般是与 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 有关。
dp[i][j] = f(dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1])

代码常见写法:
for len = 1...n
    for i = i...len
        j = i + len - 1
        dp[i][j] = max(dp[i][j], f(dp[i+1][j], dp[i][j-1], dp[i+1][j-1]))

时间复杂度和空间复杂度均为 O(n^2), 例如 516 题

2. dp[i][j] 与 O(n) 个更小规模子问题有关
一般是枚举 [i,j] 的分割点，将区间分为 [i,k] 和 [k+1,j]，对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。

dp[i][j] = g(f(dp[i][k], dp[k + 1][j])) 其中 k = i ... j-1。

for len = 1...n
    for i = i...len
        j = i + len - 1
        for k = i...j
            dp[i][j] = max(dp[i][j], f(dp[i][k], dp[k][j]))

时间复杂度可以达到: O(n^3)，空间复杂度还是 O(n^2); 例如 664 题
```



## (1) palindrome:

## (2) n sub-problem:

## (3) word break:



















#### [583. Delete Operation for Two Strings](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

Given two strings `word1` and `word2`, return *the minimum number of **steps** required to make* `word1` *and* `word2` *the same*. In one **step**, you can delete exactly one character in either string. 

**Example 1:**

```c++
Input: word1 = "sea", word2 = "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
```

**Constraints:**

- `1 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of only lowercase English letters.

```c++
// the min steps to make first i word1 and first j word2 same
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        // must init dp[i][0] and dp[0][j]
        for (int i = 0; i <= n; i++) dp[i][0] = i;
        for (int j = 0; j <= m; j++) dp[0][j] = j;

        // bc from i-1 to get 1, j-1 to get j, so i,j all start from 1 to n,m
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[n][m];
    }
};
```



