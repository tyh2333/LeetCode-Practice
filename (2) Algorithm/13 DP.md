# 1. Linear DP

## (1) single string:

### (i) basic:

#### [32. Longest Valid Parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses/)

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```c++
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".
```

**Example 2:**

```c++
Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".
```

**Example 3:**

```c++
Input: s = ""
Output: 0
```

 **Constraints:**

- `0 <= s.length <= 3 * 104`
- `s[i]` is `'('`, or `')'`. 

```c++
(1) dp[i]: longest string ends at index i;
(2) ans = max(dp[0 ~ n-1]);
(3) transition function:
if s[i] == '(' :    dp[i] = 0
if s[i] == ')' :
    if s[i - 1] == '(' && i - 2 >= 0:
        dp[i] = dp[i - 2] + 2;
    if s[i - 1] == ')' && s[i - dp[i - 1] - 1] == '(' && i - dp[i - 1] - 2 >= 0:
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;

pre = i - dp[i-1] - 1;
 ( ...  )     (     (  ...   )    )   
      pre-1  pre    |       i-1   i
                    |
            match with i-1 bracket
            dp[i-1]== i-1 to this bracket;
```

```c++

class Solution {
public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);
        int ans = 0;
        for(int i = 1; i < size; i++) {
            // s[i] = '(', dp[i] = 0 (init = 0);
            if (s[i] == '(') continue;
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    // need to make sure i-2>=0, when use dp[i-2]
                    if (i - 2 >= 0) dp[i] = dp[i - 2] + 2;
                    else dp[i] = 2;
                } 
                else if (s[i - 1] == ')' && dp[i - 1] > 0) {
                    // find s[i]'s match : pre must valid index
                    // dp[i-1]: len from i-1 to its match:
                    // e.g. ()), for the last ')', pre is -1;
                    int pre = i - 1 - dp[i - 1];
                    if (pre >= 0 && s[pre] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        // e.g. "()(())"
                        // consider first two and last four:
                        // the final len should be 2+4=6;
                        // so after finding pre, add dp[pre-1]:
                        if ((pre - 1) >= 0) {
                            dp[i] += dp[pre-1];
                        }
                    }
                }
            }
            ans = max(ans, dp[i]); 
        }
        return ans;
    }
};
```



#### [42. Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/)

Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

```c++
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
```

**Constraints:**

- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> left(n, 0), right(n, 0);
        // get biggest on the left
        for(int i = 1; i < n; i++){
            left[i] = max(left[i-1], height[i-1]);
        }
        // get biggest on the right
        for(int i = n-2; i >=0 ; i--){
            right[i] = max(right[i+1],height[i+1]);
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
            ans += max(0, min(left[i],right[i])-height[i]);
        return ans;
    }
};
```



#### [62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/)

A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```c++
Input: m = 3, n = 7
Output: 28
```

**Constraints:**

- `1 <= m, n <= 100`
- It's guaranteed that the answer will be less than or equal to `2 * 10^9`.

```c++
class Solution {
public:
    // dp[y][x] = dp[y-1][x] + dp[y][x-1];
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1) return 1;
        // add 1 row and 1 column to solve 
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for(int y = 1; y <= m; y++){
            for(int x = 1; x <= n; x++){
                // bc dp[1][1] is start point:
                if(x == 1 && y == 1) dp[y][x] = 1; 
                else dp[y][x] = dp[y-1][x] + dp[y][x-1];
            }        
        }
        return dp[m][n];
    }
};
```



#### [63. Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/)

A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and space is marked as `1` and `0` respectively in the grid.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```c++
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

**Constraints:**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` is `0` or `1`.

```c++
// dp[i][j]: ways to reach (i, j); 
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& g) {
        int row = g.size(); // row
        int col = g[0].size(); // col
        vector<vector<int>> dp(row+1, vector<int>(col+1, 0));
        for(int y = 1; y <= row; y++){
            for(int x = 1; x <= col; x++){
                if(y == 1 && x == 1) {
                    // if the start point is a obstacle, return 0;
                    if(g[0][0] == 1) return 0;
                    else dp[y][x] = 1;
                }
                else if(g[y-1][x-1] != 1){ 
                    // this is not a obstacle
                    dp[y][x] = dp[y-1][x] + dp[y][x-1];
                }
                else{
                    // do nothing
                    // bc already initilized obstacles to 0; 
                }
            }
        }
        return dp[row][col];
    }
};
```

#### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

**Example 1:**

```c++
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

 **Constraints:**

- `1 <= n <= 45`

```c++
// dp[i]: ways to reach step i;
// dp[n]: ways to reach step n;
// init dp[0] and dp[1] to 1;

class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n;i++)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
};
```

```c++
// optimization for space complexity:
class Solution {
public:
    int climbStairs(int n) {
        int two = 1;
        int one = 1;
        int curr = 1;
        for(int i = 2; i <= n; i++){
           curr = two + one;
           two = one;
           one = curr;
        }
        return curr;
    }
};
```



#### [91. Decode Ways](https://leetcode-cn.com/problems/decode-ways/)

A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

To **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `"11106"` can be mapped into:

- `"AAJF"` with the grouping `(1 1 10 6)`
- `"KJF"` with the grouping `(11 10 6)`

Note that the grouping `(1 11 06)` is invalid because `"06"` cannot be mapped into `'F'` since `"6"` is different from `"06"`.

Given a string `s` containing only digits, return *the **number** of ways to **decode** it*.

The answer is guaranteed to fit in a **32-bit** integer. 

**Example 1:**

```c++
Input: s = "12"
Output: 2
Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
```

**Example 2:**

```c++
Input: s = "226"
Output: 3
Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6). 
```

**Constraints:**

- `1 <= s.length <= 100`
- `s` contains only digits and may contain leading zero(s).

```c++
// dp[i]: ways to decode for first i;
// transition function:
// (1) if cur char can decode independently,
// only 0 can not, bc 'A'->'1':
//     dp[i] += dp[i-1];
// (2) if cur char can decode with other:
// need: i>=2 && (s[i-2]-'0')*10+s[i-1]-'0' in [10, 26]
// dp[i] += dp[i-2];
class Solution {
public:
    int numDecodings(string s) {
        int cnt = 0;
        int n = s.size();
        vector<int> f(n + 1, 0);
        f[0] = 1;
        for(int i = 1; i <= n; i++){
            if(s[i-1] != '0') f[i] += f[i-1];
            if(i-2 >= 0){
                int t = (s[i-2] -'0') * 10 + s[i-1]-'0';
                if(t>=10 && t <= 26) f[i] += f[i-2];
            }
        }
        return f[n];
    } 
};
```



### (ii) longest increasing subsequence

#### [300. Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

Given an integer array `nums`, return the length of the longest strictly increasing subsequence. A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.

 **Example 1:**

```c++
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```

**Constraints:**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 **Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?

```c++
p.s something we need to notice if we choose to use greedy algorithm：
	e.g. 0，1，0，3，2，3
	when we operate the first 0, the next bigger num of 1 is the first 3, but what we want is 2, so greedy is not a good choice here
```

```c++
// dp[i]: the length of LIS ending at nums[i]
// return max(dp[i])
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(),1);
        int res = 0;
        for(int i = 0; i < nums.size(); ++i){
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = max(dp[i], dp[j]+ 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

```c++
class Solution {
public:
    // dp + binary search:
    // dp[i] : last value in LIS which length == i, index is length; 
    // so dp will be increasing : binary search
    int lengthOfLIS(vector<int>& nums) {
        int len = 1; // len start from 1
        int n = (int)nums.size();
        if (n == 0) return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 0; // dp[0] has no meaning, len can not be 0
        dp[1] = nums[0];
        for (int i = 1; i < n; ++i) {
            // if nums[i] bigger than the last value in d, append directly:
            if (nums[i] > dp[len]) {
                dp[++len] = nums[i];
            } else {
                // update
                int l = 1, r = len; 
                while (l < r) { 
                    int mid = (l + r) >> 1;
                    if (dp[mid] < nums[i]) {
                        l = mid + 1;
                    } else {
                        r = mid;
                    }
                }
                dp[l] = nums[i];
            }
        }
        return len;
    }
};
```

#### [354. Russian Doll Envelopes](https://leetcode-cn.com/problems/russian-doll-envelopes/)

You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return *the maximum number of envelopes you can Russian doll (i.e., put one inside the other)*.

**Note:** You cannot rotate an envelope. 

**Example 1:**

```c++
Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). 
```

**Constraints:**

- `1 <= envelopes.length <= 5000`
- `envelopes[i].length == 2`
- `1 <= wi, hi <= 104`

```c++
// transform to longest increasing subsequence:
// dp[i]: LIS ends at index i;
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        if(envelopes.empty()) return 0;
        int n = envelopes.size();
        int ans = 0;
        sort(envelopes.begin(), envelopes.end());
        vector<int> dp(n, 1); 
        // envelopes[i][0]: width
        // envelopes[i][1]: height
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                if(envelopes[j][0] < envelopes[i][0]
                && envelopes[j][1] < envelopes[i][1]){
                    dp[i] = max(dp[i], dp[j]+1);
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```



#### [673. Number of Longest Increasing Subsequence](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

Given an integer array `nums`, return *the number of longest increasing subsequences.*

**Notice** that the sequence has to be **strictly** increasing.

**Example 1:**

```
Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
```

**Example 2:**

```
Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
```

**Constraints:**

- `1 <= nums.length <= 2000`
- `-106 <= nums[i] <= 106`

```c++
// (1) method 1:
//  	this is similar to the question 300, at first I thought just find how many num that equal to ans in the vector dp, but it is wrong
//  	e.g. nums = [1,3,5,4,7] 
//  		dp[0] = 4 only shows once in dp, but it could be [1, 3, 4, 7] or [1, 3, 5, 7]
class Solution {
public:
    // similar to question 300: 
    //    Just need to find the number that equal to ans of question 300
    // and use extra vector to update the longest 
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int ans = 0;
        vector<int> dp(n, 1); //   dp[i]: lengeh of LIS ends with nums[i]
        vector<int> count(n,1); // count[i]: number of LIS ends with nums[i]
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j++){
                if(nums[i] <= nums[j]) continue;

                if(dp[j] + 1 > dp[i]){
                    // update the LIS length and count
                    dp[i] = dp[j] + 1;
                    count[i] = count[j]; 
                }
                else if(dp[j] + 1 == dp[i]){
                    // same length LIS, so add count[j] to count[i]; 
                    count[i] += count[j];
                }
            }
        }
        int max_len = *max_element(dp.begin(), dp.end()); // get the max_len
        for(int i = 0; i < n; i++) // add together to get ans
            if(dp[i] == max_len)
                ans += count[i];
        return ans;
    }
};
```



#### [674. Longest Continuous Increasing Subsequence](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

Given an unsorted array of integers `nums`, return *the length of the longest **continuous increasing subsequence** (i.e. subarray)*. The subsequence must be **strictly** increasing.

A **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.

**Example 1:**

```
Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
4.
```

**Example 2:**

```
Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly
increasing.
```

 **Constraints:**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

```c++
// dp or two pointers:
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return 0;
        vector<int> dp(n+1,1);
        int ans = 1;
        for(int i = 1; i < n; i++){
            if(nums[i-1] < nums[i]) dp[i] = dp[i-1] + 1;
            else dp[i] = 1;
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

```c++
// optimization: Only use O (1) space:
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.empty()) return 0;
        int n = nums.size();
        int ans = 1; // shortest length is 1
        int cur = 1;
        for(int i = 1; i < n; i++){
            if(nums[i-1] < nums[i])
                cur++;
            else
                cur = 1;
            ans = max(ans, cur);
        }
        return ans;
    }
};
```
#### [646. Maximum Length of Pair Chain](https://leetcode.cn/problems/maximum-length-of-pair-chain/)

You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.

A pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.

Return *the length longest chain which can be formed*.

You do not need to use up all the given intervals. You can select pairs in any order.

 

**Example 1:**

```c++
Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4].
```

**Example 2:**

```c++
Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].
```

 

**Constraints:**

- `n == pairs.length`
- `1 <= n <= 1000`
- `-1000 <= lefti < righti <= 1000`

```c++
class Solution {
public:
    // dp[i] = max(dp[0~i-1]) + 1;
    std::vector<int> dp;
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end());
        int pair_size = pairs.size();
        dp.resize(pair_size, 1);
        // find j that before i to form a longer chain
        for(int i = 1; i < pair_size; i++) {
            for(int j = 0; j < i; j++) {
                if(pairs[i][0] > pairs[j][1]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

#### [818. Race Car](https://leetcode-cn.com/problems/race-car/)

Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'`(reverse):

- When you get an instruction 'A', your car does the following:

  - `position += speed`
  - `speed *= 2`

- When you get an instruction 'R' , your car does the following:

  - If your speed is positive then `speed = -1`
  - otherwise `speed = 1`

  Your position stays the same.

For example, after commands `"AAR"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.

Given a target position `target`, return *the length of the shortest sequence of instructions to get there*. 

**Example 1:**

```c++
Input: target = 3
Output: 2
Explanation: 
The shortest instruction sequence is "AA".
Your position goes from 0 --> 1 --> 3.
```

**Example 2:**

```c++
Input: target = 6
Output: 5
Explanation: 
The shortest instruction sequence is "AAARA".
Your position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.
```

**Constraints:**

- `1 <= target <= 10^4`

```c++
    // position: 0 -> 1 -> 3 -> 7 -> 15:  2^n-1;
    // speed:    1 -> 2 -> 4 -> 8 -> 16
class Solution {
public:
    int racecar(int target) {
        // dp[i]: the min steps to reach target==i;
        vector<int> dp(target+1, 0x3f3f3f3f);
        // use i to enum every target
        for (int i = 1; i <= target; i++) {
            // why choose 2*i+1 as upper_bound:
            // need to get the max distance that beyond target i;
            // assume 2^(f-1)-1 < i && 2^f-1 >= i;
            // so i <= 2^f - 1 < 2 * i + 1 
            for (int A = 1; (1 << A) - 1 < (2*i+1) ; A++) {
                int A_Dis = (1 << A) - 1;
                // (1) if just move forward can reach target i; 
                if (A_Dis == i) { 
                    dp[i] = A; 
                } 
                // (2) if forward too much, need to go backwards:
                // +1 bc need 1 operation to make it reverse:
                // the rest target is (A_Dis - i);
                else if (A_Dis > i){
                    dp[i] = min(dp[i], A + 1 + dp[A_Dis - i]);
                }
                // (3) if not pass i, first go back R times, but R < A
                // if R >= A, then the steps before are wasted:    
                else { 
                    for (int R = 0; R < A; R++) {
                        int R_Dis = (1 << R) - 1;
                        // add 2 R operation here:
                        // (1) first  : start  <- mid   i
                        // (2) second : start  mid->    i
                        dp[i] = min(dp[i], A + 2 + R + dp[i - A_Dis + R_Dis]);
                    }
                }
            }
        }
        return dp[target];
    }
};
```



#### [978. Longest Turbulent Subarray](https://leetcode-cn.com/problems/longest-turbulent-subarray/)

Given an integer array `arr`, return *the length of a maximum size turbulent subarray of* `arr`.

A subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.

More formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:

- For i <= k < j :
  - `arr[k] > arr[k + 1]` when `k` is odd, and
  - `arr[k] < arr[k + 1]` when `k` is even.
- Or, for i <= k < j:
  - `arr[k] > arr[k + 1]` when `k` is even, and
  - `arr[k] < arr[k + 1]` when `k` is odd.

**Example 1:**

```c++
Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
```

**Constraints:**

- `1 <= arr.length <= 4 * 104`
- `0 <= arr[i] <= 109`

```c++
(1) f[i]: longest ends at arr[i];
(2) transition:
(i) if(((arr[i-2] < arr[i-1]) && (arr[i-1] > arr[i])) 
    || ((arr[i-2] > arr[i-1]) && (arr[i-1] < arr[i])))  
        f[i] = f[i-1] + 1;
(ii)  else if(arr[i] != arr[i-1]) f[i] = 2; // check if can build len==2
(iii) else if(arr[i] == arr[i-1]) f[i] = 0; // check if can build len==0
(3) return max(dp[i]);
```

```c++
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        int n = arr.size();
        if(n==1) return 1;
        vector<int> f(n, 0);
        f[0] = 0; f[1] = (arr[1] != arr[0])+1;
        int ans = f[1];
        for(int i = 2; i < n; i++){
            if(((arr[i-2] < arr[i-1]) && (arr[i-1] > arr[i])) 
            || ((arr[i-2] > arr[i-1]) && (arr[i-1] < arr[i]))) 
                f[i] = f[i-1] + 1;
            else if(arr[i] != arr[i-1]) f[i] = 2;
            else if(arr[i] == arr[i-1]) f[i] = 0;
            ans = max(ans, f[i]);
        }
        return ans;
    }
};
```

```c++
// optimization: O(1) space:
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        int n = arr.size();
        if(n==1) return 1;
        int first = 0, second = (arr[1] != arr[0])+1;
        int ans = second;
        int cur = 0;
        for(int i = 2; i < n; i++){
            if(((arr[i-2] < arr[i-1]) && (arr[i-1] > arr[i])) 
            || ((arr[i-2] > arr[i-1]) && (arr[i-1] < arr[i])))
                cur = second + 1;
            else if(arr[i] != arr[i-1]) cur = 2;
            else if(arr[i] == arr[i-1]) cur = 0;
            ans = max(ans, cur);
            second = cur;
            first = second;
        }
        return ans;
    }
};
```

#### [1048. Longest String Chain](https://leetcode-cn.com/problems/longest-string-chain/)

You are given an array of `words` where each word consists of lowercase English letters.

`wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly one** letter anywhere in `wordA` **without changing the order of the other characters** to make it equal to `wordB`.

- For example, `"abc"` is a **predecessor** of `"abac"`, while `"cba"` is not a **predecessor** of `"bcad"`.

A **word chain** is a sequence of words `[word1, word2, ..., wordk]` with `k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a **predecessor** of `word3`, and so on. A single word is trivially a **word chain** with `k == 1`.

Return *the **length** of the **longest possible word chain** with words chosen from the given list of* `words`.

 **Example 1:**

```c++
Input: words = ["a","b","ba","bca","bda","bdca"]
Output: 4
Explanation: One of the longest word chains is ["a","ba","bda","bdca"].
```

**Constraints:**

- `1 <= words.length <= 1000`
- `1 <= words[i].length <= 16`
- `words[i]` only consists of lowercase English letters.

```c++
class Solution {
public:
    // check if str1 is predecessor of str2:
    bool check(string& str1,string& str2){
        if(str2.size()-str1.size()!=1) return false;
        int pos = 0;
        for(int i=0; i<str2.size(); i++)
            if(str2[i]==str1[pos])
                pos++;
        return pos==str1.size();
    }
    // similar to LIS: only difference: treat str1 is predecessor of str2 as str1 < str2 in LIS
    int longestStrChain(vector<string>& words) {
        int n = words.size();
        // sort by length:
        sort(words.begin(),words.end(),[&](const auto& str1,const auto& str2){
            return str1.size() < str2.size();
        });
        vector<int>dp(n, 1);
        for(int i=1; i<n; i++)
            for(int j=0; j<i; j++)
                if(check(words[j],words[i]))
                    dp[i]=max(dp[i], dp[j]+1);
      // else do nothing, bc init to 1;  
      	return *max_element(dp.begin(),dp.end());
    }
};
```



#### [1218. Longest Arithmetic Subsequence of Given Difference](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)

Given an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.

A **subsequence** is a sequence that can be derived from `arr` by deleting some or no elements without changing the order of the remaining elements.

**Example 1:**

```c++
Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
```

**Example 2:**

```c++
Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
```

**Example 3:**

```c++
Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
```

**Constraints:**

- `1 <= arr.length <= 105`
- `-104 <= arr[i], difference <= 104`

```c++
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        unordered_map<int, int> mp; // <value, length>
        int ans = 1;
        for(auto& num : arr){
            // if has num-difference before, add 1 to length:
            if(mp.find(num - difference) != mp.end()){
                mp[num] = mp[num - difference]+1;
                ans = max(ans, mp[num]);
            } else { // else num as the start value:
                mp[num]=1;
            }
        }
        return ans;
    }
};
```





### (iii) max sum for subarray

#### [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*. A **subarray** is a **contiguous** part of an array.

**Example 1:**

```c++
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104` 

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

```c++
// dp[i]: max sum ends at nums[i]; TC:O(n)
```

```c++
class Solution {
public:
    // f[i]: longest subarray ends by nums[i];
    // f[i] = max(f[i-1], 0) + nums[i];
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        vector<int> f(n, 0);
        f[0]= nums[0];
        int ans = f[0];
        for(int i = 1; i < n; i++){
            f[i] = max(f[i-1], 0) + nums[i];
            ans = max(ans, f[i]);
        }
        return ans;
    }
};
```

```c++
// O(1) space optimization:
class Solution {
public:
    
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int res = nums[0];
        int last = nums[0];
        for(int i = 1; i < n; ++i){
            int now = max(last, 0) + nums[i];
            res = max(res, now);
            last = now;
        }
        return res;
    }
};
```



#### [152. Maximum Product Subarray](https://leetcode-cn.com/problems/maximum-product-subarray/)

Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return *the product*.

It is **guaranteed** that the answer will fit in a **32-bit** integer.

A **subarray** is a contiguous subsequence of the array.

**Example 1:**

```
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

```c++
// dp[i]: max product ends at nums[i];
// bc product can be positive and negative
// so save both smallest and biggest:
```

```c++
class Solution {
public:
   
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int min_val = 1, max_val = 1;
        int ans = INT_MIN;
        for(int i = 0; i < n; i++){
            int aa = min_val * nums[i];  
            int bb = max_val * nums[i]; 
            min_val = min(nums[i], min(aa, bb));
            max_val = max(nums[i], max(aa, bb));
            ans = max(ans, max_val);
        }
        return ans;
    }
};
```



#### [363. Max Sum of Rectangle No Larger Than K](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

Given an `m x n` matrix `matrix` and an integer `k`, return *the max sum of a rectangle in the matrix such that its sum is no larger than* `k`.

It is **guaranteed** that there will be a rectangle with a sum no larger than `k`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg)

```c++
Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2
Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).
```

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-100 <= matrix[i][j] <= 100`
- `-105 <= k <= 105`

**Follow up:** What if the number of rows is much larger than the number of columns?

```c++
class Solution
{
    vector<vector<int>> sums;
public:
    int maxSumSubmatrix(vector<vector<int>> &matrix, int k)
    {
        /*~~ 304. 2D prefixed sum ~~*/
        int m = matrix.size(), n = matrix[0].size();
        sums = vector<vector<int>>(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sums[i][j] = sums[i][j - 1] 
                           + sums[i - 1][j] 
                           - sums[i - 1][j - 1] 
                           + matrix[i - 1][j - 1];
            }
        }
        auto sumRange = [&](int row1, int col1, int row2, int col2) {
            return sums[row2][col2] - sums[row2][col1] - sums[row1][col2] + sums[row1][col1];
        };
        int ans = INT_MIN;
        /*~~560 subarray that sum==k ~~*/
        for (int col1 = 0; col1 < n; col1++) {
            // there is one test case that  row >> col;
            for (int col2 = col1+1; col2 <= n; col2++) {
                set<int> st;
                st.insert(0);
                for (int row = 1; row <= m; row++) {
                    int sum = sumRange(0, col1, row, col2);
                    auto it = st.lower_bound(sum-k);
                    if (it != st.end()) ans = max(ans, sum-*it);
                    st.insert(sum);
                }
            }
        }
        return ans;
    }
};
```



#### [918. Maximum Sum Circular Subarray](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

Given a **circular integer array** `nums` of length `n`, return *the maximum possible sum of a non-empty **subarray** of* `nums`.

A **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.

A **subarray** may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.

**Example 1:**

```
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3
```

**Constraints:**

- `n == nums.length`
- `1 <= n <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`

```c++
// (1) first assume it's not circular, get max
// (2) then assume it's circular, then A[0], A[n-1] will be chosen, so find min in the middle and use sum-min to get max.
// (3) choose the bigger max;
```

```c++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& A) {
        int n = A.size();
        // dp[i]: max sum ends at nums[i]:
        vector<int> dp(n, A[0]); 
        int sum = A[0];  
        int maxVal1 = A[0];
        for (int i = 1; i < A.size(); i++){
            sum += A[i];
            dp[i] = max(dp[i - 1] + A[i], A[i]);
            maxVal1 = max(maxVal1, dp[i]);
        }
        int minVal2 = 0;
        for (int i = 1; i < A.size()-1; i++){
            dp[i] = min(dp[i - 1] + A[i], A[i]);
            minVal2 = min(minVal2, dp[i]);
        }
        return max(maxVal1, sum-minVal2);
    }
};
```

#### [1800. Maximum Ascending Subarray Sum](https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/)

Given an array of positive integers `nums`, return the *maximum possible sum of an **ascending** subarray in* `nums`. A subarray is defined as a contiguous sequence of numbers in an array.

A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**. 

**Example 1:**

```c++
Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65. 
```

**Constraints:**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

```c++
class Solution {
public:
//     f[i] : maxnum ends at nums[i]
    int maxAscendingSum(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 0);
        dp[0] = nums[0];
        int ans = nums[0];
        for(int i = 1; i < n; i++){
            if(nums[i] > nums[i-1]){
                dp[i] = dp[i-1] + nums[i];
            }
            else dp[i] = nums[i];
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

#### [面试题 17.24. Max Submatrix LCCI](https://leetcode-cn.com/problems/max-submatrix-lcci/)

Given an NxM matrix of positive and negative integers, write code to find the submatrix with the largest possible sum.

Return an array `[r1, c1, r2, c2]`, where `r1`, `c1` are the row number and the column number of the submatrix's upper left corner respectively, and `r2`, `c2` are the row number of and the column number of lower right corner. If there are more than one answers, return any one of them.

**Note:** This problem is slightly different from the original one in the book.

**Example:**

```
Input:
[
   [-1,0],
   [0,-1]
]
Output: [0,1,0,1]
```

**Note:**

- `1 <= matrix.length, matrix[0].length <= 200`

```c++
class Solution {
public:
    // (1) enum i,j to use two pointers to traversal all possible height for the matrix: 
    // (2) 918.column prefixSum(treat column sum as one value)+ 53. Maximum Subarray:
    vector<int> getMaxMatrix(vector<vector<int>>& matrix) {
        int n = matrix.size(), m = matrix[0].size();
        if (n == 0) return {0,0,0,0} ;
        int r1 = 0, r2 = 0, c1 = 0, c2 = 0;
        int max_sum = matrix[0][0];
        // prefix_sum_col[i][j] : sum of column from matrix[0][j] to matrix[i][j]:
        vector<vector<int>> prefix_sum_col(n, vector<int>(m, 0));
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
            {
                if(i == 0) prefix_sum_col[i][j] = matrix[i][j];
                else prefix_sum_col[i][j] = prefix_sum_col[i-1][j] + matrix[i][j];
            }
        r1 = 0; r2 = 0; c1 = 0; c2 = 0;
        //======== 53 Maximum Subarray: =========//
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j <= i; j++)
            {    
                vector<int> dp(m, 0); // dp[i]: max sum ends at column i
                dp[0] = prefix_sum_col[i][0] - prefix_sum_col[j][0] + matrix[j][0];
                int cur_c1 = 0, cur_c2 = 0;
                for(int k = 1; k < m; k++){
                    int cur_sum = prefix_sum_col[i][k] - prefix_sum_col[j][k] + matrix[j][k];
                    if(dp[k-1] < 0){   
                        dp[k] = cur_sum;  
                        cur_c1 = k; 
                        cur_c2 = k;
                    }
                    else{
                        dp[k] = dp[k-1] + cur_sum;    
                        cur_c2 = k;
                    }
                    if(dp[k] > max_sum) /// only update r and c when bigger than max_sum:
                    {
                        r1 = j; // rows update to current upper and lower bound
                        r2 = i; 
                        c1 = cur_c1; 
                        c2 = cur_c2;
                        max_sum = dp[k]; // update max_sum
                    }
                }
            }
        }
        return {r1,c1, r2,c2};
    }
};
```



### (iv) house robbery

#### [198. House Robber](https://leetcode-cn.com/problems/house-robber/)

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```c++
// dp[i]: max profit for first i houses:
// dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
// dp[0] = nums[0]; // only have one house
// dp[1] = max(nums[0], nums[1]); // choose 1
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        vector<int> dp(n, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < n; i++){
            dp[i] = max(dp[i-2] + nums[i], dp[i-1]);
        }
        return dp[n-1];
    }
};
```

```c++
// O(1) space optimization:
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int minus2 = nums[0];
        int minus1 = max(nums[0], nums[1]);
        int cur = 0;
        for(int i = 2; i < n; i++){
            cur = max(minus2 + nums[i], minus1);
            minus2 = minus1;
            minus1 = cur;
        }
        return minus1;
    }
};
```



#### [213. House Robber II](https://leetcode-cn.com/problems/house-robber-ii/)

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

**Example 1:**

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

```c++
// circular: can't choose first and last together:
// so check from 0 to n-1
// then check from 1 to n, the rest is sames as 198. House Robber I
```

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int ans = 0;
        vector<int> dp(n+1, 0);
        dp[0] = 0;
        dp[1] = nums[0]; // can choose to rob first
        // rob from 0 to n-1
        for(int i = 2; i < n; i++){
            dp[i] = max( dp[i-2]+nums[i-1], dp[i-1]);
        }
        ans = dp[n-1]; // nums can steal from 0 to n-1
        dp.clear();
        
        dp[0] = 0; 
        dp[1] = 0; // can't choose to rob first
        dp[2] = nums[1]; // start from 2nd house, so i init to 3
        for(int i = 3; i <= n; i++){
            dp[i] = max(dp[i-2]+ nums[i-1], dp[i-1]);
        }
        return max(ans, dp[n]); // choose biggest profit
    }
};
```

```c++
// can also optimize to O(1) space same as in 198. House robber I, bc dp[i] only depends on dp[i-2] and dp[i-1];
```



#### [337. House Robber III](https://leetcode-cn.com/problems/house-robber-iii/)

The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.

Besides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.

Given the `root` of the binary tree, return *the maximum amount of money the thief can rob **without alerting the police***.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
```

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `0 <= Node.val <= 104`

```c++
(1) method 1:  
   use pair<steal, not steal> to save result;
   e.g. [2,1,3,null,4]
        2
       / \
      1   3
       \
        4
can rob both 3 and 4 at the same time:
So not just sum every other layer.
```

```c++
class Solution {
public:
    // every node only have two status: steal or not
    // first  : sum when not steal
    // second : sum when steal
    // return the max sum for stealing or not stealing:
    int rob(TreeNode* root) {
        pair<int, int> res = dfs(root);
        return max(res.first, res.second);
    }
    // dfs return max profit for steal or not steal root:
    // first: not steal, second: steal;
    pair<int, int> dfs(TreeNode* root){
        if(root == nullptr) return {0, 0};
        pair<int, int> l = dfs(root->left);
        pair<int, int> r = dfs(root->right);
        return make_pair(
            /// first: not steal root, decide subtree seperately:
            max(l.first, l.second) + max(r.first, r.second),
            // second: choose to steal root + not steal children
            root->val + l.first + r.first
        );
    }
};
```



```c++
// (2) method 2: Memorization recursion
    Use map to store the max the thief can get from cur node;
    sum[root] = val; 
    if(sum.find(root) != sum.end()) 
        return sum[root];
```

```c++

class Solution {
public:
    unordered_map<TreeNode*, int> sum;
    int rob(TreeNode* root) {
        // got nothing on nullptr node
        if (root == nullptr) return 0;
        if(sum.find(root) != sum.end()) return sum[root];
        // val1 : amount of cur node
        int val1 = root->val;
        // first plan: 
        // (1) cur root has left child: get his left->left and left->right
        if (root->left != nullptr) 
            val1 += rob(root->left->left) + rob(root->left->right);
        // (2) cur root has right child: get his right->left and right->right
        if (root->right != nullptr) 
            val1 += rob(root->right->left) + rob(root->right->right);
        // second plan: we don't want cur node
        //  then we can have cur node->left and node->right
        int val2 = rob(root->left) + rob(root->right);
        // At last cmp first plan and second plan, we choose a better one;
        sum[root] = max(val1, val2);
        return sum[root];
    }
};
```



#### [740. Delete and Earn](https://leetcode-cn.com/problems/delete-and-earn/)

You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:

- Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.

Return *the **maximum number of points** you can earn by applying the above operation some number of times*. 

**Example 1:**

```c++
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
```

**Example 2:**

```c++
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
```

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `1 <= nums[i] <= 104`

```c++
// e.g. [2,2,3,3,3,4]
// delete 3 will not have influence on other 3
// so can delete all 3 in one operation:
// and rob nums[i], need to delete nums[i]-1 and nums[i]+1:
// so transform to house robbery problems:
```

```c++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
    // can't use max_element for empty vector
        if(nums.size()==0) return 0; 
        int max_num = *max_element(nums.begin(), nums.end());
    // vector sum only need to have max_num+1 length:
        vector<int> sum(max_num+1, 0); 
        for (int i = 0; i < nums.size(); i ++) {
            sum[nums[i]] += nums[i];
        }
      // following part can be optimized to O(1) space, same as Leetcode 198.
        vector<int> dp(max_num+1, 0);
        dp[0] = 0;
        dp[1] = sum[1]; 
        for (int i = 2; i < sum.size(); i ++) {
            dp[i] = max(dp[i-1], dp[i-2] + sum[i]);
        }
        return dp[max_num];
    }
};
```



#### [1235. Maximum Profit in Job Scheduling](https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/)

We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png)**

```
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png)**

```
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.
```

**Example 3:**

**![img](https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png)**

```
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6
```

**Constraints:**

- `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`
- `1 <= startTime[i] < endTime[i] <= 109`
- `1 <= profit[i] <= 104`

```c++
// (1) method 1:
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size();
        vector<int> job(n+1);
        for(int i = 0; i <= n; i++){
            job[i] = i;
        }
        // sort job id by 
        sort(job.begin()+1, job.end(), [&](int& a, int& b) {
            return endTime[a-1]< endTime[b-1]; 
        });
        vector<int> prev(n + 1);
        for (int i = 1; i <= n; i++){
            for (int j = i - 1; j >= 1; j--){
                if (endTime[job[j]-1] <= startTime[job[i]-1])
                {
                    prev[i] = j;
                    break;
                }
            }
        }
        vector<int>dp(n + 1);
        dp[1] = profit[job[1]-1];
        for (int i = 1; i <= n; i++)
            dp[i] = max(dp[i - 1], profit[job[i]-1] + dp[prev[i]]);
        return dp[n];
    }
};
```

```c++
// optimization: use binary search to accelerate find pre: O(nlogn):
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size();
        vector<int> index(n);
        iota(index.begin(), index.end(), 0);
        sort(index.begin(), index.end(), [&](int i, int j) {
            return endTime[i] < endTime[j];
        });
        vector<int> dp(n+1);
        int left, right, mid;
        for (int i = 0; i < n; ++i) {
            left = 0, right = i;
            while (left < right) {
                mid = left + (right - left) / 2;
                if (endTime[index[mid]] <= startTime[index[i]]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            dp[i+1] = max(dp[i], dp[left] + profit[index[i]]);
        }
        return dp[n];
    }
};
```



#### [1388. Pizza With 3n Slices](https://leetcode-cn.com/problems/pizza-with-3n-slices/)

There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:

- You will pick **any** pizza slice.
- Your friend Alice will pick next slice in anti clockwise direction of your pick. 
- Your friend Bob will pick next slice in clockwise direction of your pick.
- Repeat until there are no more slices of pizzas.

Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/02/18/sample_3_1723.png)

```c++
Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2020/02/18/sample_4_1723.png)**

```c++
Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.
```

**Constraints:**

- `1 <= slices.length <= 500`
- `slices.length % 3 == 0`
- `1 <= slices[i] <= 1000`

```c++
(1) similar to House Robbery II, circular array can not choose the first and last element at the same time.
  so dp twice and choose bigger one: 0 ~ n-1 + 1 ~ n;

(2) dp[i][j]: choose j elements from first i elements;
    dp[i][j] = max(dp[i-2][j-1]+slices[i-1], dp[i-1][j]);

(3) why i-1 in slices[i-1]: i,j are numbers start from 1 but for slices is index, start from 0, so use i-1:
```

```c++
class Solution {
public:
    int calculate(const vector<int>& slices) {
        int n = slices.size();
        int choose = (n+1)/3; // how many slices need to choose
        vector<vector<int>> dp(n+1, vector<int> (choose + 1,0));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= min(choose, i); j++){
                // (1) dp[i-1][j]: not select current;
                // (2) dp[i-2][j-1] + slices[i-1]: select current;
                dp[i][j] = max(dp[i-1][j], 
                               ((i-2>=0)?dp[i-2][j-1]:0) + slices[i-1]);
            }
        }
        return dp[n][choose];  
    }
    int maxSizeSlices(vector<int>& slices) {
        vector<int> v1(slices.begin() + 1, slices.end());
        vector<int> v2(slices.begin(), slices.end() - 1);
        int ans1 = calculate(v1);
        int ans2 = calculate(v2);
        return max(ans1, ans2);
    }
};
```



## (2) double strings:

#### [10. Regular Expression Matching](https://leetcode-cn.com/problems/regular-expression-matching/)

Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:

- `'.'` Matches any single character.
- `'*'` Matches zero or more of the preceding element.

The matching should cover the **entire** input string (not partial). 

**Example 1:**

```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
```

**Example 2:**

```
Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
```

**Example 3:**

```
Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
```

**Example 4:**

```
Input: s = "aab", p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
```

**Example 5:**

```
Input: s = "mississippi", p = "mis*is*p*."
Output: false
```

**Constraints:**

- `1 <= s.length <= 20`
- `1 <= p.length <= 30`
- `s` contains only lowercase English letters.
- `p` contains only lowercase English letters, `'.'`, and `'*'`.
- It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.

```c++
// dp[i][j]: if first i of s matches first j of p:
// return dp[m][n];
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        if(s == p) return true;
        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));
        dp[0][0]= true;//"" matches ""
        for(int i = 1; i <= n; i++){
            if(p[i-1] == '*' && dp[0][i-2]){
                dp[0][i]=true;
            }
        }
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i-1] == p[j-1] || p[j-1]=='.'){
                    dp[i][j] = dp[i-1][j-1];
                }
                else if(p[j-1] =='*') {
                    if(p[j-2] != s[i-1] && p[j-2] != '.'){
                        dp[i][j] = dp[i][j-2];
                    }
                    else {   	
                        dp[i][j] = dp[i][j-2]  // (1)b* = "": a, ab*;
                                || dp[i-1][j]; // (3)b* = bbbb: b* can match multiple chars in string s; 
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```



#### [44. Wildcard Matching](https://leetcode-cn.com/problems/wildcard-matching/)

Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:

- `'?'` Matches any single character.
- `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the **entire** input string (not partial).

**Example 1:**

```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
```

**Example 2:**

```
Input: s = "aa", p = "*"
Output: true
Explanation: '*' matches any sequence.
```

**Example 3:**

```
Input: s = "cb", p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
```

**Example 4:**

```
Input: s = "adceb", p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
```

**Example 5:**

```
Input: s = "acdcb", p = "a*c?b"
Output: false 
```

**Constraints:**

- `0 <= s.length, p.length <= 2000`
- `s` contains only lowercase English letters.
- `p` contains only lowercase English letters, `'?'` or `'*'`.

```c++
// dp[i][j]: if first i of s matches first j of p:
// return dp[m][n];
class Solution {
public:
    bool isMatch(string s, string p) {
        int ss = s.size(), ps = p.size();
        vector<vector<int>> dp(ss+1, vector<int>(ps+1, 0));
        dp[0][0] = 1;
        for(int j = 1; j <= ps; j++){
            if(p[j-1] == '*') dp[0][j] = dp[0][j-1];
            else break;
        }
        for(int i = 1; i <= ss; i++){
            for(int j = 1; j <= ps; j++){
                if(s[i-1] == p[j-1] || p[j-1]=='?'){
                    dp[i][j] = dp[i-1][j-1];
                }
                else if(p[j-1] == '*'){
                    // * represents for 0 character || multiple chars:
                    dp[i][j] = dp[i][j-1] || dp[i-1][j];
                }
            }
        }
        return dp[ss][ps];
    }
};
```



#### [72. Edit Distance](https://leetcode-cn.com/problems/edit-distance/)

Given two strings `word1` and `word2`, return *the minimum number of operations required to convert `word1` to `word2`*.

You have the following three operations permitted on a word:

- Insert a character
- Delete a character
- Replace a character 

**Example 1:**

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
```

**Example 2:**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

 

**Constraints:**

- `0 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of lowercase English letters.

```c++
// dp[i][j]: if first i of s matches first j of p:
// return dp[m][n];
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        vector<vector<int> > f(n+1, vector<int>(m+1));
        // f[i][j]: min steps to make first i of s matches first j; 
        // (1) insert: f[i][j] = 1 + f[i-1][j];
        // (2) delete: f[i][j] = 1 + f[i][j-1];
        // (3) replace: if(word1[i] == word2[j]) 
            // f[i][j] = f[i-1][j-1] 
        //     else f[i][j] = f[i-1][j-1] + 1;
        for(int i = 0; i <= n; i++) f[i][0] = i;
        for(int i = 0; i <= m; i++) f[0][i] = i;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;
                f[i][j] = min(f[i][j], f[i-1][j-1] + (word1[i-1]!=word2[j-1]));
            }
        }
        return f[n][m];
    }
};
```



#### [97. Interleaving String](https://leetcode-cn.com/problems/interleaving-string/)

Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.

An **interleaving** of two strings `s` and `t` is a configuration where they are divided into **non-empty** substrings such that:

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**Note:** `a + b` is the concatenation of strings `a` and `b`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

```
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
```

**Constraints:**

- `0 <= s1.length, s2.length <= 100`
- `0 <= s3.length <= 200`
- `s1`, `s2`, and `s3` consist of lowercase English letters.

 **Follow up:** Could you solve it using only `O(s2.length)` additional memory space?

```c++
class Solution {
public:
    // dp[i][j]: if s1[0~i-1] and s2[0~j-1] can be s3[0~i+j-1];
    // return dp[m][n];
    bool isInterleave(string s1, string s2, string s3) {
        if(s1.size()+s2.size() != s3.size()) return false;
        int n1 = s1.size();
        int n2 = s2.size();
        vector<vector<int> > dp(n1+1, vector<int> (n2+1));
        dp[0][0] = true;
        // init dp[0][i] and dp[i][0]:
        // (1) only use char in s1:
        for(int i=1;i<=n1;++i)
            dp[i][0] = dp[i-1][0] && (s1[i-1]==s3[i-1]);
        // (2) only use char in s2:
        for(int i=1;i<=n2;++i)
            dp[0][i] = dp[0][i-1] && (s2[i-1]==s3[i-1]);
        for(int i=1; i<=n1; i++){
            for(int j=1; j<=n2; j++){
                dp[i][j] = (dp[i-1][j] && s1[i-1]==s3[i-1+j])
                        || (dp[i][j-1] && s2[j-1]==s3[i-1+j]);
            }
        }
        return dp[n1][n2];
    }
};
```



#### [115. Distinct Subsequences](https://leetcode-cn.com/problems/distinct-subsequences/)

Given two strings `s` and `t`, return *the number of distinct subsequences of `s` which equals `t`*. A string's **subsequence** is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., `"ACE"` is a subsequence of `"ABCDE"` while `"AEC"` is not).

It is guaranteed the answer fits on a 32-bit signed integer. 

**Example 1:**

```
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways you can generate "rabbit" from S.
rabbbit
rabbbit
rabbbit
```

 **Constraints:**

- `1 <= s.length, t.length <= 1000`
- `s` and `t` consist of English letters.

```c++
class Solution {
public:
    int big = 1e9 + 7;
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        // dp[i][j]: number of different seq for first i of s, first j of t
        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        // when j is "", dp[i][0] = 1;
        for(int i = 0; i <= n; i++) dp[i][0] = 1;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                // trim: if j > i, first j of t can not be sub seq of first i of s
                if(j > i) continue;
                
                if(s[i-1] == t[j-1])
                    dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % big; // use or not use s[i]:
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[n][m];
    }
};
```





#### [583. Delete Operation for Two Strings](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

Given two strings `word1` and `word2`, return *the minimum number of **steps** required to make* `word1` *and* `word2` *the same*. In one **step**, you can delete exactly one character in either string. 

**Example 1:**

```c++
Input: word1 = "sea", word2 = "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea". 
```

**Constraints:**

- `1 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of only lowercase English letters.

```c++
// the min steps to make first i word1 and first j word2 same
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        // must init dp[i][0] and dp[0][j]
        for (int i = 0; i <= n; i++) dp[i][0] = i;
        for (int j = 0; j <= m; j++) dp[0][j] = j;

        // bc from i-1 to get 1, j-1 to get j, so i,j all start from 1 to n,m
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[n][m];
    }
};
```



#### [712. Minimum ASCII Delete Sum for Two Strings](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

Given two strings `s1` and `s2`, return *the lowest **ASCII** sum of deleted characters to make two strings equal*.

**Example 1:**

```
Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
```

**Example 2:**

```c++
Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
```

**Constraints:**

- `1 <= s1.length, s2.length <= 1000`
- `s1` and `s2` consist of lowercase English letters.

```c++
// To make the delete part smallest, the part to keep should be biggest:
// so this is longest common subsequence problem:
// dp[i][j]: sum for LCS 
// return total - 2 * dp[n][m] = to_delete;
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int total = 0, l1 = s1.length(), l2 = s2.length();
        for(char c : s1) total += c;
        for(char c : s2) total += c;
        vector<vector<int>> dp(l1 + 1, vector<int>(l2 + 1, 0));
        for(int i = 1; i <= l1; ++i){
            for(int j = 1; j <= l2; ++j){
                if(s1[i - 1] == s2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + s2[j - 1];
                }else{
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return total - 2 * dp[l1][l2];
    }
};
```



#### [718. Maximum Length of Repeated Subarray](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

Given two integer arrays `nums1` and `nums2`, return *the maximum length of a subarray that appears in **both** arrays*. 

**Example 1:**

```c++
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
```

**Constraints:**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`

```c++
class Solution {
public:
    // dp[i][j]: LCS
    // when A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1;
    // else dp[i][j] = 0;
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1,0));
        int ans= 0;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <=n; j++){
                if(A[i-1] == B[j-1]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = 0;
                }
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```



#### [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)

Given two strings `text1` and `text2`, return *the length of their longest **common subsequence**.* If there is no **common subsequence**, return `0`.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

- For example, `"ace"` is a subsequence of `"abcde"`.

A **common subsequence** of two strings is a subsequence that is common to both strings. 

**Example 1:**

```
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
```

**Constraints:**

- `1 <= text1.length, text2.length <= 1000`
- `text1` and `text2` consist of only lowercase English characters.

```c++
class Solution {
public:
    // dp[i][j]: the length of LCS between 
    // the first i chars of string a and first j chars of string b
    int longestCommonSubsequence(string a, string b) {
        int m = a.size();
        int n = b.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1, 0)); // 初始化默认是0
        for(int i = 1; i <=m; ++i){
            for(int j = 1; j<=n; ++j){
                if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;
                else dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
            }
        }
        return dp[m][n];
    }
};
```

## (3) matrix:

#### [64. Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum/)

Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. **Note:** You can only move either down or right at any point in time. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```c++
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
```

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

```c++
// (1) method 1: 
// top-left to right-bottom, so start from dp[0][0].
// dp[i][j]: the min sum from 0,0 to i,j;
// return dp[n][m];
class Solution {
public:

    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int n = grid.size(), m = grid[0].size();
        vector<vector<int> > dp(n+1, vector<int>(m+1, INT_MAX));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(i == 1 && j==1){
                    dp[i][j] = grid[i-1][j-1];
                    continue;
                } else {
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) 
                                + grid[i-1][j-1];
                }
            }
        }
        return dp[n][m];
    }
};
```

```c++
// space optimize to O (N)
// still need to figure out how to reduce to 1D
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> dp(n, 0);
        dp[0] = grid[0][0];    
        for (int j = 1; j < n; ++j){
            dp[j] = dp[j - 1] + grid[0][j];
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (j == 0) {
                    dp[j] = dp[j] + grid[i][j];
                } else {
                    dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
                }
            }
        }
        return dp[n - 1];
    }
};
```



#### [85. Maximal Rectangle](https://leetcode-cn.com/problems/maximal-rectangle/)

Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return *its area*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```c++
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 6
Explanation: The maximal rectangle is shown in the above picture.
```

**Constraints:**

- `rows == matrix.length`
- `cols == matrix[i].length`
- `0 <= row, cols <= 200`
- `matrix[i][j]` is `'0'` or `'1'`.

```c++
// (1) method 1:  monotous stack:
// TC: O(m*n):
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return 0;
        int m = matrix.size(), n = matrix[0].size(), ans = 0; 
        vector<vector<int>> left(m, vector<int>(n, 0));
        // build left: the num of continuous 1 on the left: O(m*n):
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if(matrix[i][j]=='1')
                    left[i][j] = (j == 0 ? 0: left[i][j-1]) + 1; 
        //monotous stack for every column:
        for(int j = 0; j < n; j++){ //O(n*m)
            stack<int> s;
            // init is important:
            // inint up as -1, -1 will be upper bound for the 
            // element still in stack after traversal
            vector<int> up(m,-1), down(m, m); 
            // find upper and lower bound(next smaller)for every element:
            // this bound can not be reached:
            for(int i = 0; i < m; i++){
                while(!s.empty() && left[i][j] <= left[s.top()][j]){
                    down[s.top()] = i;  s.pop();
                }
                up[i] = s.empty() ? -1 : s.top();
                s.push(i);
            }
            // update ans:
            for(int i = 0; i < m; i++){
                if(left[i][j] == '0') break;
                //  down[i]-1)-(up[i]-1)+1: bound can not choose:
                ans = max(ans, left[i][j] * (down[i]-up[i]-1));
            }
        }
        return ans;
    }
};
```



#### [118. Pascal's Triangle](https://leetcode-cn.com/problems/pascals-triangle/)

Given an integer `numRows`, return the first numRows of **Pascal's triangle**. In **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

 

**Example 1:**

```c++
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**Constraints:**

- `1 <= numRows <= 30`

```c++
init all as 1:
dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
resize i+1 for every row:
```

```c++
// numRows is total lines, so biggest index is numRows-1
// init all as 1:
// dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
// resize i+1 for every row:
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> dp( numRows, vector<int>(numRows, 1));
        
        for (int i = 0; i < numRows; i ++){
            for (int j = 1; j < i; j ++){
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
            }
        }
        for(int i = 0; i < numRows; i++){
            dp[i].resize(i+1);
        }
        return dp;
    }
};
```



#### [119. Pascal's Triangle II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**. In **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

 

**Example 1:**

```
Input: rowIndex = 3
Output: [1,3,3,1]
```

**Constraints:**

- `0 <= rowIndex <= 33` 

**Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?

```c++
// 0-index:
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>> dp(rowIndex+1, vector<int>(rowIndex+1, 1));
        for(int i = 0; i < rowIndex+1; i++){
            for(int j = 1; j < i; j++){
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
            }
        }
        return dp[rowIndex];

    }
};
```

```c++
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> dp(rowIndex+1, 0);
        dp[0] = 1;
        for(int i = 1; i <= rowIndex; i++){
            for(int j = i; j > 0; j--){
                // dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                // bc need j-1 to update j, so if use 
              	// 1D dp, the j should be update from i;
                // bc dp[j-1] saved last round value 
                // when we update dp[j]:
                dp[j] = dp[j-1] + dp[j];
            }
        }
        return dp;
    }
};
```



#### [120. Triangle](https://leetcode-cn.com/problems/triangle/)

Given a `triangle` array, return *the minimum path sum from top to bottom*. For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row. 

**Example 1:**

```c++
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

**Constraints:**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-104 <= triangle[i][j] <= 104`

**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?

```c++
// (1) method 1 : 
//     DP,自底向上直接修改，相当于记录从最后一行到第一行的路径长度。
// 因为三角形的数组，所以下层数量比上层数量多，triangle[i+1][j], triangle[i+1][j+1]，所以可以防止数据溢出
//     In the example, when we start from the bottom: 
//         we can reach 6 from 4 or 1: so we have two paths: one is 4=>6, another is 1=>6,
//     so the sum of the paths respectively is 10 and 7, which means if we wanna reach 6 from the
//     bottom, at least need 7 for path sum 。

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        for(int i = triangle.size()-2; i >= 0; i--)
            for(int j = 0; j < triangle[i].size(); j++)
                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]);
        return triangle[0][0];
    }
};
```

```c++
// 不修改数组解法：使用额外空间：

class Solution {
public: 
    // 自底向上方法:
    // 状态定义: dp[i][j]: min path from the bottom to t[i][j];
    // 状态转移: dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + t[i][j];
    // 结果定义: dp[0][0]
    int minimumTotal(vector<vector<int>>& t) {
        if(t.empty() || t[0].empty()) return 0;
        // 因为从倒数第二层开始判断，所以判断是否只有一层;
        if(t.size() == 1) return t[0][0];
        int n = t.size();
        vector<vector<int>> dp(n+1, vector<int>(n+1));
        // j <= i
        for(int i = n - 1; i >= 0; i--){
            for(int j = 0; j <= i; j++){
                dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + t[i][j];
            }
        }
        return dp[0][0];
    }
};
```

```c++
//优化: 因为第i层只依赖于第i+1层的信息，所以直接把第一维i删除即可
class Solution {
public: 
    int minimumTotal(vector<vector<int>>& t) {
        if(t.empty() || t[0].empty()) return 0;
        // 因为从倒数第二层开始判断，所以判断是否只有一层;
        if(t.size() == 1) return t[0][0];
        int n = t.size();
        vector<int> dp(n+1);
        for(int i = n - 1; i >= 0; i--){
            for(int j = 0; j <= i; j++){ // j <= i
                dp[j] = min(dp[j], dp[j+1]) + t[i][j];
            }
        }
        return dp[0];
    }
};
```



#### [174. Dungeon Game](https://leetcode-cn.com/problems/dungeon-game/)

The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.

Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).

To reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.

Return *the knight's minimum initial health so that he can rescue the princess*.

**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg)

```c++
Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
Output: 7
Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.
```

**Example 2:**

```c++
Input: dungeon = [[0]]
Output: 1
```

**Constraints:**

- `m == dungeon.length`
- `n == dungeon[i].length`
- `1 <= m, n <= 200`
- `-1000 <= dungeon[i][j] <= 1000`

```c++
class Solution {
public:
    // hp[y][x]: min hp needed to reach (x, y)
    // start from the right-bot: set the right, bot of princess to 1, bc pass princess need at least 1 hp:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int row = dungeon.size(); // row
        int col = dungeon[0].size();  // col
        vector<vector<int>> hp(row+1, vector<int> (col+1, 0x3f3f3f3f));
        hp[row-1][col] = hp[row][col-1] = 1;
        for(int y = row-1; y >= 0; --y){
            for(int x = col-1; x >= 0; --x){
                // need max(1,): for every spot, hp must be at least 1 to be alive
                hp[y][x] = max(1, min(hp[y][x+1], hp[y+1][x])
                                - dungeon[y][x]);
            }
        }
        return hp[0][0];
    }
};
```



#### [221. Maximal Square](https://leetcode-cn.com/problems/maximal-square/)

Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, *find the largest square containing only* `1`'s *and return its area*. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

```c++
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

```c++
Input: matrix = [["0","1"],["1","0"]]
Output: 1 
```

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` is `'0'` or `'1'`.

```c++
class Solution {
public:
    // dp[i][j]: max side that (i,j) can be;
    // dp[i][j] = 1 + max(max(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]);
    // result: max(dp[0 : n-1][0 : j-1])
    // return area, side * side
    int maximalSquare(vector<vector<char>>& g) {
        if(g.empty() || g[0].empty()) return 0;
        int n = g.size(), m = g[0].size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        int ans = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(g[i-1][j-1] == '0') continue;
                dp[i][j] = 1 + min(min(dp[i-1][j], dp[i][j-1]), 
                                    dp[i-1][j-1]);
                ans = max(ans, dp[i][j]); 
            }
        }
        return ans*ans;
    }   
};
```



#### [329. Longest Increasing Path in a Matrix](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

Given an `m x n` integers `matrix`, return *the length of the longest increasing path in* `matrix`. From each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

```c++
Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

```c++
Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
```

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 200`
- `0 <= matrix[i][j] <= 231 - 1`

```c++
// (1) method 1: DFS + DP (top down)
// 时间复杂度 = 子问题数量 * 子问题非递归部分时间
class Solution {
private: 
    int m; // row of the matrix
    int n; // col of the matrix
    vector<vector<int>> dp;
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        int ans = 0; // ans is final result
        m = matrix.size();
        n = matrix[0].size();
        dp = vector<vector<int>>(m,vector<int>(n,-1));
        for(int y = 0; y < m; y++){
            for(int x = 0; x < n; x++){
                // update ans
                ans = max(ans, dfs(matrix,x,y));
            }
        }
        return ans;
    }
    // return the len of the longest increasing path: 
    int dfs(const vector<vector<int>> &matrix, int x, int y){
        if(dp[y][x] != -1) return dp[y][x];
        static int dx[] = {0,-1,0,1};
        static int dy[] = {-1,0,1,0};
        dp[y][x] = 1;
        for(int i = 0; i < 4; i++){
            int tx = x + dx[i];
            int ty = y + dy[i];
            // check left, right, top, bottom of (x,y)
            if(tx < 0 || ty < 0 || tx >= n || ty >= m 
            	|| matrix[ty][tx] <= matrix[y][x]){
                continue;
            }
            dp[y][x] = max(dp[y][x], 1 + dfs(matrix,tx,ty));
        }
        return dp[y][x];
    }
};
```

```c++

// (2) method 2: DP :  bottom up
// DP core idea : Build larger solutions from smaller ones; So the longest path starting with a larger number is a subproblem of the longest path starting with a smaller number。

class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        int ans = 0;
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 1)); 
        vector<pair<int, pair<int, int> >> cells;
        // build cell vector for sorting
        for(int y = 0; y < m; y++)
            for(int x = 0; x < n; x++)
                cells.push_back({matrix[y][x],{y,x}});

        sort(cells.rbegin(), cells.rend());
        // Sort finished, then we start operation from the biggest element
        static int dx[] = {0, -1, 0, 1};
        static int dy[] = {-1, 0, 1, 0};
        
        for(const auto & cell : cells){
            // get the biggest in the rest of the elements: cell={matrix[y][x],{x,y}}
            int y = cell.second.first;
            int x = cell.second.second;
            // In four rounds,(ty,tx)is: top,bottom,left,right cell of (y,x);
            for(int i = 0; i < 4; i++){
                int tx = x + dx[i];
                int ty = y + dy[i];
                // (1) out of bound
                if(tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                // (2) cur cell value < matrix[y][x]
                if(matrix[ty][tx] <= matrix[y][x]) continue;
                // (3) Available for updating:
                dp[y][x] = max(dp[y][x], 1 + dp[ty][tx]); 
            } 
            // update final ans after checking every cell
            ans = max(ans, dp[y][x]);
        }
        return ans;
    }
};
```



#### [650. 2 Keys Keyboard](https://leetcode-cn.com/problems/2-keys-keyboard/)

There is only one character `'A'` on the screen of a notepad. You can perform two operations on this notepad for each step:

- Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
- Paste: You can paste the characters which are copied last time.

Given an integer `n`, return *the minimum number of operations to get the character* `'A'` *exactly* `n` *times on the screen*.

**Example 1:**

```c++
Input: n = 3
Output: 3
Explanation: Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
```

**Example 2:**

```c++
Input: n = 1
Output: 0
```

**Constraints:**

- `1 <= n <= 1000`

```c++
spilt all operations((copy, paste, ..., paste)) into following?

    C is for copy, P is for paste: then [CPP][CPPPP][CP]

    ((((((base)p1)p2)p3)p4)...)pk = n;  (n = p1 * p2 * ... * pk)

    Why need to spilt pi, when pi is not a prime:
        if pi is composite pi = x * y; 
        if not spilt pi, x*y operations needed, 
        if     spilt pi, x+y operations needed.
        then we can get: x*y-x-y = (x-1)*(y-1) - 1:
        so if(x > 2 && y > 2), divide the composite into primes start from 2;

    when N is prime, can only copy paste once by once, so worst case TC is O(N):
    is N is not prime, ans will be sum of all parts after spilting.
    SC is O(1);
```

```c++
class Solution {
public:
    int minSteps(int n) {
        int ans = 0;
        int d = 2; 
        while (n > 1) {
            while (n % d == 0) {
                ans += d;
                n /= d;
            }
            d++;
        }
        return ans;
    }
};
```



#### [931. Minimum Falling Path Sum](https://leetcode-cn.com/problems/minimum-falling-path-sum/)

Given an `n x n` array of integers `matrix`, return *the **minimum sum** of any **falling path** through* `matrix`. A **falling path** starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position `(row, col)` will be `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.

 **Example 1:**

```c++
Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]
Output: 13
Explanation: There are two falling paths with a minimum sum underlined below:
[[2,1,3],      [[2,1,3],
 [6,5,4],       [6,5,4],
 [7,8,9]]       [7,8,9]]
```

**Constraints:**

- `n == matrix.length`
- `n == matrix[i].length`
- `1 <= n <= 100`
- `-100 <= matrix[i][j] <= 100`

```c++
	  bc only use level i+1 to get level i, so use Scrolling array:
    only need to change first dimension to 2, and change all first dimension to i&1;
    middle value can transfer from three direction, but on the boundary is different:
    dp[i][j]: sum that ends at (i,j);
    (1) j=0:  dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + A[i][j]; 
    (2) j=m-1:dp[i][j] = min(dp[i+1][j], dp[i+1][j-1]) + A[i][j]; 
    (3) j=1~m-2:dp[i][j] = min(dp[i+1][j-1], min(dp[i+1][j], dp[i+1][j+1])) + A[i][j];
    return the min_value in the first level;
```

```c++
// optimize to scrolling array:
// (1) change dp first dimension to 2;
// (2) change dp[i][j] to dp[i&1][j]; 
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& A) {
        if(A.empty() || A[0].empty()) return 0;
        int n = A.size(), m = A[0].size();
        if(n == 1) return *min_element(A[0].begin(), A[0].end());
        vector<vector<int>> dp(2, vector<int>(m,0));
        for(int i = n-1; i >= 0; i--){
            for(int j = 0; j < m; j++){
                if(j == 0){
                    dp[i&1][j] = min(dp[i+1&1][j], dp[i+1&1][j+1]) + A[i][j];
                }
                else if(j == m-1){
                    dp[i&1][j] = min(dp[i+1&1][j], dp[i+1&1][j-1]) + A[i][j];
                }
                else{
                    dp[i&1][j] = min(dp[i+1&1][j-1],min(dp[i+1&1][j], dp[i+1&1][j+1])) + A[i][j];
                }
            }
        }
        return *min_element(dp[0].begin(), dp[0].end());
    }
};
```

#### [1277. Count Square Submatrices with All Ones](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)

Given a `m * n` matrix of ones and zeros, return how many **square** submatrices have all ones.

**Example 1:**

```c++
Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation: 
There are 10 squares of side 1.
There are 4 squares of side 2.
There is  1 square of side 3.
Total number of squares = 10 + 4 + 1 = 15.
```

**Example 2:**

```c++
Input: matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
Output: 7
Explanation: 
There are 6 squares of side 1.  
There is 1 square of side 2. 
Total number of squares = 6 + 1 = 7.
```

**Constraints:**

- `1 <= arr.length <= 300`
- `1 <= arr[0].length <= 300`
- `0 <= arr[i][j] <= 1`

```c++
// f[i][j]: max suqares sides for with matrix[i][j] as bot-right
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> f(m, vector<int>(n));
        int ans = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == 0 || j == 0) {
                    f[i][j] = matrix[i][j];
                }
                else if (matrix[i][j] == 0) {
                    f[i][j] = 0;
                }
                else {
                    f[i][j] = min(min(f[i][j - 1], f[i - 1][j]), f[i - 1][j - 1])+1;
                }
                // with max side == x, there will be a x squares:
                // sides == 1,2,...x; so ans += x;
                ans += f[i][j];
            }
        }
        return ans;
    }
};
```







## (4) K strings:

#### [552. Student Attendance Record II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:

- `'A'`: Absent.
- `'L'`: Late.
- `'P'`: Present.

Any student is eligible for an attendance award if they meet **both** of the following criteria:

- The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.
- The student was **never** late (`'L'`) for 3 or more **consecutive** days.

Given an integer `n`, return *the **number** of possible attendance records of length* `n` *that make a student eligible for an attendance award. The answer may be very large, so return it **modulo*** `109 + 7`.

**Example 1:**

```c++
Input: n = 2
Output: 8
Explanation: There are 8 records with length 2 that are eligible for an award:
"PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL"
Only "AA" is not eligible because there are 2 absences (there need to be fewer than 2).
```

**Constraints:**

- `1 <= n <= 105`

```c++
// (1) method 1: dp:

// dp[i][j][k]: number of possible attendance records when
// first  i days, : [0, n];
// absent j days  : [0, 1];
// ends continuous k late days : [0, 2];
// (1) last day is 'P':  dp[i][j][0] = dp[i - 1][j][k];
// (2) last day is 'A':  dp[i][1][0] = dp[i - 1][0][k];
// (3) last day is 'L':  dp[i][j][k] = dp[i - 1][j][k - 1];
class Solution {
public:
    static constexpr int MOD = 1'000'000'007;
    int dp[100001][2][3]; // [day i][A num][L num] 
    int checkRecord(int n) {
        dp[0][0][0] = 1;
        for (int i = 1; i <= n; i++) {
            // (1) assume last day is 'P', 3rd dimension is 0:
            for (int j = 0; j <= 1; j++) {
                for (int k = 0; k <= 2; k++) {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;
                }
            }
            // (2) assume last day is 'A', no more 'A' in record: 
            // 2nd Dimension is 1 && 3rd Dimension is 0:
            for (int k = 0; k <= 2; k++) {
                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;
            }
            // (3) assume last day is 'L'
            for (int j = 0; j <= 1; j++) {
                for (int k = 1; k <= 2; k++) { // k from 1 to 2:
                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= 1; j++) {
            for (int k = 0; k <= 2; k++) {
                sum = (sum + dp[n][j][k]) % MOD;
            }
        }
        return sum;
    }
};
```



```c++
// method 2: dfs：
class Solution {
public:
    static constexpr int mod = 1e9+7;
    int mem[100001][2][3];
    int checkRecord(int n) {
        memset(mem, -1, sizeof(mem));
        return dfs(n, 0, 0);
    }
    // n : number of total days: 
    // aCnt : number of 'A':
    // lCnt : number of continuous 'L' in the end: 
    int dfs(int n, int aCnt, int lCnt) {
      // must check if aCnt and lCnt valid, then check if n == 0: bc some conditions with n==0, but aCnt and lCnt is not valid, then ans should be 0
        if (aCnt >= 2) return 0;
        if (lCnt >= 3) return 0;
        if (n == 0) return 1; 
        if (mem[n][aCnt][lCnt] != -1) {
            return mem[n][aCnt][lCnt];
        }
        int ans = 0;
        ans = (ans + dfs(n - 1, aCnt + 1, 0)) % mod; // cur letter A
        ans = (ans + dfs(n - 1, aCnt, lCnt + 1)) % mod; // cur letter L
        ans = (ans + dfs(n - 1, aCnt, 0)) % mod; // cur letter P
        mem[n][aCnt][lCnt] = ans;
        return ans;
    }
};
```



# 2. interval DP:

## (0) Intro of interval DP:

```c++
区间动态规划:

区间 DP 是状态的定义和转移都与区间有关，其中区间用两个端点表示。
状态定义 dp[i][j] = [i...j] 上原问题的解。i 变大，j 变小都可以得到更小规模的子问题。
对于单串上的问题，我们可以对比一下线性动态规划和区间动态规划。线性动态规划, 一般是定义 dp[i]， 
表示考虑到前 i 个元素，原问题的解，i 变小即得到更小规模的子问题，推导状态时候是从前往后，即 i 从小到大推的。
区间动态规划，一般是定义 dp[i][j]，表示考虑 [i...j] 范围内的元素，原问题的解增加 i，减小 j 
都可以得到更小规模的子问题。推导状态一般是按照区间长度从短到长推的。
区间动态规划的状态设计，状态转移都与线性动态规划有明显区别，但是由于这两种方法都经常用在单串问题上，
拿到一个单串的问题时，往往不能快速地判断到底是用线性动态规划还是区间动态规划，这也是区间动态规划的难点之一。

状态转移，推导状态 dp[i][j] 时，有两种常见情况:

1. dp[i][j] 仅与常数个更小规模子问题有关
一般是与 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 有关。
dp[i][j] = f(dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1])

代码常见写法:
for len = 1...n
    for i = i...len
        j = i + len - 1
        dp[i][j] = max(dp[i][j], f(dp[i+1][j], dp[i][j-1], dp[i+1][j-1]))

时间复杂度和空间复杂度均为 O(n^2), 例如 516 题

2. dp[i][j] 与 O(n) 个更小规模子问题有关
一般是枚举 [i,j] 的分割点，将区间分为 [i,k] 和 [k+1,j]，对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。

dp[i][j] = g(f(dp[i][k], dp[k + 1][j])) 其中 k = i ... j-1。

for len = 1...n
    for i = i...len
        j = i + len - 1
        for k = i...j
            dp[i][j] = max(dp[i][j], f(dp[i][k], dp[k][j]))

时间复杂度可以达到: O(n^3)，空间复杂度还是 O(n^2); 例如 664 题
```



## (1) palindrome:

## (2) n sub-problem:

## (3) word break:

