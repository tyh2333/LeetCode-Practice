[TOC]
Table of Contents
=================

* [Map or Set traversal](#map-or-set-traversal)
   * [1. One or Two times map,set:](#1-one-or-two-times-mapset)
         * [LeeCode 1743. restore the array from adjacent pairs](#leecode-1743-restore-the-array-from-adjacent-pairs)
         * [LeetCode 169: Majority Element:](#leetcode-169-majority-element)
         * [LeetCode 128: Longest Consecutive Sequence:](#leetcode-128-longest-consecutive-sequence)
         * [<a href="https://leetcode-cn.com/problems/majority-element-ii/" rel="nofollow">229. Majority Element II</a>](#229-majority-element-ii)
         * [LeetCode 246: Strobogrammatic Number](#leetcode-246-strobogrammatic-number)
         * [<a href="https://leetcode-cn.com/problems/palindrome-permutation/" rel="nofollow">266. Palindrome Permutation</a>](#266-palindrome-permutation)
         * [<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" rel="nofollow">349. Intersection of Two Arrays</a>(no dup in answer)](#349-intersection-of-two-arraysno-dup-in-answer)
         * [<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" rel="nofollow">350. Intersection of Two Arrays II</a>(allow dup in answer)](#350-intersection-of-two-arrays-iiallow-dup-in-answer)
         * [<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" rel="nofollow">387. First Unique Character in a String</a>](#387-first-unique-character-in-a-string)
         * [<a href="https://leetcode-cn.com/problems/find-the-difference/" rel="nofollow">389. Find the Difference</a>](#389-find-the-difference)
         * [<a href="https://leetcode-cn.com/problems/longest-palindrome/" rel="nofollow">409. Longest Palindrome</a>](#409-longest-palindrome)
         * [<a href="https://leetcode-cn.com/problems/number-of-boomerangs/" rel="nofollow">447. Number of Boomerangs</a>](#447-number-of-boomerangs)
         * [<a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/" rel="nofollow">599. Minimum Index Sum of Two Lists</a>](#599-minimum-index-sum-of-two-lists)
         * [<a href="https://leetcode-cn.com/problems/set-mismatch/" rel="nofollow">645. Set Mismatch</a>](#645-set-mismatch)
         * [<a href="https://leetcode-cn.com/problems/degree-of-an-array/" rel="nofollow">697. Degree of an Array</a>](#697-degree-of-an-array)
         * [<a href="https://leetcode-cn.com/problems/jewels-and-stones/" rel="nofollow">771. Jewels and Stones</a>](#771-jewels-and-stones)
         * [<a href="https://leetcode-cn.com/problems/number-of-matching-subsequences/" rel="nofollow">792. Number of Matching Subsequences</a>](#792-number-of-matching-subsequences)
         * [<a href="https://leetcode-cn.com/problems/unique-morse-code-words/" rel="nofollow">804. Unique Morse Code Words</a>](#804-unique-morse-code-words)
         * [<a href="https://leetcode-cn.com/problems/linked-list-components/" rel="nofollow">817. Linked List Components</a>](#817-linked-list-components)
         * [<a href="https://leetcode-cn.com/problems/unique-email-addresses/" rel="nofollow">929. Unique Email Addresses</a>](#929-unique-email-addresses)
         * [<a href="https://leetcode-cn.com/problems/unique-email-addresses/" rel="nofollow">929. Unique Email Addresses</a>](#929-unique-email-addresses-1)
         * [<a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/" rel="nofollow">954. Array of Doubled Pairs</a>](#954-array-of-doubled-pairs)
         * [<a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/" rel="nofollow">1525. Number of Good Ways to Split a String</a>](#1525-number-of-good-ways-to-split-a-string)
         * [<a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" rel="nofollow">30. Substring with Concatenation of All Words</a>](#30-substring-with-concatenation-of-all-words)
   * [2. Special Key-Value map or set:](#2-special-key-value-map-or-set)
         * [<a href="https://leetcode-cn.com/problems/group-anagrams/" rel="nofollow">49. Group Anagrams</a>](#49-group-anagrams)
         * [<a href="https://leetcode-cn.com/problems/group-shifted-strings/" rel="nofollow">249. Group Shifted Strings</a>](#249-group-shifted-strings)
         * [<a href="https://leetcode-cn.com/problems/unique-word-abbreviation/" rel="nofollow">288. Unique Word Abbreviation</a>](#288-unique-word-abbreviation)
         * [<a href="https://leetcode-cn.com/problems/snapshot-array/" rel="nofollow">1146. Snapshot Array</a>](#1146-snapshot-array)
         * [<a href="https://leetcode-cn.com/problems/rank-teams-by-votes/" rel="nofollow">1366. Rank Teams by Votes</a>](#1366-rank-teams-by-votes)
   * [3. Kth min or max (priority_queue)](#3-kth-min-or-max-priority_queue)
         * [<a href="https://leetcode-cn.com/problems/third-maximum-number/" rel="nofollow">414. Third Maximum Number</a>](#414-third-maximum-number)
   * [4. Design with Map](#4-design-with-map)
         * [<a href="https://leetcode-cn.com/problems/logger-rate-limiter/" rel="nofollow">359. Logger Rate Limiter</a>](#359-logger-rate-limiter)
         * [<a href="https://leetcode-cn.com/problems/design-hit-counter/" rel="nofollow">362. Design Hit Counter</a>](#362-design-hit-counter)
   * [5. Multiset:](#5-multiset)
         * [<a href="https://leetcode-cn.com/problems/the-skyline-problem/" rel="nofollow">218. The Skyline Problem</a>](#218-the-skyline-problem)
         * [<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" rel="nofollow">295. Find Median from Data Stream</a>](#295-find-median-from-data-stream)
* [Priority_queue: Top K](#priority_queue-top-k)
         * [<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" rel="nofollow">215. Kth Largest Element in an Array</a>](#215-kth-largest-element-in-an-array)
         * [<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" rel="nofollow">347. Top K Frequent Elements</a>](#347-top-k-frequent-elements)
         * [<a href="https://leetcode-cn.com/problems/top-k-frequent-words/" rel="nofollow">692. Top K Frequent Words</a>](#692-top-k-frequent-words)
         * [<a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/" rel="nofollow">1801. Number of Orders in the Backlog</a>](#1801-number-of-orders-in-the-backlog)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->


# Map or Set traversal

## 1. One or Two times map,set:

#### LeeCode 1743. restore the array from adjacent pairs

**Example 1:**

```c++
Input: adjacentPairs = [[2,1],[3,4],[3,2]]
Output: [1,2,3,4]
Explanation: This array has all its adjacent pairs in adjacentPairs.
Notice that adjacentPairs[i] may not be in left-to-right order.
```

```c++
class Solution {
public:
    vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
        unordered_map<int,vector<int>>  hash;
        int n = adjacentPairs.size();
        for(int i = 0;i < n;i ++){
            int a = adjacentPairs[i][0],b = adjacentPairs[i][1];
            hash[a].push_back(b);
            hash[b].push_back(a);
        }
        int start = 0;
        // find the start point
        for(auto [a,b] : hash){
            if(b.size() == 1){
                start = a;
                break;
            }
        }
        vector<int> res;
        res.push_back(start);
        for(int i = 1; i < n + 1; i++){
            int a = hash[res[i - 1]][0]; // next node
            // if next node is the last:
            if(hash[res[i - 1]].size() == 1) res.push_back(a);
            // else: one is the pre node, one is next node:
            else{
                 int b = hash[res[i - 1]][1];
                 int x = (a == res[i - 2]) ? b : a;
                 res.push_back(x);
            }
        }
        return res;
    }
};
```









#### LeetCode 169: Majority Element:

**(1) method 1 : map**

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> map;
        for (int i : nums) 
            if (++ map[i] > nums.size() / 2) return i;
        return 0;
    }
};
```

**(2) method 2 :  sort and return the middle element: **

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size()/2];
    }
};
```









#### LeetCode 128: Longest Consecutive Sequence:

**(1) method 1:**

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }
        int longestLen = 0;
        for (const int& num : num_set) {
            // if doesn't have last value, start count
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentLen = 1;
                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentLen += 1;
                }
                longestLen = max(longestLen, currentLen);
            }
        }
        return longestLen;           
    }
};
```



#### [229. Majority Element II](https://leetcode-cn.com/problems/majority-element-ii/)

Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times. 

**Example 1:**

```c++
Input: nums = [3,2,3]
Output: [3]
```

**Example 2:**

```c++
Input: nums = [1]
Output: [1]
```

**Example 3:**

```c++
Input: nums = [1,2]
Output: [1,2]
```

**Constraints:**

- `1 <= nums.length <= 5 * 104`
- `-109 <= nums[i] <= 109` 

**Follow up:** Could you solve the problem in linear time and in `O(1)` space?

```c++
// there are at most 1 elements that freq > 1/2;
// there are at most 2 elements that freq > 1/3;
// (1) TC: O(n), SC optimzation: O(1)
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        vector<int> ans(2, 0);
        int one = INT_MIN, two = INT_MIN;
        int n = (int) nums.size();
        unordered_map<int, int> mp;
        for(auto& x : nums){
            mp[x] ++;
            if(mp[x] > n/3){
                if(one == INT_MIN){
                    one = x;
                } else if(x != one){
                    two = x;
                    break;
                }
            }
        }
        if(one == INT_MIN && two == INT_MIN) return {};
        if(one == INT_MIN && two != INT_MIN) return {two};
        if(one != INT_MIN && two == INT_MIN) return {one};
        return {one, two};
    }
};
```



#### LeetCode 246: Strobogrammatic Number

Given a string `num` which represents an integer, return `true` *if* `num` *is a **strobogrammatic number***.

A **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down). 

**Example 1:**

```c++
Input: num = "69"
Output: true
```

**(1) map + two pointers: **

```c++
class Solution {
public:
    // match after rotate：0，1，8，6，9
    bool isStrobogrammatic(string num) {
        int n = num.size();
        if(num.empty()) return false;
        unordered_map<char,char> mp;
        mp['0'] = '0';
        mp['1'] = '1';
        mp['8'] = '8';
        mp['6'] = '9';
        mp['9'] = '6';
        int i = 0;
        int j = n-1;
        // must check when i==j
        // for single number, if they are : 0, 1, 8 will be true:
        while(i <= j){
        // for(int i = 0,j = n-1; i <= j; i++, j--){
            if(mp.count(num[i]) == 0 || mp[num[i]] != num[j])
                return false;
            i++;
            j--;
        }
        return true;
    }
};
```







#### [266. Palindrome Permutation](https://leetcode-cn.com/problems/palindrome-permutation/)

Given a string `s`, return `true` if a permutation of the string could form a palindrome.

 

**Example 1:**

```
Input: s = "code"
Output: false
```

```c++
class Solution {
public:
    bool canPermutePalindrome(string s){
        unordered_map<char, int> mp;
        for(auto c : s) mp[c]++;
        int count = 0;
        for(auto [k,v] : mp)
            if(v % 2 == 1) 
                count++;
        return count <= 1;
    }
};
```





#### [349. Intersection of Two Arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays/)(no dup in answer)

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2)
    {
        vector<int> ans;
        if(nums1.size() > nums2.size()) intersection(nums2, nums1); // always build set from smaller array
        set<int> s(nums1.begin(), nums1.end());
        for(auto &i : nums2){
            if(s.erase(i)){ // if can delete, add to the answer;
                // why not use s.count to check?
                // bc need to avoid duplicate values;
                // using count may add same value to the answer and hard to remove dup from an array;
                ans.push_back(i);
            }
        }
        return ans;
    }
};
```



#### [350. Intersection of Two Arrays II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)(allow dup in answer)

**Example 1:**

```c++
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
```

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res; 
        unordered_map<int,int> u;
        for(int i : nums1) u[i]++;
        for(int i : nums2)   
            if(--u[i] >= 0)    
                res.push_back(i);
       return res;
    }
};
```





#### [387. First Unique Character in a String](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

Given a string `s`, *find the first non-repeating character in it and return its index*. If it does not exist, return `-1`.

 **Example 1:**

```c++
Input: s = "leetcode"
Output: 0
```

```c++
class Solution {
public:
    int firstUniqChar(string s) {
        if(!s.size()) return -1;
        unordered_map<char, int> mp;
        for(auto c : s){
            mp[c]++;
        }
        for(int i = 0; i < s.size(); i++){
            if(mp[s[i]]==1)
                return i;
        }
        return -1;
    }
};
```



#### [389. Find the Difference](https://leetcode-cn.com/problems/find-the-difference/)

You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then add one more letter at a random position.

Return the letter that was added to `t`. 

**Example 1:**

```c++
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
```



```c++
class Solution {
public:
    // two times map
    char findTheDifference(string s, string t) {
        // s is origin, t is new string
        unordered_map<char, int> mp;
        for(auto x : s)
        {
            mp[x]++;
        }
        for(auto x : t)
        {
            mp[x]--;
            if(mp[x]==-1) 
                return x; // real return 
        }
        return 'a'; // fake return
    }
};
```



#### [409. Longest Palindrome](https://leetcode-cn.com/problems/longest-palindrome/)



Given a string `s` which consists of lowercase or uppercase letters, return *the length of the **longest palindrome*** that can be built with those letters.

Letters are **case sensitive**, for example, `"Aa"` is not considered a palindrome here.

 

**Example 1:**

```c++
Input: s = "abccccdd"
Output: 7
Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
```



```c++
class Solution {
public:
    // use map, record the frequency of each letter;
    // if the frequency more than 2, do (f/2) * 2
    int longestPalindrome(string s) {
        int ans = 0;
        unordered_map<char, int> mp;
        for(auto x : s) mp[x]++;
        for(auto x : mp)
            if(x.second >= 2)
                ans += (x.second/2)*2;
        // if ans < s.size(), means:
        //  there are another single element can be put in the middle
        if(ans < s.size()) ans+=1;
        return ans;
    }
};
```

#### [447. Number of Boomerangs](https://leetcode-cn.com/problems/number-of-boomerangs/)

You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.

Return *the number of boomerangs*.

**Example 1:**

```
Input: points = [[0,0],[1,0],[2,0]]
Output: 2
Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].
```

**Constraints:**

- `n == points.length`
- `1 <= n <= 500`
- `points[i].length == 2`
- `-104 <= xi, yi <= 104`
- All the points are **unique**.

```c++
class Solution {
public:
    int numberOfBoomerangs(vector<vector<int>>& points) {
        unordered_map<int, int> mp;
        int ans = 0;
        for(int i = 0; i < points.size(); i++){
            for(int j = 0; j < points.size(); j++){
                auto a = points[i];
                auto b = points[j];
                int dis = (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);
                mp[dis]++;
            }
            for(const auto& [k, v] : mp){
                ans += v*(v-1);
            }
            mp.clear();
        }
        return ans;
    }
};
```



#### [599. Minimum Index Sum of Two Lists](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)

Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.

You need to help them find out their **common interest** with the **least list index sum**. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.



**Example 1:**

```c++
Input: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["Piatti","The Grill at Torrey Pines","Hungry Hunter Steakhouse","Shogun"]
Output: ["Shogun"]
Explanation: The only restaurant they both like is "Shogun".
```

**(1) three times map traversal : **

```c++
(1) first find common:
(2) then find the min index:
(3) then add all the index same as min to ans:
```

```c++
class Solution {
public:
    // must there common interest
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        unordered_map<string, int> mp1, common;
        for(int i = 0; i < list1.size(); i++) mp1[list1[i]] += i;
        // build common map
        for(int i = 0; i < list2.size(); i++){
            if(mp1.count(list2[i]) > 0){ // means common elements
                common[list2[i]] = i + mp1[list2[i]];
            }
        } 
        vector<string> ans; // it could have multiple answers
        int max_sum = INT_MAX;
        for(auto& [k, v] : common) max_sum = min(v, max_sum);
        for(auto& [k, v] : common) if(v == max_sum) ans.push_back(k);
        return ans;
    }
};
```



#### [645. Set Mismatch](https://leetcode-cn.com/problems/set-mismatch/)

You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.

You are given an integer array `nums` representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return *them in the form of an array*.

**Example 1:**

```c++
Input: nums = [1,2,2,4]
Output: [2,3]
```



```c++
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        vector<int> ans(2, 0);
        unordered_map<int, int> mp;
        for(int i = 1; i <= nums.size(); i++){
            mp[i] = 0;
        }
        for(auto x : nums){
            mp[x]++;
        }
        for(auto [k,v] : mp){
            if(v == 0) ans[1]=k;
            else if(v == 2) ans[0]=k;
        }
        return ans;
    }
};
```





#### [697. Degree of an Array](https://leetcode-cn.com/problems/degree-of-an-array/)

Given a non-empty array of non-negative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`.

**Example 1:**

```c++
Input: nums = [1,2,2,3,1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
```

```c++
class Solution {
public:
    // find the max freq: then use get_wide to get smallest length:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, int> mp;
        int max_freq = 1;
        vector<int> most_num;
        for(auto x : nums){
            mp[x]++;
            if(mp[x] > max_freq){
                most_num.clear();
                most_num.push_back(x);
                max_freq = mp[x];
            }
            else if(mp[x] == max_freq) 
                most_num.push_back(x);
        }
        int ans = INT_MAX;
        for(auto x : most_num) 
            ans = min(ans, get_wide(nums, x));
        return ans;
    }
    int get_wide(const vector<int> nums, int target){
        int n = nums.size();
        int start = 0, end = n -1;
        for(int i = 0; i < n; i++){
            if(nums[i] == target){
                start = i; 
                break;
            }
        }
        for(int i = n-1; i >= 0; i--){
            if(nums[i] == target){
                end = i; 
                break;
            }
        }
        return end-start+1;
    }
};
```



#### [771. Jewels and Stones](https://leetcode-cn.com/problems/jewels-and-stones/)

You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so `"a"` is considered a different type of stone from `"A"`.

**Example 1:**

```c++
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
```



```c++
class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        //set to store all jewels, no dup, so use set
        unordered_set<char> jew;
        for(auto c : jewels) jew.insert(c);
        int ans = 0;
        for(auto c : stones){
            if(jew.count(c) == 1) 
                ans++;
        }
        return ans;
    }
};
```



#### [792. Number of Matching Subsequences](https://leetcode-cn.com/problems/number-of-matching-subsequences/)

Given a string `s` and an array of strings `words`, return *the number of* `words[i]` *that is a subsequence of* `s`.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

- For example, `"ace"` is a subsequence of `"abcde"`.

**Example 1:**

```c++
Input: s = "abcde", words = ["a","bb","acd","ace"]
Output: 3
Explanation: There are three strings in words that are a subsequence of s: "a", "acd", "ace".
```

**Example 2:**

```c++
Input: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
Output: 2
```

 

**Constraints:**

- `1 <= s.length <= 5 * 104`
- `1 <= words.length <= 5000`
- `1 <= words[i].length <= 50`
- `s` and `words[i]` consist of only lowercase English letters.

```c++
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        map<char, vector<int>> hash; // <value, index>
        for (int i = 0; i < s.size(); ++i) {
            hash[s[i]].push_back(i);
        }
        int ans = 0;
        for (auto& ww : words) {
            int cur = -1;
            bool flag = true;
            for (char& c : ww) {
                if (hash.find(c) == hash.end()) {
                    flag = false; break;
                }
                auto lb = lower_bound(hash[c].begin(), hash[c].end(), cur);
                if (lb == hash[c].end()) {
                    flag = false; break;
                } else {
                    if (*lb >= cur) {
                        cur = *lb + 1;
                    } else {
                        flag = false; break;
                    }
                }
            }
            if (flag) ans++;
        }
        return ans;
    }
};
```



#### [804. Unique Morse Code Words](https://leetcode-cn.com/problems/unique-morse-code-words/)

International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:

- `'a'` maps to `".-"`,
- `'b'` maps to `"-..."`,
- `'c'` maps to `"-.-."`, and so on.

For convenience, the full table for the `26` letters of the English alphabet is given below:

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

Given an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter.

- For example, `"cab"` can be written as `"-.-..--..."`, which is the concatenation of `"-.-."`, `".-"`, and `"-..."`. We will call such a concatenation the **transformation** of a word.

Return *the number of different **transformations** among all words we have*.

**Example 1:**

```c++
Input: words = ["gin","zen","gig","msg"]
Output: 2
Explanation: The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."
There are 2 different transformations: "--...-." and "--...--.".
```

```c++
class Solution {
public:
    string return_mose(char c){
        vector<string> mose
        {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---",
        "-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-",
        "...-",".--","-..-","-.--","--.."};
        return mose[c-'a'];
    }
    int uniqueMorseRepresentations(vector<string>& words) {
        if(!words.size()) return 0;
        unordered_map<string,int> mp;
        for(auto x : words){
            string tmp = "";
            for(auto y : x) tmp += return_mose(y);
            mp[tmp]++;
        }
        return mp.size();
    }
};
```



#### [817. Linked List Components](https://leetcode-cn.com/problems/linked-list-components/)

You are given the `head` of a linked list containing unique integer values and an integer array `nums` that is a subset of the linked list values.

Return *the number of connected components in* `nums` *where two values are connected if they appear **consecutively** in the linked list*. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg)

```c++
Input: head = [0,1,2,3], nums = [0,1,3]
Output: 2
Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.
```

**Constraints:**

- The number of nodes in the linked list is `n`.
- `1 <= n <= 104`
- `0 <= Node.val < n`
- All the values `Node.val` are **unique**.
- `1 <= nums.length <= n`
- `0 <= nums[i] <= n`
- All the values of `nums` are **unique**.

```c++
class Solution {
public:
    int numComponents(ListNode* head, vector<int>& G) {
        unordered_set<int> set(G.begin(), G.end());
        int ans = 0;
        while(head){
            // only check when set has cur value:
            // (1) cur must in set:
            if(set.count(head->val))    
                // (1) need ans++: cur is the last value:
                // (2）head->next not in set:
                if(!head->next || !set.count(head->next->val))
                    ans++; 

            head = head->next;
        }
        return ans;
    }
};
```



#### [929. Unique Email Addresses](https://leetcode-cn.com/problems/unique-email-addresses/)

Every **valid email** consists of a **local name** and a **domain name**, separated by the `'@'` sign. Besides lowercase letters, the email may contain one or more `'.'` or `'+'`.

- For example, in `"alice@leetcode.com"`, `"alice"` is the **local name**, and `"leetcode.com"` is the **domain name**.

If you add periods `'.'` between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule **does not apply** to **domain names**.

- For example, `"alice.z@leetcode.com"` and `"alicez@leetcode.com"` forward to the same email address.

If you add a plus `'+'` in the **local name**, everything after the first plus sign **will be ignored**. This allows certain emails to be filtered. Note that this rule **does not apply** to **domain names**.

- For example, `"m.y+name@email.com"` will be forwarded to `"my@email.com"`.

It is possible to use both of these rules at the same time.

Given an array of strings `emails` where we send one email to each `email[i]`, return *the number of different addresses that actually receive mails*.

**Example 1:**

```c++
Input: emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
Output: 2
Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails.
```

```c++
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        unordered_set<string> hash; // 去重
        for(auto email : emails){
            // 找到'@' 分割前后两个字符串
            // 因为前面的字符串是和用 '.' 连接
            // 后面的字符串是和用 '+' 连接
            int at = email.find('@');
            string name;
            for(auto c : email.substr(0, at)){
                if(c == '+') break;
                else if(c != '.') name += c;
            }
            string domain = email.substr(at + 1);
            hash.insert(name + '@' + domain);
        }
        return hash.size();
    }
};
```



#### [929. Unique Email Addresses](https://leetcode-cn.com/problems/unique-email-addresses/)

Every **valid email** consists of a **local name** and a **domain name**, separated by the `'@'` sign. Besides lowercase letters, the email may contain one or more `'.'` or `'+'`.

- For example, in `"alice@leetcode.com"`, `"alice"` is the **local name**, and `"leetcode.com"` is the **domain name**.

If you add periods `'.'` between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule **does not apply** to **domain names**.

- For example, `"alice.z@leetcode.com"` and `"alicez@leetcode.com"` forward to the same email address.

If you add a plus `'+'` in the **local name**, everything after the first plus sign **will be ignored**. This allows certain emails to be filtered. Note that this rule **does not apply** to **domain names**.

- For example, `"m.y+name@email.com"` will be forwarded to `"my@email.com"`.

It is possible to use both of these rules at the same time.

Given an array of strings `emails` where we send one email to each `email[i]`, return *the number of different addresses that actually receive mails*. 

**Example 1:**

```c++
Input: emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
Output: 2
Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails.
```

```c++
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        unordered_set<string> hash;  
        for(auto email : emails){
            // find '@' to spilt into local_name and domain_name
            // bc local_name can insert '.' and ignore the letters after '+':
            int idx = email.find('@');
            string local = "";
            for(auto c : email.substr(0, idx)){
                if(c == '+') break;
                else if(c != '.') local += c;
            }
            string domain = email.substr(idx + 1);
            hash.insert(local + '@' + domain);
        }
        return hash.size();
    }
};
```



#### [954. Array of Doubled Pairs](https://leetcode-cn.com/problems/array-of-doubled-pairs/)

Given an integer array of even length `arr`, return `true` *if it is possible to reorder* `arr` *such that* `arr[2 * i + 1] = 2 * arr[2 * i]` *for every* `0 <= i < len(arr) / 2`*, or* `false`*otherwise*.

**Example 1:**

```c++
Input: arr = [3,1,3,6]
Output: false
```

**Example 2:**

```c++
Input: arr = [2,1,2,6]
Output: false
```

**Constraints:**

- `2 <= arr.length <= 3 * 104`
- `arr.length` is even.
- `-10^5 <= arr[i] <= 10^5`

```c++
class Solution {
public:
    bool canReorderDoubled(vector<int>& A) {
        map<double, int> m;
        for (auto& num : A) {
            m[num]++;
        }
        for (auto& [val, freq] : m) {
            if (freq < 0) return false;
            if (freq == 0) continue;
            if (val > 0) {
                if (m.find(val * 2) == m.end()) return false;
                m[val * 2] -= freq;
            } else {
                if (m.find(val / 2.0) == m.end()) return false;
                m[val / 2.0] -= freq;
            }
        }
        return true;
    }
};
```

#### [1525. Number of Good Ways to Split a String](https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/)

You are given a string `s`, a split is called *good* if you can split `s`into 2 non-empty strings `p` and `q` where its concatenation is equal to `s` and the number of distinct letters in `p` and `q` are the same.

Return the number of *good* splits you can make in `s`. 

**Example 1:**

```c++
Input: s = "aacaba"
Output: 2
Explanation: There are 5 ways to split "aacaba" and 2 of them are good. 
("a", "acaba") Left string and right string contains 1 and 3 different letters respectively.
("aa", "caba") Left string and right string contains 1 and 3 different letters respectively.
("aac", "aba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aaca", "ba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aacab", "a") Left string and right string contains 3 and 1 different letters respectively.
```

**Example 2:**

```c++
Input: s = "abcd"
Output: 1
Explanation: Split the string as follows ("ab", "cd").
```

**Constraints:**

- `s` contains only lowercase English letters.
- `1 <= s.length <= 10^5`

```c++
class Solution {
public:
    // two times map:
    int numSplits(string s) {
        unordered_map<char, int> left; // the number of kinds including cur element
        unordered_map<char, int> right; // the number of kinds including cur element
        int len = s.length();
        int ans = 0;
        for(int i = 0; i < len; i++){
            right[s[i]]++;
        }
        for(int i = 0; i < len; i++){
            left[s[i]]++;
            right[s[i]]--;
            if(right[s[i]] == 0){
                right.erase(s[i]);
            }
            if(left.size() == right.size()) ans++;
        }
        return ans;
    }
};
```



#### [30. Substring with Concatenation of All Words](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

You are given a string `s` and an array of strings `words` of **the same length**. Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` **exactly once**, **in any order**, and **without any intervening characters**.

You can return the answer in **any order**. 

**Example 1:**

```c++
Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoo" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.
```



```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (s.empty() || words.empty()) return {};
        int n = words.size(), m = words[0].size(), j = 0;
        if (s.size() < m * n) return {}; // means can not build
        vector<int> res;
        unordered_map<string, int> dict;
        unordered_map<string, int> tmp; 
        for (auto str : words){
            dict[str]++;
        }
        // optimize i+m*n <= s.size();
        for (int i = 0; i + m * n <= s.size(); ++i) {
            string ss = "";
            for (j = i; j < i + m * n; j += m) {
                ss = s.substr(j, m); // get a word with len=m
                if(dict.count(ss) == 0) break;
                tmp[ss]++;
            }
            if (j == i + m * n && tmp == dict) res.push_back(i);
            tmp.clear();
        }
        return res;
    }
};
```













## 2. Special Key-Value map or set:

#### [49. Group Anagrams](https://leetcode-cn.com/problems/group-anagrams/)

Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```



```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> ans;
        unordered_map<string, vector<string>> mp;
        for(auto x : strs){
            // x is one of the string
            string tmp = x; // save old value
            sort(x.begin(), x.end());
            mp[x].push_back(tmp);
        }
        for(auto x : mp){
            ans.push_back(x.second);
        }
        return ans;
    }
};
```



#### [249. Group Shifted Strings](https://leetcode-cn.com/problems/group-shifted-strings/)

We can shift a string by shifting each of its letters to its successive letter.

- For example, `"abc"` can be shifted to be `"bcd"`.

We can keep shifting the string to form a sequence.

- For example, we can keep shifting `"abc"` to form the sequence: `"abc" -> "bcd" -> ... -> "xyz"`.

Given an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. You may return the answer in **any order**. 

**Example 1:**

```c++
Input: strings = ["abc","bcd","acef","xyz","az","ba","a","z"]
Output: [["acef"],["a","z"],["abc","bcd","xyz"],["az","ba"]]
```

```c++
class Solution {
public:
    vector<vector<string>> groupStrings(vector<string>& strings) {
        vector<vector<string>> ans;
        // key is the shift array: the diff from last element:
        map<vector<int>, vector<string>> mp;
        for(auto str : strings){
            vector<int> tmp;
            for(int i = 0; i < str.size()-1; i++){
                tmp.push_back((str[i+1]-str[i]+26)%26);
            }
            mp[tmp].push_back(str);
        }
        for(auto &m : mp){
            ans.push_back(m.second);
        }
        return ans;
    }
};
```



#### [288. Unique Word Abbreviation](https://leetcode-cn.com/problems/unique-word-abbreviation/)

The **abbreviation** of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an **abbreviation** of itself.

For example:

- `dog --> d1g` because there is one letter between the first letter `'d'` and the last letter `'g'`.
- `internationalization --> i18n` because there are 18 letters between the first letter `'i'` and the last letter `'n'`.
- `it --> it` because any word with only two characters is an **abbreviation** of itself.

Implement the `ValidWordAbbr` class:

- `ValidWordAbbr(String[] dictionary)` Initializes the object with a `dictionary` of words.

- ```c++
  boolean isUnique(string word) Return true if either if the following conditions are met (otherwise returns false);
  ```

  - There is no word in `dictionary` whose **abbreviation** is equal to `word`'s **abbreviation**.
  - For any word in `dictionary` whose **abbreviation** is equal to `word`'s **abbreviation**, that word and `word` are **the same**.

 

**Example 1:**

```c++
Input
["ValidWordAbbr", "isUnique", "isUnique", "isUnique", "isUnique", "isUnique"]
[[["deer", "door", "cake", "card"]], ["dear"], ["cart"], ["cane"], ["make"], ["cake"]]
Output
[null, false, true, false, true, true]

Explanation
ValidWordAbbr validWordAbbr = new ValidWordAbbr(["deer", "door", "cake", "card"]);
validWordAbbr.isUnique("dear"); // return false, dictionary word "deer" and word "dear" have the same abbreviation "d2r" but are not the same.
validWordAbbr.isUnique("cart"); // return true, no words in the dictionary have the abbreviation "c2t".
validWordAbbr.isUnique("cane"); // return false, dictionary word "cake" and word "cane" have the same abbreviation  "c2e" but are not the same.
validWordAbbr.isUnique("make"); // return true, no words in the dictionary have the abbreviation "m2e".
validWordAbbr.isUnique("cake"); // return true, because "cake" is already in the dictionary and no other word in the dictionary has "c2e" abbreviation.
```

 

**Constraints:**

- `1 <= dictionary.length <= 3 * 104`
- `1 <= dictionary[i].length <= 20`
- `dictionary[i]` consists of lowercase English letters.
- `1 <= word.length <= 20`
- `word` consists of lowercase English letters.
- At most `5000` calls will be made to `isUnique`.

```c++
/**
 * Your ValidWordAbbr object will be instantiated and called as such:
 * ValidWordAbbr* obj = new ValidWordAbbr(dictionary);
 * bool param_1 = obj->isUnique(word);
 */
class ValidWordAbbr {
public:
    // unordered_map <abbre for string, origin string>:
    unordered_map<string, unordered_set<string>> mp;
    ValidWordAbbr(vector<string>& dictionary) {
        for (const auto& word : dictionary) {
            if (word.size() == 1 || word.size() == 2) {
                mp[word] = {word}; // if word_len < 2: 
                continue;
            }
            auto abbre =word.front() + to_string(word.size() - 2) + word.back();
            mp[abbre].insert(word);
        }
    }
    bool isUnique(string word) {
        auto key = word;
        if(word.size() > 2) {
            key = word.front() + to_string(word.size() - 2) + word.back();
        }
        // here key is the abbreviation of word
        // (1) condition 1: there is no such abbreviation in dic, return ture;
        if (!mp.count(key)) return true; // it's unique
        // (2) condition 2: only one word for the abbreviation and same as word
        return mp[key].size() == 1 && (*mp[key].begin() == word);
    }
};


```



#### [1146. Snapshot Array](https://leetcode-cn.com/problems/snapshot-array/)

Implement a SnapshotArray that supports the following interface:

- `SnapshotArray(int length)` initializes an array-like data structure with the given length. **Initially, each element equals 0**.
- `void set(index, val)` sets the element at the given `index` to be equal to `val`.
- `int snap()` takes a snapshot of the array and returns the `snap_id`: the total number of times we called `snap()`minus `1`.
- `int get(index, snap_id)` returns the value at the given `index`, at the time we took the snapshot with the given `snap_id` 

**Example 1:**

```c++
Input: ["SnapshotArray","set","snap","set","get"]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation: 
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5
```

 **Constraints:**

- `1 <= length <= 50000`
- At most `50000` calls will be made to `set`, `snap`, and `get`.
- `0 <= index < length`
- `0 <= snap_id < `(the total number of times we call `snap()`)
- `0 <= val <= 10^9`

```c++
class SnapshotArray {
public:
    int snapId;
    // use map for every value to save snapshot 
    // vector's index is index for every value;
    // map<snapId, val>;
    // or use vector<vector<int, int>> nums, then use binary search;
    vector<map<int, int>> nums; 

    SnapshotArray(int length) { // O(length)
        snapId = 0;
        map<int, int> mp;
        mp[0] = 0;
        for (int i = 0; i < length; i++) {
            nums.push_back(mp); // version 0
        }
    }
    
    void set(int index, int val) { // O(log N)
        nums[index][snapId] = val;
    }
    
    int snap() { // O(1)
        return snapId++;
    }
    
    int get(int index, int snap_id) { // O(log N)
        // Note: get the map for cur index:
        // we may change one value many times before take snapshot
        // and all operations before snapshot() share same snapId
        // so we need find the upper_bound then -- to get the last change:
        auto iter = nums[index].upper_bound(snap_id); 
        iter--; // floor key
        return iter->second;
    }
};
```



#### [1366. Rank Teams by Votes](https://leetcode-cn.com/problems/rank-teams-by-votes/)

In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.

The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

Given an array of strings `votes` which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return *a string of all teams* **sorted** by the ranking system.

**Example 1:**

```c++
Input: votes = ["ABC","ACB","ABC","ACB","ACB"]
Output: "ACB"
Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.
Team B was ranked second by 2 voters and was ranked third by 3 voters.
Team C was ranked second by 3 voters and was ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team and team B is the third.
```

**Example 2:**

```c++
Input: votes = ["WXYZ","XYZW"]
Output: "XWYZ"
Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position. 
```

**Example 3:**

```c++
Input: votes = ["ZMNAGUEDSJYLBOPHRQICWFXTVK"]
Output: "ZMNAGUEDSJYLBOPHRQICWFXTVK"
Explanation: Only one voter so his votes are used for the ranking.
```

**Example 4:**

```c++
Input: votes = ["BCA","CAB","CBA","ABC","ACB","BAC"]
Output: "ABC"
Explanation: 
Team A was ranked first by 2 voters, second by 2 voters and third by 2 voters.
Team B was ranked first by 2 voters, second by 2 voters and third by 2 voters.
Team C was ranked first by 2 voters, second by 2 voters and third by 2 voters.
There is a tie and we rank teams ascending by their IDs.
```

**Example 5:**

```c++
Input: votes = ["M","M","M","M"]
Output: "M"
Explanation: Only team M in the competition so it has the first rank.
```

 **Constraints:**

- `1 <= votes.length <= 1000`
- `1 <= votes[i].length <= 26`
- `votes[i].length == votes[j].length` for `0 <= i, j < votes.length`.
- `votes[i][j]` is an English **upper-case** letter.
- All characters of `votes[i]` are unique.
- All the characters that occur in `votes[0]` **also occur** in `votes[j]` where `1 <= j < votes.length`.

```c++
class Solution {
public:
    string rankTeams(vector<string>& votes) {
        map<char,vector<int>> mp;
        for(auto v:votes){
            for(int i = 0; i < v.size();i++){
                mp[v[i]].resize(26);
                mp[v[i]][i]++;
            }      
        }
        string ans = votes[0];
        sort(ans.begin(),ans.end(),[&](char a, char b){
            return mp[a] > mp[b] || mp[a] == mp[b] && a < b;
        });
        return ans; 
    }
};
```







---

## 3. Kth min or max (priority_queue)

#### [414. Third Maximum Number](https://leetcode-cn.com/problems/third-maximum-number/)

Given integer array `nums`, return *the third maximum number in this array*. If the third maximum does not exist, return the maximum number. 

**Example 1:**

```c++
Input: nums = [3,2,1]
Output: 1
Explanation: The third maximum is 1.
```

**When we see k max, k min : we can use heap:priority_queue**

**but this method is not good when we need to conside dup elements,like in this problem;**

```c++
For example, 1 2 2 3, the third max number is 1, not 2, but if we build a heap, it will be 2 2 3 left , top=2; **
```

```c++
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        long MIN_VALUE = LONG_MIN;
        // init first second third biggest value:
        long firstElement  = MIN_VALUE;
        long secondElement = MIN_VALUE;
        long thirdElement  = MIN_VALUE;
        for(int num : nums) {
            if(num > firstElement) {
                thirdElement = secondElement;
                secondElement = firstElement;
                firstElement = num;
            }else if(secondElement < num && num < firstElement) {
                thirdElement = secondElement;
                secondElement = num;
            }else if (thirdElement < num && num < secondElement) {
                thirdElement = num;
            }
        }
        // if no third biggest value, return the biggest value:
        return (thirdElement== MIN_VALUE) ? (int)firstElement : (int)thirdElement;
    }
};
```



## 4. Design with Map

#### [359. Logger Rate Limiter](https://leetcode-cn.com/problems/logger-rate-limiter/)

```c++
class Logger {
public:
    unordered_map<string, int> m;
    Logger() {

    }
    // Each message corresponds to a timestamp
    bool shouldPrintMessage(int timestamp, string message) {
        for(auto it = m.begin(); it != m.end(); it++){
            if(it->second - timestamp > 10){
                m.erase(it);
            }
        }
        if(m.count(message) == 0 || timestamp - m[message] >= 10){
            m[message] = timestamp;
            return true;
        }
        return false;
    }
};
```



#### [362. Design Hit Counter](https://leetcode-cn.com/problems/design-hit-counter/)

```c++
class HitCounter {
public:
    unordered_map<int, int> mp;
    /** Initialize your data structure here. */
    HitCounter() {}
    
    /** Record a hit.
        @param timestamp - The current timestamp (in seconds granularity). */
    void hit(int timestamp) { //O(1)
        mp[timestamp]++;
    }
    
    /** Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity). */
    int getHits(int timestamp) {
        int ans = 0;
        // at most 300 hundreads times for traverse map 
        for (auto it = mp.begin(); it != mp.end(); ) {
            if(it != mp.end() && timestamp - it->first < 300) {
                ans += it->second;
                ++it;
            } else {
                it = mp.erase(it);
            }
        }
        return ans;
    }
};

/**
 * Your HitCounter object will be instantiated and called as such:
 * HitCounter* obj = new HitCounter();
 * obj->hit(timestamp);
 * int param_2 = obj->getHits(timestamp);
 */
```





## 5. Multiset:

#### [218. The Skyline Problem](https://leetcode-cn.com/problems/the-skyline-problem/)

A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return *the **skyline** formed by these buildings collectively*.

The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:

- `lefti` is the x coordinate of the left edge of the `ith` building.
- `righti` is the x coordinate of the right edge of the `ith` building.
- `heighti` is the height of the `ith` building.

You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.

The **skyline** should be represented as a list of "key points" **sorted by their x-coordinate** in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.

**Note:** There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]` 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/01/merged.jpg)

```c++
Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
Explanation:
Figure A shows the buildings of the input.
Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.
```

**Example 2:**

```c++
Input: buildings = [[0,2,3],[2,5,3]]
Output: [[0,3],[5,0]]
```

 **Constraints:**

- `1 <= buildings.length <= 104`
- `0 <= lefti < righti <= 231 - 1`
- `1 <= heighti <= 231 - 1`
- `buildings` is sorted by `lefti` in non-decreasing order.

```c++
// (1) method 1: Sweeping line algorithm O(nlogn);
//     使用到了数据结构： multiset<int> ms; balanced BST
//     时间复杂度：O(nlogn);
//     空间复杂度：O(n);
// 思路:
//     events = {
//         {x : L, height: H, type : entering},
//         {x : R, height: H, type : leaving }}
//     events.SortByX()
//     ds = new DS(); // data structure
//     for e in events:
//         if entering(e):
//             if e.height > ds.max() : ans += [e.height]
//             ds.add(e.height)
//         if leaving(e) :
//             ds.remove(e.height)
//             if e.height > ds.max() : ans += [ds.max()]
//     DS Candidate:
//         Heap: max O(1),  add O(logn), remove_by_key ??? O(n)/O(logn);
//         balanced binary search tree : max, add, remove O(logn);

class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        typedef pair<int, int> Event; // events,  x,   h
        vector<Event> es;        
        hs_.clear();
        for (const auto& b : buildings) {
            es.emplace_back(b[0], b[2]);
            es.emplace_back(b[1], -b[2]);
        }
        // Sort events by x
        sort(es.begin(), es.end(), [](const Event& e1, const Event& e2){
            if (e1.first == e2.first) return e1.second > e2.second;
            return e1.first < e2.first;
        });
        vector<vector<int>> ans;
        // Process all the events
        for (const auto& e: es) {            
            int x = e.first;
            bool entering = e.second > 0;
            int h = abs(e.second);
            if (entering) {                
                if (h > this->maxHeight())
                    ans.push_back({x, h});
                hs_.insert(h);
            } else {
                hs_.erase(hs_.equal_range(h).first);
                if (h > this->maxHeight())
                    ans.push_back({x, this->maxHeight()});
            }            
        }
        return ans;
    }
private:
    int maxHeight() const {
        if (hs_.empty()) return 0;
        return *hs_.rbegin();
    }
    multiset<int> hs_;
};
```



#### [295. Find Median from Data Stream](https://leetcode-cn.com/problems/find-median-from-data-stream/)

The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.

- For example, for `arr = [2,3,4]`, the median is `3`.
- For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.

Implement the MedianFinder class:

- `MedianFinder()` initializes the `MedianFinder` object.
- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.
- `double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.

**Example 1:**

```c++
Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0 
```

**Constraints:**

- `-105 <= num <= 105`
- There will be at least one element in the data structure before calling `findMedian`.
- At most `5 * 104` calls will be made to `addNum` and `findMedian`.

```c++
// (1) method 1 : 大顶堆 + 小顶堆 + 平衡
// 如果我们可以用以下方式维护两个堆：
// 用于存储输入数字中较小一半的最大堆
// 用于存储输入数字的较大一半的最小堆
class MedianFinder {
    priority_queue<int> lo;                              // max heap
    priority_queue<int, vector<int>, greater<int>> hi;   // min heap
public:
    // Adds a number into the data structure.
    // 要保持两个堆的平衡，因为一开始是平衡的，
    // 所以每次向大根堆添加元素，然后把大根堆的新堆顶转移给小根堆
    // 这样大根堆每次添加一个元素，又减少了一个元素，相当于元素数量没变化
    // 而小跟堆是每次加1个，如果小跟堆数量比大根堆多了，就移回来一个
    void addNum(int num)
    {
        lo.push(num);                                    // Add to max heap
        auto node = lo.top(); lo.pop();
        hi.push(node);                                   // balancing step
        if (lo.size() < hi.size()) {                     // maintain size property
            lo.push(hi.top());
            hi.pop();
        }
    }

    // Returns the median of current data stream
    double findMedian()
    {
        // 因为我们一直是保持大根堆的元素数量 >= 小跟堆的元素数量
        // （1）如果大根堆元素多，那么大根堆堆顶元素就是结果
        // （2）两个堆元素数量一样，那么两个堆顶元素之和 * 0.5;
        return lo.size() > hi.size() ? (double) lo.top() : (lo.top() + hi.top()) * 0.5;
    }
};
```

```c++

// (2) method 2: multiset（BST）, 直接用multiset的 iterator, ++,--操作；
class MedianFinder {
    multiset<int> data;
    multiset<int>::iterator lo_median, hi_median;
public:
    MedianFinder(){}

    void addNum(int num)
    {
        const size_t n = data.size();   // store previous size

        data.insert(num);               // insert into multiset

        if (!n) {
            // no elements before, one element now
            lo_median = hi_median = data.begin();
        }
        else if (n & 1) { // n is old size:
            // odd size before (i.e. lo == hi), even size now (i.e. hi = lo + 1)

            if (num < *lo_median)       // num < lo
                lo_median--;
            else                        // num >= hi
                hi_median++;            // insertion at end of equal range
        }
        else {
            // 如果n是偶数，那么low和high插入之前不是同一个数，那么三个区间可以插入：
            // 小于low, 大于low,小于high , 大于high:
            // even size before (i.e. hi = lo + 1), odd size now (i.e. lo == hi)
            if (num > *lo_median && num < *hi_median) {
                // 两个指针向中间靠拢，指向num这个新插入的数
                lo_median++;                    // num in between lo and hi
                hi_median--;
            }
            else if (num >= *hi_median)         // num inserted after hi
                lo_median++;                    // 把low 指向 high
            else                                // num <= lo < hi
                lo_median = --hi_median;        //把high指向low
        }
    }
    double findMedian()
    {
        return (*lo_median + *hi_median) * 0.5;
    }
};
```







# Priority_queue: Top K

```c++
priority_queue <int, vector<int>, greater<int>> minHeap;
priority_queue <int, vector<int>, less <int>>   maxHeap; default is maxHeap;
```

#### [215. Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

Given an integer array `nums` and an integer `k`, return *the* `kth` *largest element in the array*. Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.

**Example 1:**

```c++
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```

**Constraints:**

- `1 <= k <= nums.length <= 104`
- `-104 <= nums[i] <= 104`

```c++
// (1) method 1: vector, Sort O(nlogn)
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        return nums[nums.size()- k];
    }
};
```

```c++
// (2) method 2: priority_queue, O(nlogn)
class Solution {
public:
    // You may assume k is always valid, 1 ≤ k ≤ array's length.
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<>> pq; 
        for(auto x : nums){
            pq.push(x);
            if(pq.size() > k){
                pq.pop();
            }
        } 
        return pq.top();
    }
};
```

#### [347. Top K Frequent Elements](https://leetcode-cn.com/problems/top-k-frequent-elements/)

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**. 

**Example 1:**

```c++
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Constraints:**

- `1 <= nums.length <= 105`
- `k` is in the range `[1, the number of unique elements in the array]`.
- It is **guaranteed** that the answer is **unique**.

**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.

```c++
// (1) method 1: map + priority_queue:
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> ans;
        unordered_map<int, int> mp;
        for(auto x : nums) mp[x]++;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for(auto [val,freq] : mp){
            pq.push({freq, val});
            if(pq.size() > k){
                pq.pop();
            }
        }
        while(!pq.empty()){
            auto tmp = pq.top(); pq.pop();
            ans.push_back(tmp.second);
        }
        return ans;
    }
};
```

#### [692. Top K Frequent Words](https://leetcode-cn.com/problems/top-k-frequent-words/)

Given an array of strings `words` and an integer `k`, return *the* `k` *most frequent strings*. Return the answer **sorted** by **the frequency** from highest to lowest. Sort the words with the same frequency by their **lexicographical order**.

**Example 1:**

```c++
Input: words = ["i","love","leetcode","i","love","coding"], k = 2
Output: ["i","love"]
Explanation: "i" and "love" are the two most frequent words.
Note that "i" comes before "love" due to a lower alphabetical order.
```

**Constraints:**

- `1 <= words.length <= 500`
- `1 <= words[i] <= 10`
- `words[i]` consists of lowercase English letters.
- `k` is in the range `[1, The number of **unique** words[i]]`

**Follow-up:** Could you solve it in `O(n log(k))` time and `O(n)` extra space?

```c++
// (1) method 1: use map to cnt frequency, use priority_queue to get top k;
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> cnt;
        for (auto& word : words) {
            cnt[word]++;
        }
        auto cmp = [&](const pair<string, int>& a, const pair<string, int>& b) {
            return a.second == b.second ? a.first < b.first : a.second > b.second;
        };
        // pq is minHeap:
        priority_queue<pair<string, int>, vector<pair<string, int>>,
            decltype(cmp)> pq(cmp);
        for (auto& it : cnt) {
            pq.emplace(it);
            if (pq.size() > k) {
                pq.pop();
            }
        }
        vector<string> ans(k);
        for (int i = k - 1; i >= 0; i--) {
            ans[i] = pq.top().first; pq.pop();
        }
        return ans;
    }
};
```



#### [1801. Number of Orders in the Backlog](https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/)

You are given a 2D integer array `orders`, where each `orders[i] = [pricei, amounti, orderTypei]` denotes that `amounti` orders have been placed of type `orderTypei` at the price `pricei`. The `orderTypei` is:

- `0` if it is a batch of `buy` orders, or
- `1` if it is a batch of `sell` orders.

Note that `orders[i]` represents a batch of `amounti` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`. There is a **backlog** that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:

- If the order is a `buy` order, you look at the `sell` order with the **smallest** price in the backlog. If that `sell` order's price is **smaller than or equal to** the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.
- Vice versa, if the order is a `sell` order, you look at the `buy` order with the **largest** price in the backlog. If that `buy` order's price is **larger than or equal to** the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.

Return *the total **amount** of orders in the backlog after placing all the orders from the input*. Since this number can be large, return it **modulo** `10^9 + 7`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/11/ex1.png)

```c++
Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
Output: 6
Explanation: Here is what happens with the orders:
- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.
- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.
- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.
- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.
Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/11/ex2.png)

```c++
Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
Output: 999999984
Explanation: Here is what happens with the orders:
- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.
- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.
- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.
- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.
Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).
```

**Constraints:**

- `1 <= orders.length <= 105`
- `orders[i].length == 3`
- `1 <= pricei, amounti <= 109`
- `orderTypei` is either `0` or `1`.

```c++
// (1) method 1: 堆中为什么要用pair存订单： 不然一个订单需要push特别多次，特别慢
class Solution {
public:
    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
        //<价格, 数目>，最大堆，pair 默认按照第一个元素排序
        priority_queue<pair<int, int>, vector<pair<int, int>>, less<pair<int, int>>> BuyQ;  
        //<价格, 数目>，最小堆
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> SellQ; 
        for (auto& order : orders) {
            int price  = order[0];
            int amount = order[1];
            int type   = order[2];
            if (type == 0) 
            {   //当前订单是Buy，需要找最小的Sell
                while (amount > 0 && !SellQ.empty() && SellQ.top().first <= price) {  
                    //当前订单数目大于0，Sell最低价<= 当前订单价格
                    if (amount > SellQ.top().second) {  //当前订单数 > Sell最低价的订单数
                        amount -= SellQ.top().second;
                        SellQ.pop();  //Sell中最低价被删除
                    } else if (amount == SellQ.top().second) {  //当前订单数 == Sell最低价的订单数
                        SellQ.pop();  //Sell中最低价被删除
                        amount = 0;
                    } else if (amount < SellQ.top().second) { //当前订单数 < Sell最低价的订单数
                        auto minSell = SellQ.top(); SellQ.pop(); //更新Sell最低价的订单数量
                        SellQ.push(pair<int, int>(minSell.first, minSell.second - amount));
                        amount = 0;
                    }
                }
                if (amount > 0) BuyQ.push(pair<int, int>(price, amount)); //当前订单数还有余留，则压入队列中
            } 
            else 
            {  //当前订单是Sell，需要找最大的Buy
                while (amount > 0 && !BuyQ.empty() && BuyQ.top().first >= price) {  
                    //当前订单数目大于0，Buy最高价>= 当前订单价格
                    if (amount > BuyQ.top().second) {  //当前订单数 > Buy最高价的订单数
                        amount -= BuyQ.top().second;
                        BuyQ.pop();  //Buy最高价被删除
                    } else if (amount == BuyQ.top().second) {  //当前订单数 == Buy最高价的订单数
                        BuyQ.pop();  //Buy最高价被删除
                        amount = 0;
                    } else if (amount < BuyQ.top().second) { //当前订单数 < Buy最高价的订单数
                        auto maxBuy = BuyQ.top(); BuyQ.pop(); //更新Buy最高价的订单数量
                        BuyQ.push(pair<int, int>(maxBuy.first, maxBuy.second - amount));
                        amount = 0;
                    }
                }
                if (amount > 0) SellQ.push(pair<int, int>(price, amount)); //当前订单数还有余留，则压入队列中
            }
        }
        int res = 0;
        int mod = 1e9+7;
        while (!BuyQ.empty()) {
            res = (res + BuyQ.top().second) % mod;
            BuyQ.pop();
        }
        while (!SellQ.empty()) {
            res = (res + SellQ.top().second) % mod;
            SellQ.pop();
        }
        return res;
    }
};
```

