[TOC]
Table of Contents
=================

* [Tree](#tree)
   * [1. Tree BFS:](#1-tree-bfs)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" rel="nofollow">102. Binary Tree Level Order Traversal</a>](#102-binary-tree-level-order-traversal)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" rel="nofollow">103. Binary Tree Zigzag Level Order Traversal</a>](#103-binary-tree-zigzag-level-order-traversal)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" rel="nofollow">107. Binary Tree Level Order Traversal II</a>](#107-binary-tree-level-order-traversal-ii)
         * [<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" rel="nofollow">116. Populating Next Right Pointers in Each Node</a>](#116-populating-next-right-pointers-in-each-node)
         * [<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" rel="nofollow">117. Populating Next Right Pointers in Each Node II</a>](#117-populating-next-right-pointers-in-each-node-ii)
         * [<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" rel="nofollow">513. Find Bottom Left Tree Value</a>](#513-find-bottom-left-tree-value)
         * [<a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" rel="nofollow">515. Find Largest Value in Each Tree Row</a>](#515-find-largest-value-in-each-tree-row)
         * [<a href="https://leetcode-cn.com/problems/add-one-row-to-tree/" rel="nofollow">623. Add One Row to Tree</a>](#623-add-one-row-to-tree)
         * [<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" rel="nofollow">637. Average of Levels in Binary Tree</a>](#637-average-of-levels-in-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" rel="nofollow">671. Second Minimum Node In a Binary Tree</a>](#671-second-minimum-node-in-a-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/" rel="nofollow">958. Check Completeness of a Binary Tree</a>](#958-check-completeness-of-a-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" rel="nofollow">993. Cousins in Binary Tree</a>](#993-cousins-in-binary-tree)
   * [2.  TreeDepth related](#2--treedepth-related)
         * [<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" rel="nofollow">104. Maximum Depth of Binary Tree</a>](#104-maximum-depth-of-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/balanced-binary-tree/" rel="nofollow">110. Balanced Binary Tree</a>](#110-balanced-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" rel="nofollow">111. Minimum Depth of Binary Tree</a>](#111-minimum-depth-of-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" rel="nofollow">222. Count Complete Tree Nodes</a>](#222-count-complete-tree-nodes)
         * [<a href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/" rel="nofollow">366. Find Leaves of Binary Tree</a>](#366-find-leaves-of-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" rel="nofollow">543. Diameter of Binary Tree</a>](#543-diameter-of-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/" rel="nofollow">865. Smallest Subtree with all the Deepest Nodes</a>](#865-smallest-subtree-with-all-the-deepest-nodes)
         * [<a href="https://leetcode-cn.com/problems/deepest-leaves-sum/" rel="nofollow">1302. Deepest Leaves Sum</a>](#1302-deepest-leaves-sum)
   * [3. Tree Path:](#3-tree-path)
      * [(1) Path Sum](#1-path-sum)
         * [<a href="https://leetcode-cn.com/problems/path-sum/" rel="nofollow">112. Path Sum</a>](#112-path-sum)
         * [<a href="https://leetcode-cn.com/problems/path-sum-ii/" rel="nofollow">113. Path Sum II</a>](#113-path-sum-ii)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" rel="nofollow">124. Binary Tree Maximum Path Sum</a>](#124-binary-tree-maximum-path-sum)
         * [<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" rel="nofollow">129. Sum Root to Leaf Numbers</a>](#129-sum-root-to-leaf-numbers)
         * [<a href="https://leetcode-cn.com/problems/path-sum-iii/" rel="nofollow">437. Path Sum III</a>](#437-path-sum-iii)
      * [(2) Normal Tree Path:](#2-normal-tree-path)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-paths/" rel="nofollow">257. Binary Tree Paths</a>](#257-binary-tree-paths)
         * [<a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" rel="nofollow">863. All Nodes Distance K in Binary Tree</a>](#863-all-nodes-distance-k-in-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/" rel="nofollow">988. Smallest String Starting From Leaf</a>](#988-smallest-string-starting-from-leaf)
         * [<a href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/" rel="nofollow">1372. Longest ZigZag Path in a Binary Tree</a>](#1372-longest-zigzag-path-in-a-binary-tree)
   * [4. Subtree:](#4-subtree)
         * [<a href="https://leetcode-cn.com/problems/same-tree/" rel="nofollow">100. Same Tree</a>](#100-same-tree)
         * [<a href="https://leetcode-cn.com/problems/symmetric-tree/" rel="nofollow">101. Symmetric Tree</a>](#101-symmetric-tree)
         * [<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" rel="nofollow">108. Convert Sorted Array to Binary Search Tree</a>](#108-convert-sorted-array-to-binary-search-tree)
         * [<a href="https://leetcode-cn.com/problems/invert-binary-tree/" rel="nofollow">226. Invert Binary Tree</a>](#226-invert-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="nofollow">235. Lowest Common Ancestor of a Binary Search Tree</a>](#235-lowest-common-ancestor-of-a-binary-search-tree)
         * [<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow">236. Lowest Common Ancestor of a Binary Tree</a>](#236-lowest-common-ancestor-of-a-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" rel="nofollow">404. Sum of Left Leaves</a>](#404-sum-of-left-leaves)
         * [<a href="https://leetcode-cn.com/problems/most-frequent-subtree-sum/" rel="nofollow">508. Most Frequent Subtree Sum</a>](#508-most-frequent-subtree-sum)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-tilt/" rel="nofollow">563. Binary Tree Tilt</a>](#563-binary-tree-tilt)
         * [<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" rel="nofollow">572. Subtree of Another Tree</a>](#572-subtree-of-another-tree)
         * [<a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" rel="nofollow">606. Construct String from Binary Tree</a>](#606-construct-string-from-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" rel="nofollow">617. Merge Two Binary Trees</a>](#617-merge-two-binary-trees)
         * [<a href="https://leetcode-cn.com/problems/maximum-binary-tree/" rel="nofollow">654. Maximum Binary Tree</a>](#654-maximum-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/print-binary-tree/" rel="nofollow">655. Print Binary Tree</a>](#655-print-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/longest-univalue-path/" rel="nofollow">687. Longest Univalue Path</a>](#687-longest-univalue-path)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-pruning/" rel="nofollow">814. Binary Tree Pruning</a>](#814-binary-tree-pruning)
         * [<a href="https://leetcode-cn.com/problems/range-sum-of-bst/" rel="nofollow">938. Range Sum of BST</a>](#938-range-sum-of-bst)
         * [<a href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees/" rel="nofollow">951. Flip Equivalent Binary Trees</a>](#951-flip-equivalent-binary-trees)
         * [968. Binary Tree Cameras](<a href="https://leetcode-cn.com/problems/binary-tree-cameras/" rel="nofollow">https://leetcode-cn.com/problems/binary-tree-cameras/</a>)](#968-binary-tree-camerashttpsleetcode-cncomproblemsbinary-tree-cameras)
         * [<a href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/" rel="nofollow">979. Distribute Coins in Binary Tree</a>](#979-distribute-coins-in-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/maximum-average-subtree/" rel="nofollow">1120. Maximum Average Subtree</a>](#1120-maximum-average-subtree)
         * [<a href="https://leetcode-cn.com/problems/binary-tree-coloring-game/" rel="nofollow">1145. Binary Tree Coloring Game</a>](#1145-binary-tree-coloring-game)
         * [<a href="https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/" rel="nofollow">1315. Sum of Nodes with Even-Valued Grandparent</a>](#1315-sum-of-nodes-with-even-valued-grandparent)
         * [<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" rel="nofollow">1367. Linked List in Binary Tree</a>](#1367-linked-list-in-binary-tree)
         * [<a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/" rel="nofollow">1448. Count Good Nodes in Binary Tree</a>](#1448-count-good-nodes-in-binary-tree)
   * [5. BST:](#5-bst)
      * [(1) Biggest  SubBST :  most nodes or biggest sum](#1-biggest--subbst---most-nodes-or-biggest-sum)
         * [<a href="https://leetcode-cn.com/problems/largest-bst-subtree/" rel="nofollow">333. Largest BST Subtree</a> : most nodes](#333-largest-bst-subtree--most-nodes)
         * [<a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/" rel="nofollow">1373. Maximum Sum BST in Binary Tree</a> : biggest sum](#1373-maximum-sum-bst-in-binary-tree--biggest-sum)
      * [(2) BST Inorder](#2-bst-inorder)
         * [<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" rel="nofollow">99. Recover Binary Search Tree</a>](#99-recover-binary-search-tree)
         * [<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" rel="nofollow">230. Kth Smallest Element in a BST</a>](#230-kth-smallest-element-in-a-bst)
         * [<a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/" rel="nofollow">270. Closest Binary Search Tree Value</a>](#270-closest-binary-search-tree-value)
         * [<a href="https://leetcode-cn.com/problems/inorder-successor-in-bst/" rel="nofollow">285. Inorder Successor in BST</a>](#285-inorder-successor-in-bst)
         * [<a href="https://leetcode-cn.com/problems/inorder-successor-in-bst-ii/" rel="nofollow">510. Inorder Successor in BST II</a>](#510-inorder-successor-in-bst-ii)
         * [<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" rel="nofollow">783. Minimum Distance Between BST Nodes</a>](#783-minimum-distance-between-bst-nodes)
         * [<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" rel="nofollow">98. Validate Binary Search Tree</a>](#98-validate-binary-search-tree)
      * [(3) BST + Binary Search:](#3-bst--binary-search)
         * [<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" rel="nofollow">108. Convert Sorted Array to Binary Search Tree</a>](#108-convert-sorted-array-to-binary-search-tree-1)
         * [<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" rel="nofollow">700. Search in a Binary Search Tree</a>](#700-search-in-a-binary-search-tree)
         * [<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" rel="nofollow">701. Insert into a Binary Search Tree</a>](#701-insert-into-a-binary-search-tree)
         * [<a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" rel="nofollow">653. Two Sum IV - Input is a BST</a>](#653-two-sum-iv---input-is-a-bst)
         * [<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" rel="nofollow">669. Trim a Binary Search Tree</a>](#669-trim-a-binary-search-tree)
         * [<a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" rel="nofollow">173. Binary Search Tree Iterator</a>](#173-binary-search-tree-iterator)
         * [<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" rel="nofollow">450. Delete Node in a BST</a>](#450-delete-node-in-a-bst)
         * [<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" rel="nofollow">538. Convert BST to Greater Tree</a>](#538-convert-bst-to-greater-tree)
   * [6. Tree Traversal:](#6-tree-traversal)
         * [<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" rel="nofollow">430. Flatten a Multilevel Doubly Linked List</a>](#430-flatten-a-multilevel-doubly-linked-list)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->


# Tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
```

## 1. Tree BFS:



#### [102. Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector <vector <int>> ret;
        if (!root) return ret;
        queue <TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            ret.push_back(vector <int> ());
            for (int i = 1; i <= size; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return ret;
    }
};
```



#### [103. Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

Given the `root` of a binary tree, return *the zigzag level order traversal of its nodes' values*. (i.e., from left to right, then right to left for the next level and alternate between).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        if(!root) return ret;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            int currentLevelSize = q.size();
            ret.push_back(vector <int> ());
            for (int i = 1; i <= currentLevelSize; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        for(int i = 1; i < ret.size(); i+=2)
            reverse(ret[i].begin(), ret[i].end());
        return ret;
    }
};
```



#### [107. Binary Tree Level Order Traversal II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

Given the `root` of a binary tree, return *the bottom-up level order traversal of its nodes' values*. (i.e., from left to right, level by level from leaf to root).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
```

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int> > ans;
        if(!root) return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int curNodeSize = q.size();
            ans.push_back(vector<int> ());
            for(int i = 1; i <= curNodeSize; i++){
                auto node = q.front(); q.pop();
                ans.back().push_back(node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        reverse(ans.begin(), ans.end()); 
        return ans;
    }
};
```







#### [116. Populating Next Right Pointers in Each Node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

**Follow up:**

- You may only use constant extra space.
- Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```c++
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Constraints:**

- The number of nodes in the given tree is less than `4096`.
- `-1000 <= node.val <= 1000`

**(1) method 1: DFS **

```c++
class Solution {
public:
    // for the perfect binary tree can use following method:(not for normal tree):
    Node* connect(Node* root) {
        if (root == nullptr || root->left == nullptr) return root;
        // (1) connect two children of cur node
        root->left->next = root->right;
        // (2) if cur has next node then connect cur->right and cur->next->left:
        if (root->next) root->right->next = root->next->left;
        connect(root->left);
        connect(root->right);
        return root;
    }
};
```



**(2) method 2: BFS**

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int q_size = q.size(); 
            Node* tmp = q.front();
            for(int i = 1; i <= q_size; i++){
                auto node = q.front(); q.pop();
                if(i==1) tmp = node;  
                else if(i > 1){
                    tmp->next = node;  
                    tmp = node; 
                }
                tmp->next = NULL;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return root;
    }
};
```

**(3) method 3: same code as LeetCode 117: **

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        // every layer will be a list:
        Node* cur = root; // start from root:
        Node* dummy = new Node(0); // point to the first point in next level:
        Node* pre = dummy; // used for store the former node in current level:
        // if dummy->next is nullptr means all nodes are connected:
        while (cur != nullptr) {
            dummy->next = nullptr;
            pre = dummy;
            // dummy->next is the first node of next level:
            // connect left and right and update pre, finish one level in while:
            while (cur != nullptr) {
                if (cur->left != nullptr) { // deal with left child
                    pre->next = cur->left;
                    pre = pre->next;
                }
                if (cur->right != nullptr) { // deal with right child
                    pre->next = cur->right;
                    pre = pre->next;
                }
                // move to next node in current level:
                cur = cur->next;
            }
            // move cur node to the first node in next level:
            cur = dummy->next;  
        }
        return root;
    }
};
```



#### [117. Populating Next Right Pointers in Each Node II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

Given a binary tree

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. 

**Follow up:**

- You may only use constant extra space.
- Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

```
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

 **Constraints:**

- The number of nodes in the given tree is less than `6000`.
- `-100 <= node.val <= 100`

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        // every layer will be a list:
        Node* cur = root; // start from root:
        Node* dummy = new Node(0); // point to the first point in next level:
        Node* pre = dummy; // used for store the former node in current level:
        // if dummy->next is nullptr means all nodes are connected:
        while (cur != nullptr) {
            dummy->next = nullptr;
            pre = dummy;
            // dummy->next is the first node of next level:
            // connect left and right and update pre, finish one level in while:
            while (cur != nullptr) {
                if (cur->left != nullptr) { // deal with left child
                    pre->next = cur->left;
                    pre = pre->next;
                }
                if (cur->right != nullptr) { // deal with right child
                    pre->next = cur->right;
                    pre = pre->next;
                }
                // move to next node in current level:
                cur = cur->next;
            }
            // move cur node to the first node in next level:
            cur = dummy->next;  
        }
        return root;
    }
};
```

#### [513. Find Bottom Left Tree Value](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

Given the `root` of a binary tree, return the leftmost value in the last row of the tree. 

**Example 1:

![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

```c++
Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7
```

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int ans = 0;
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                auto node = q.front(); q.pop();
                if(i == 0) ans = node->val;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return ans;
    }
};
```





#### [515. Find Largest Value in Each Tree Row](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

Given the `root` of a binary tree, return *an array of the largest value in each row* of the tree **(0-indexed)**. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)

```c++
Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
```



```c++
class Solution {
public:
    // INT_MIN = -2^31
    // INT_MAX = 2^31 -1
    vector<int> largestValues(TreeNode* root) {
        if(!root) return {};
        vector<int> ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            int max_val = INT_MIN;
            for(int i = 0; i < size; i++){
                auto node = q.front(); q.pop();
                max_val = max(max_val, node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            ans.push_back(max_val);
        }
        return ans;
    }
};
```



#### [623. Add One Row to Tree](https://leetcode-cn.com/problems/add-one-row-to-tree/)

Given the `root` of a binary tree and two integers `val` and `depth`, add a row of nodes with value `val` at the given depth `depth`. Note that the `root` node is at depth `1`.

The adding rule is:

- Given the integer `depth`, for each not null tree node `cur` at the depth `depth - 1`, create two tree nodes with value `val` as `cur`'s left subtree root and right subtree root.
- `cur`'s original left subtree should be the left subtree of the new left subtree root.
- `cur`'s original right subtree should be the right subtree of the new right subtree root.
- If `depth == 1` that means there is no depth `depth - 1` at all, then create a tree node with value `val` as the new root of the whole original tree, and the original tree is the new root's left subtree.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg)

```c++
Input: root = [4,2,6,3,1,5], val = 1, depth = 2
Output: [4,1,1,2,null,null,6,3,1,5]
```

```c++
class Solution {
public:
    TreeNode* addOneRow(TreeNode* root, int v, int d) {
        if(!root) return {};
        queue<TreeNode*> q;
        q.push(root);
        int depth = 1;
        // corner case: when add at the first level:
        // connect root to new_left and right == nullptr;
        if(d == 1){ 
            TreeNode* new_root = new TreeNode(v);
            new_root->left = root;
            new_root->right = nullptr;
            return new_root;
        }
        while(!q.empty()){  
            int size = q.size(); 
            for(int i = 1; i <= size; i++){
                auto node = q.front(); q.pop();
                // save next level, bc will change later
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
                if(depth == d-1){ 
                    // In for loop:work on one node of level d-1:
                    TreeNode* l_child = new TreeNode(v);
                    TreeNode* r_child = new TreeNode(v);
                    if(node->left){ 
                        l_child->left = node->left;
                        l_child->right = nullptr;
                    }
                    if(node->right){ 
                        r_child->right = node->right;
                        r_child->left = nullptr;
                    }
                    node->left  = l_child;
                    node->right = r_child;
                }
            }
            depth++; 
            if(depth == d) return root; 
        }
        return root;
    }
};
```





#### [637. Average of Levels in Binary Tree](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

Given the `root` of a binary tree, return *the average value of the nodes on each level in the form of an array*. Answers within `10-5` of the actual answer will be accepted.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)

```c++
Input: root = [3,9,20,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
```

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `-2^31 <= Node.val <= 2^31 - 1`



```c++
class Solution {
public: 
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ret;
        if(!root) return ret;
        queue<TreeNode* > q;
        q.push(root);
        while(!q.empty()){
          	// save size here:
            int size = q.size(); 
          	// use double here !!
            double sum = 0, count = 0;
            for(int i = 1; i <= size; i++){ 
                auto node = q.front(); q.pop();
                sum += node->val; count++;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            ret.push_back(sum/count);
        }
        return ret;
    }
};
```





#### [671. Second Minimum Node In a Binary Tree](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly `two` or `zero` sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property `root.val = min(root.left.val, root.right.val)` always holds.

Given such a binary tree, you need to output the **second minimum** value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)

```c++
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
```

```c++
class Solution {
public:
    // the smallest must be root:
    // recursion to find the first value that is bigger than root->val:
    // return the next value that bigger than val in the tree:
    int dfs(TreeNode* root, int val) {
        if (!root) return -1;
        if (root->val > val) return root->val;
        int left = dfs(root->left, val); // next bigger value in left subtree
        int right = dfs(root->right, val); // next bigger value in right subtree
        if (left < 0) return right;
        if (right < 0) return left;
        return min(left, right); // two bigger value in both left and right
    }
    int findSecondMinimumValue(TreeNode* root) {
        return dfs(root, root->val);
    }
};
```

#### [958. Check Completeness of a Binary Tree](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

Given the `root` of a binary tree, determine if it is a *complete binary tree*. In a **[complete binary tree](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png)

```c++
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
```

```c++
class Solution {
public:
    // two condition make it not complete:
    // (1) if a node only has right child
    // (2) if a node only has left child, or no children, 
    // any node later will be leave node.
    bool isCompleteTree(TreeNode* root) {
        if (!root) return true;
        queue<TreeNode*> q;
        q.push(root);
        bool ifLeaf = false;  
        while (!q.empty()){
            TreeNode* node = q.front(); q.pop();
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
            // (1) condition 1:
            if (!node->left && node->right)  return false;
            // (2) condition 2:
            if (ifLeaf && (node->left || node->right)){ 
                return false;
            }
            // if node has no right child, change ifLeaf
            if(!node->right) ifLeaf = true; 
        }
        return true;
    }
};
```



#### [993. Cousins in Binary Tree](https://leetcode-cn.com/problems/cousins-in-binary-tree/)

Given the `root` of a binary tree with unique values and the values of two different nodes of the tree `x` and `y`, return `true` *if the nodes corresponding to the values* `x` *and* `y` *in the tree are **cousins**, or* `false` *otherwise.*

Two nodes of a binary tree are **cousins** if they have the same depth with different parents.

Note that in a binary tree, the root node is at the depth `0`, and children of each depth `k` node are at the depth `k + 1`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png)

```c++
Input: root = [1,2,3,4], x = 4, y = 3
Output: false
```



```c++
class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        queue<TreeNode*>q;
        q.push(root); 
        int flag = 2;                       
        while(!q.empty()){
            int n = q.size();
            for(int i = 0; i<n; i++){         
                auto root = q.front(); q.pop();    
                if( root->left && 
                    root->right &&
                    ((root->left->val == x  && root->right->val == y)
                    ||(root->left->val == y && root->right->val == x)
                )){           
                    return false; // cousins can not have same parent:
                } 
                if(root->left){
                    q.push(root->left);    
                    // if root->left is x or y flag-- means found one:
                    if(root->left->val == x || root->left->val == y) flag--;    
                }
                if(root->right){    
                    // if root->right is x or y flag-- means found one:
                    q.push(root->right);
                    if(root->right->val==x || root->right->val==y) flag--;
                }  
            }
            // if only found one in current level, return false;
            if(flag==1) return false;   
            // if found both, and not has the same father, return true:
            if(flag==0) return true;   
            // else if flag==2: means have not found any of the two nodes:
        }                            
        return false;  
    }
};
```







## 2.  TreeDepth related



#### [104. Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

Given the `root` of a binary tree, return *its maximum depth*. A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: 3
```



```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;        
        return 1 + max(maxDepth(root->left), 
                       maxDepth(root->right));
    }
};
```



#### [110. Balanced Binary Tree](https://leetcode-cn.com/problems/balanced-binary-tree/)

Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of *every* node differ in height by no more than 1. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: true
```



```c++
class Solution {
public:
    int flag = true;
    // check every node's l-subtree's h and r-subtree's h 
    int dfs(TreeNode* root){
        if(flag == false) return 0;
        if(root == nullptr) return 1;
        int l = dfs(root->left); // height of left subtree
        int r = dfs(root->right);// height of right subtree
        if(abs(l-r) > 1) flag = false; // if height dif is more than 1, means not balanced. 
        return max(l,r)+1;
    }
    bool isBalanced(TreeNode* root) {
        dfs(root);
        return flag;
    }
};
```





#### [111. Minimum Depth of Binary Tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. **Note:** A leaf is a node with no children. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: 2
```

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;  // recur exit
        int l = minDepth(root->left);// min_d of left tree
        int r = minDepth(root->right);// min_d of right tree
        if (!l || !r) return l+r+1;// include 3 conditions
        return min(l, r) + 1; 
    }
};
```



#### [222. Count Complete Tree Nodes](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

Given the `root` of a **complete** binary tree, return the number of the nodes in the tree. According to **[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`. Design an algorithm that runs in less than `O(n)` time complexity.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```c++
Input: root = [1,2,3,4,5,6]
Output: 6
```



```c++
// (1) method 1:
// Time Complexity: O(n), for traversal every node;
class Solution {
public:
    int countNodes(TreeNode* root) {
        return root != nullptr ? 1+countNodes(root->right)+countNodes(root->left):0;
    }
};
```



```c++
// (2) method 2:
// use the feature of complete tree: 
//     if (l_depth == r_depth): left subtree is comoplete; 
//     else right subtree is comoplete;  
//     And number of nodes for complete tree: (1 << depth): 2^h: 
//     bc number of complete tree nodes is 2^h -1,so plus root is 2^h;
// use the feature of complete tree: 
//     if l_depth==r_depth: left subtree is comoplete; 
//     else right subtree is comoplete;  
//     And (1 << l_depth): 2^h: 
// bc number of complete tree nodes is 2^h -1,so plus root is 2^h;
class Solution {
public:
  	// Time complexity: O(logN * logN): 
    // In each recursion 
    //    (1) logN to get tree depth
    // 		(2) spilt half, kind of like binary search. logN
  	// So in total is O(logN * logN);
  
    // (1) depth of left-bottom node for complete tree:
    int countLevels(TreeNode * root) {
        int level = 0;
        while (root != nullptr) {
            level++;
            root = root->left; 
        }
        return level;
    }
    int count(TreeNode * root, int l_depth) {
        if (!root) return 0;
        int r_depth = countLevels(root->right);
        // (1) left tree is complete, recursion in right subtree:
        if (l_depth == r_depth){
            
            return (1<<l_depth) + count(root->right, r_depth-1);
        }
        // (2) right subtree is complete, recursion in left subtree:
        return (1 << r_depth) + count(root->left, l_depth - 1);
    }
    int countNodes(TreeNode* root) {
        return count(root, countLevels(root) - 1);
    }
};
```



#### [366. Find Leaves of Binary Tree](https://leetcode-cn.com/problems/find-leaves-of-binary-tree/)

Given the `root` of a binary tree, collect a tree's nodes as if you were doing this:

- Collect all the leaf nodes.
- Remove all the leaf nodes.
- Repeat until the tree is empty.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg)

```c++
Input: root = [1,2,3,4,5]
Output: [[4,5,3],[2],[1]]
Explanation:
[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned. 
```

**Constraints:**

- The number of nodes in the tree is in the range `[1, 100]`.
- `-100 <= Node.val <= 100`

```c++
class Solution {
public:
    // calculate tree height from the bottom, then leaves have same h==0;
    // push these result according to height:
    vector<vector<int>> ans;

    vector<vector<int>> findLeaves(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // return h of tree:
    int dfs(TreeNode* root){
        if(root == nullptr) return 0;
        // post order:
        int l = dfs(root->left); // height of left tree
        int r = dfs(root->right); // height of right tree
        int h = max(l, r) + 1;
        if(ans.size() < h) ans.resize(h);
        ans[h-1].push_back(root->val);
        return h;
    }
};
```



#### [543. Diameter of Binary Tree](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

Given the `root` of a binary tree, return *the length of the **diameter** of the tree*. The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`. The **length** of a path between two nodes is represented by the number of edges between them.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```c++
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
```

```c++
class Solution {
public:
    int depth = 0; // update depth
    // max_depth of root
    int dfs(TreeNode* root){  
        if(!root) return 0;
        int L = dfs(root->left);
        int R = dfs(root->right);
        depth = max (L+R, depth);
        return max(L, R) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return depth;
    }
};
```









#### [865. Smallest Subtree with all the Deepest Nodes](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/)

Given the `root` of a binary tree, the depth of each node is **the shortest distance to the root**.

Return *the smallest subtree* such that it contains **all the deepest nodes** in the original tree.

A node is called **the deepest** if it has the largest depth possible among any node in the entire tree.

The **subtree** of a node is tree consisting of that node, plus the set of all descendants of that node.

**Note:** This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/ 

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)

```c++
Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
```

```c++
class Solution {
public:
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        if(!root) return nullptr;
        int l_dpeth = tree_depth(root->left);
        int r_dpeth = tree_depth(root->right);
        if(l_dpeth > r_dpeth){
            return subtreeWithAllDeepest(root->left);
        }
        else if(l_dpeth < r_dpeth) {
            return subtreeWithAllDeepest(root->right);
        }
        return root;
    }
    int tree_depth(TreeNode* root){
        if(!root) return 0;
        return max(tree_depth(root->left), 
                   tree_depth(root->right)) + 1;
    }
};
```











#### [1302. Deepest Leaves Sum](https://leetcode-cn.com/problems/deepest-leaves-sum/)

Given the `root` of a binary tree, return *the sum of values of its deepest leaves*.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png)

```c++
Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
Output: 15
```

```c++
class Solution {
public:
    int max_depth(TreeNode* root){
        if(!root) return 0;
        return 1+ max(max_depth(root->left), 
                        max_depth(root->right));
    }
    int deepestLeavesSum(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int max_d = max_depth(root);
        int depth = 1;
        int sum = 0;
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++)
            {
                auto node = q.front(); q.pop();
                if(depth == max_d) sum += node->val;
                if(node->left)  q.push(node->left);
                if(node->right) q.push(node->right);
            }
            depth++;
        }
        return sum;
    }
};
```



---



## 3. Tree Path:

### (1) Path Sum

#### [112. Path Sum](https://leetcode-cn.com/problems/path-sum/)

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. A **leaf** is a node with no children.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```c++
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
```

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(!root) return false;
        if(!root->left && !root->right) 
            return (sum == root->val);
        return hasPathSum(root->left, sum - root->val) 
            || hasPathSum(root->right, sum - root->val);
    }
};
```



#### [113. Path Sum II](https://leetcode-cn.com/problems/path-sum-ii/)

Given the `root` of a binary tree and an integer `targetSum`, return *all **root-to-leaf** paths where the sum of the node values in the path equals* `targetSum`*. Each path should be returned as a list of the node **values**, not node references*. A **root-to-leaf** path is a path starting from the root and ending at any leaf node. A **leaf** is a node with no children. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```c++
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
Explanation: There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
```

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return ans;
        vector<int> path;
        dfs(root, targetSum, path);
        return ans;
    }
    void dfs(TreeNode* root, int targetSum, vector<int> path){
        if(root == nullptr) return;
        // backtracking 1: push node
        path.push_back(root->val);
        // reach leaf + root->val == targetSum
        if(!root->left && !root->right && root->val == targetSum){
            ans.push_back(path);
        } 
        // recursion in left and right subtree
        dfs(root->left, targetSum - root->val, path);
        dfs(root->right, targetSum - root->val, path);
        // backtracking 2: pop_back 
        path.pop_back();
    }
};
```



#### [124. Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root. The **path sum** of a path is the sum of the node's values in the path. Given the `root` of a binary tree, return *the maximum **path sum** of any path*.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```c++
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```



```c++
class Solution {
public:
    int ans = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // the longest path from root:
    int dfs(TreeNode* root){
        if(!root) return 0;
        auto left = dfs(root->left);
        auto right = dfs(root->right);
        ans = max(ans, left + right + root->val);
        return max(0, max(left, right) + root->val);
    }
};
```

#### [129. Sum Root to Leaf Numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

You are given the `root` of a binary tree containing digits from `0` to `9` only.  Each root-to-leaf path in the tree represents a number.  For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`. Return *the total sum of all root-to-leaf numbers*. Test cases are generated so that the answer will fit in a **32-bit** integer. A **leaf** node is a node with no children.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```c++
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

```c++
class Solution {
public:
    long long ans; /// long long for int overflow
    void dfs(TreeNode* root, vector<int> path){
        if(root == nullptr) return;
        path.push_back(root->val);
        // only calculate sum when reaching leaves;
        if(root->left == nullptr && root->right == nullptr){
            long long tmp_sum = 0;
            for(int i = 0; i < path.size(); i++){
                tmp_sum *= 10;
                tmp_sum += path[i];
            }
            ans += tmp_sum;
        }
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
        path.pop_back();
  }
    int sumNumbers(TreeNode* root) {
        vector<int> path;
        dfs(root, path);
        return ans;
    }
};
```



#### [437. Path Sum III](https://leetcode-cn.com/problems/path-sum-iii/)

Given the `root` of a binary tree and an integer `targetSum`, return *the number of paths where the sum of the values along the path equals* `targetSum`.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```c++
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
```

```c++
// (1) method 1: normal method: nested dfs
class Solution {
public:
    int ans = 0;
    // path from root with sum;
    void dfs(TreeNode* root, int sum){
        if(root == nullptr) return;
        if(root->val == sum) ans ++;
        dfs(root->left, sum - root->val);
        dfs(root->right, sum - root->val);
    }
    
    // for every node , do dfs(root, sum);
    int pathSum(TreeNode* root, int sum) {
        if(root == nullptr) return 0;
        dfs(root, sum);
        pathSum(root->left, sum);
        pathSum(root->right, sum);
        return ans;
    }
};
```

```c++
// (2) method 2: prefix: TC: O(n):
class Solution {
public:
    int dfs(TreeNode* root, int targetSum, unordered_map<int, int> &m, int cur_sum) 
    {
        if (root == nullptr) return 0;
        int ans = 0;
        cur_sum += root->val;
        int prefix = cur_sum - targetSum;
        if (m.find(prefix) != m.end()) {
            ans += m[prefix];
        }
        ++m[cur_sum];
        ans += dfs(root->left,  targetSum, m, cur_sum) 
             + dfs(root->right, targetSum, m, cur_sum);
        --m[cur_sum];
        return ans;
    }
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;
        unordered_map<int, int> m;
        m[0] = 1;
        return dfs(root, targetSum, m, 0);
    }
};
```









### (2) Normal Tree Path:

#### [257. Binary Tree Paths](https://leetcode-cn.com/problems/binary-tree-paths/)

Given the `root` of a binary tree, return *all root-to-leaf paths in **any order***. A **leaf** is a node with no children.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```c++
Input: root = [1,2,3,null,5]
Output: ["1->2->5","1->3"]
```

```c++
class Solution {
public:
    vector<string> ans;
    void dfs(TreeNode*root, string tmp){
        if(root == nullptr) return;
        tmp += to_string(root->val);
        // if leave nodes, check if could be put into ans.
        if(root->left == nullptr && root->right == nullptr){
            ans.push_back(tmp);
        }
        else tmp += "->"; // add this for all non-leave nodes
        // recursion in left subtree
        dfs(root->left, tmp);
        dfs(root->right, tmp);
        tmp.pop_back();
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string tmp = "";
        dfs(root, tmp);
        return ans;
    }
};
```



#### [863. All Nodes Distance K in Binary Tree](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

Given the `root` of a binary tree, the value of a target node `target`, and an integer `k`, return *an array of the values of all nodes that have a distance* `k` *from the target node.* You can return the answer in **any order**.

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png)

```c++
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
Output: [7,4,1]
Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.
  // All the values Node.val are unique. but doesn't matter
```

```c++

// (1) find_father + bfs:
class Solution {
public:
    unordered_map<TreeNode *, TreeNode *> parent;
    // find father node for every node:
    void dfs_find_parent(TreeNode * node){
        if (node){
            if (node->left) parent[node->left] = node;
            if (node->right) parent[node->right] = node;
            dfs_find_parent(node->left);
            dfs_find_parent(node->right);
        }
    }
    // transfer tree to graph:
    // BFS start from target, to find node at step k;
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) 
    {
        // build graph: 
        dfs_find_parent(root);
        if (k == 0) return vector<int> {target->val};
        vector<int> ans;
        queue<TreeNode *> Q;
        unordered_set<TreeNode *> visited;
        Q.push(target);
        visited.insert(target);
        int level = 0;
        while (!Q.empty() && level < k){ // level > k break;
            level ++;
            int size = (int)Q.size();
            for (int i = 0; i < size; i ++){
                auto x = Q.front(); Q.pop();
                for (auto y : {parent[x],x->left,x->right}){
                    if (y && visited.find(y) == visited.end()){
                        if (level == k){
                            ans.push_back(y->val);
                        }
                        visited.insert(y);
                        Q.push(y);
                    }
                }
            }
        }
        return ans;
    }
};

```



```c++
// (2) find_father + dfs:
class Solution {
public:
    int k;
    unordered_map<TreeNode *, TreeNode *> parent;
    vector<int> res;

    void dfs_find_parent(TreeNode * node){ // O(n)
        if (node){
            if (node->left) parent[node->left] = node;
            if (node->right) parent[node->right] = node;
            dfs_find_parent(node->left);
            dfs_find_parent(node->right);
        }
    }

    void dfs_get_res(TreeNode * node, TreeNode * prev, int cur_dist)
    {
        if (!node) return;
        if (cur_dist == k)
        {
            res.push_back(node->val);
            return;
        }
        // following ifs to make sure not go backwards:
        // e.g. after searched father, don't search from child
        if (parent[node] != prev)
            dfs_get_res(parent[node], node, cur_dist + 1);
        if (node->left != prev)
            dfs_get_res(node->left, node, cur_dist + 1);
        if  (node->right != prev)
            dfs_get_res(node->right, node, cur_dist + 1);
    }

    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) 
    {
        this->k = k;
        dfs_find_parent(root);
        dfs_get_res(target, NULL, 0);
        return res;
    }
};
```







#### [988. Smallest String Starting From Leaf](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)

You are given the `root` of a binary tree where each node has a value in the range `[0, 25]` representing the letters `'a'` to `'z'`. Return *the **lexicographically smallest** string that starts at a leaf of this tree and ends at the root*.As a reminder, any shorter prefix of a string is **lexicographically smaller**.

- For example, `"ab"` is lexicographically smaller than `"aba"`. A leaf of a node is a node that has no children. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/01/30/tree1.png)

```c++
Input: root = [0,1,2,3,4,3,4]
Output: "dba"
```

```c++
class Solution {
public:
    string ans;
    void dfs(TreeNode* node, string path){
        if (!node) return;
        // transfer int to according char : 0 -> 'a'
        path += node->val + 'a'; 
        // (1) when reach a leave node, 
        // reverse the path to get leave to root and update ans;
        if (node->left == nullptr && node->right == nullptr){
            reverse(path.begin(), path.end());
            // use min to compare two string directly 
            ans = min(ans, path); 
            return;
        }
        // (2) if not a leave node, keep recursion:
        dfs(node->left,  path);
        dfs(node->right, path);
    }
    string smallestFromLeaf(TreeNode* root) {
        if (!root) return "";
        // initialize ans as a bigger string 
        // then all possible string in lexicographical;
        ans = "~"; // key point: "~" ascII is 
        dfs(root, "");
        return ans;
    }
};
```

#### [1372. Longest ZigZag Path in a Binary Tree](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)

You are given the `root` of a binary tree. A ZigZag path for a binary tree is defined as follow:

- Choose **any** node in the binary tree and a direction (right or left).
- If the current direction is right, move to the right child of the current node; otherwise, move to the left child.
- Change the direction from right to left or from left to right.
- Repeat the second and third steps until you can't move in the tree.

Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return *the longest **ZigZag** path contained in that tree*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png)

```c++
Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).
```

```c++
class Solution {
public:
    int maxAns = 0;;
    /* dir :  0 => left, 1 => right */
    void dfs(TreeNode* root, bool dir, int len) {
        maxAns = max(maxAns, len); 
        // (1) next step should go right
        if (dir == 0) { 
            // if has left child: len++, change direction:
            if (root->left) dfs(root->left, 1, len + 1); 
            // if has right child: len==1, keep direction:
            // len==1 not 0, bc just pass current node:
            if (root->right) dfs(root->right, 0, 1); 
        } 
        // (2) next step should go left
        else if(dir == 1) {
            if (root->right) dfs(root->right, 0, len + 1);
            if (root->left) dfs(root->left, 1, 1);
        }
    } 
    int longestZigZag(TreeNode* root) {
        if (!root) return 0;
        dfs(root, 0, 0); // root go left
        dfs(root, 1, 0); // root go right
        return maxAns;
    }
};
```



## 4. Subtree:



#### [100. Same Tree](https://leetcode-cn.com/problems/same-tree/)

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```c++
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p && !q) return true;
        if(!p || !q) return false;
        if(p->val != q->val) return false;
        return isSameTree(p->left, q->left)
            && isSameTree(p->right, q->right);
    }
};
```





#### [101. Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree/)

Given the `root` of a binary tree, *check whether it is a mirror of itself* (i.e., symmetric around its center).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```c++
Input: root = [1,2,2,3,4,4,3]
Output: true
```

```c++
class Solution {
public:
    bool dfs(TreeNode* p, TreeNode *q){
        if(!p || !q) return !p && !q; 
        return (p->val == q->val) && dfs(p->left, q->right) && dfs(p->right, q->left);
    }
    bool isSymmetric(TreeNode* root){
        if(!root) return true;
        return dfs(root->left, root->right);
    }
};
```



#### [108. Convert Sorted Array to Binary Search Tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a **height-balanced** binary search tree*.  A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```c++
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
```

```c++
class Solution {
public:
    TreeNode* build(vector<int>& nums, int l, int r){
        if(l > r) return nullptr;
        int mid = (l+r)/2;
        TreeNode* newNode = new TreeNode(nums[mid]);
        newNode->left = build(nums, l, mid-1);
        newNode->right = build(nums, mid+1, r);
        return newNode;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.empty()) return nullptr;
        return build(nums, 0, nums.size()-1);
    }
};
```





#### [226. Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree/)

Given the `root` of a binary tree, invert the tree, and return *its root*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```c++
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```



#### [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).” 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```c++
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

````c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == nullptr)return root;
        auto l = lowestCommonAncestor(root->left, p, q); 
        auto r = lowestCommonAncestor(root->right, p, q); 
        if(!l) return r;
        if(!r) return l;
        return root;
    }
};
````



#### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).” 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```c++
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == nullptr)return root;
        auto l = lowestCommonAncestor(root->left, p, q); 
        auto r = lowestCommonAncestor(root->right, p, q); 
        if(!l) return r;
        if(!r) return l;
        return root;
    }
};
```



#### [404. Sum of Left Leaves](https://leetcode-cn.com/problems/sum-of-left-leaves/)

Given the `root` of a binary tree, return the sum of all left leaves.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
```

```c++
class Solution {
public:
    int sum = 0;
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            auto node = q.front(); q.pop();
            if(node->left) q.push(node->left);
            if(node->left 
                && !node->left->left 
                && !node->left->right)
                sum = sum + node->left->val;
            if(node->right) q.push(node->right);
        }
        return sum;
    }
};
```







#### [508. Most Frequent Subtree Sum](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)

Given the `root` of a binary tree, return the most frequent **subtree sum**. If there is a tie, return all the values with the highest frequency in any order.

The **subtree sum** of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg)

```c++
Input: root = [5,2,-3]
Output: [2,-3,4]
```

```c++
class Solution {
public:
    vector<int> ans;
    unordered_map<int,int> m;
    int MAX = 1;  
    // getSum of root
    int getSum(TreeNode* root){
        if(root == nullptr) return 0;  
        int sum = getSum(root->left) 
                + getSum(root->right) 
                + root->val;
        m[sum]++;
        if(m[sum] == MAX) ans.push_back(sum);
        if(m[sum] > MAX){
            MAX = m[sum];
            ans.clear();
            ans.push_back(sum);
        }
        return sum;
    }
    vector<int> findFrequentTreeSum(TreeNode* root) {
        getSum(root);
        return ans;
    }
};
```



#### [563. Binary Tree Tilt](https://leetcode-cn.com/problems/binary-tree-tilt/)

Given the `root` of a binary tree, return *the sum of every tree node's **tilt**.* The **tilt** of a tree node is the **absolute difference** between the sum of all left subtree node **values** and all right subtree node **values**. If a node does not have a left child, then the sum of the left subtree node **values** is treated as `0`. The rule is similar if there the node does not have a right child. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg)

```c++
Input: root = [1,2,3]
Output: 1
Explanation: 
Tilt of node 2 : |0-0| = 0 (no children)
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)
Sum of every tilt : 0 + 0 + 1 = 1
```

```c++
class Solution {
public: 
    int sum = 0;
    // return sum of subtree
    int dfs(TreeNode* root){
        // nullptr node has 0 tilt:
        if(!root) return 0; 
        int l = dfs(root->left); 
        int r = dfs(root->right); 
        sum += abs(l - r); 
        return l + r + root->val;
    }
    int findTilt(TreeNode* root) {
        dfs(root);
        return sum;
    }
};
```



#### [572. Subtree of Another Tree](https://leetcode-cn.com/problems/subtree-of-another-tree/)

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of` subRoot` and `false` otherwise. A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)

```c++
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

```c++
class Solution {
public:
    bool isSametree (TreeNode* p, TreeNode* q){
        if(!p && !q) return true;
        if(!p || !q) return false;
        if(p->val != q->val) return false;
        return isSametree(p->left, q->left)
            && isSametree(p->right, q->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root == nullptr) return false;
        if(root->val == subRoot->val){
            if(isSametree(root, subRoot)){
                return true;
            }
        }
        return isSubtree(root->left, subRoot)
            || isSubtree(root->right, subRoot);
    }
};
```



#### [606. Construct String from Binary Tree](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

Given the `root` of a binary tree, construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg)

```c++
Input: root = [1,2,3,4]
Output: "1(2(4))(3)"
Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"
```

```c++
class Solution {
public:
    string tree2str(TreeNode* t) {
        // recursion exit: 
        // (1) if t == nullptr, return "";
        if(!t) return ""; 
        // (2) if left and right child are all nullptr, return v->val;
        if(!t->left && !t->right) return to_string(t->val); 
        // (3) if t->right = nullptr， return cur node and recursion 
        // result of t->left :  t->val + "(" + tree2str(t->left) + ")"
        if(!t->right){
            return to_string(t->val) +"("+tree2str(t->left)+")";
        }
        // (4) can not omit when miss left child
        // (5) bc when t->left == nullptr, we can omit the "()",
        // so we treat this as the same situation of both children are not nullptr.
        return to_string(t->val) 
            + "(" + tree2str(t->left) + ")(" + tree2str(t->right) + ")"; 
    }
};
```



#### [617. Merge Two Binary Trees](https://leetcode-cn.com/problems/merge-two-binary-trees/)

You are given two binary trees `root1` and `root2`.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return *the merged tree*.

**Note:** The merging process must start from the root nodes of both trees.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```c++
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
```

```c++

class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if(!t1) return t2;
        if(!t2) return t1;
        t1->val += t2->val;
        t1->left = mergeTrees(t1->left, t2->left);
        t1->right = mergeTrees(t1->right, t2->right);
        return t1;
    }
};
```



#### [654. Maximum Binary Tree](https://leetcode-cn.com/problems/maximum-binary-tree/)

You are given an integer array `nums` with no duplicates. A **maximum binary tree** can be built recursively from `nums` using the following algorithm:

1. Create a root node whose value is the maximum value in `nums`.
2. Recursively build the left subtree on the **subarray prefix** to the **left** of the maximum value.
3. Recursively build the right subtree on the **subarray suffix** to the **right** of the maximum value.

Return *the **maximum binary tree** built from* `nums`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```c++
Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
```

```c++
class Solution {
public:
    TreeNode* dfs(vector<int>&nums, int l, int r){
        if(l > r) return nullptr;
        int tmp_max = INT_MIN ; // the max value
        int idx = l; // find the max value in cur part
        // find the biggest element pos in the nums
        for(int i = l; i <= r; i++){
            if(nums[i] > tmp_max){
                tmp_max = nums[i];
                idx = i;
            }
        }
        TreeNode* root = new TreeNode(tmp_max);
        root->left = dfs(nums, l, idx-1);
        root->right = dfs(nums, idx+1, r);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n = (int)nums.size();
        if(n == 0) return nullptr;
        return dfs(nums, 0, n-1);
    }
};
```



#### [655. Print Binary Tree](https://leetcode-cn.com/problems/print-binary-tree/)

Given the `root` of a binary tree, construct a **0-indexed** `m x n` string matrix `res` that represents a **formatted layout** of the tree. The formatted layout matrix should be constructed using the following rules:

- The **height** of the tree is `height` and the number of rows `m` should be equal to `height + 1`.
- The number of columns `n` should be equal to `2height+1 - 1`.
- Place the **root node** in the **middle** of the **top row** (more formally, at location `res[0][(n-1)/2]`).
- For each node that has been placed in the matrix at position `res[r][c]`, place its **left child** at `res[r+1][c-2height-r-1]` and its **right child** at `res[r+1][c+2height-r-1]`.
- Continue this process until all the nodes in the tree have been placed.
- Any empty cells should contain the empty string `""`.

Return *the constructed matrix* `res`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg)

```c++
Input: root = [1,2]
Output: 
[["","1",""],
 ["2","",""]]
```

```c++
class Solution {
public:
  	// m is tree height 
  	// n == 2^(height+1)-1, root is in the middle of first line
    // pass by reference !! use &
    void dfs(TreeNode* root, int l,int r,int height,vector<vector<string> > &v){
        if(!root) return; 
        if(l > r) return; 
        int mid = (l + r)/2;
        v[height][mid] += to_string(root->val);
        dfs(root->left, l, mid-1, height+1, v);
        dfs(root->right, mid+1, r, height+1, v);
    }
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
    vector<vector<string>> printTree(TreeNode* root) {
        int m = maxDepth(root), n = 1;
        for(int i = 0; i < m; i++) n *= 2;
        n -= 1;
        vector<vector<string>> ans(m, vector<string>(n, ""));
        dfs(root, 0, n-1, 0, ans);
        return ans;
    }
};
```



#### [687. Longest Univalue Path](https://leetcode-cn.com/problems/longest-univalue-path/)

Given the `root` of a binary tree, return *the length of the longest path, where each node in the path has the same value*. This path may or may not pass through the root.

**The length of the path** between two nodes is represented by the number of edges between them.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg)

```c++
Input: root = [5,4,5,1,1,5]
Output: 2
```

```c++
class Solution {
public:
    int ans = 0;
    //return the length of the longest path from node:
    int dfs(TreeNode* node) { 
        if (!node) return 0;
        int left = dfs(node->left); 
        int right = dfs(node->right);
        int arrowLeft = 0;  
        int arrowRight = 0; 
        if (node->left && node->left->val == node->val) 
            arrowLeft = left + 1; 
        if (node->right && node->right->val == node->val) 
            arrowRight = right+ 1;
        // why not +1 here, bc 3 nodes length==2;
        ans = max(ans, arrowLeft + arrowRight);
        // why not use left or right instead: 
        // only count when have same value:
        return max(arrowLeft, arrowRight);
    } 
    int longestUnivaluePath(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return ans;
    }
};
```



#### [814. Binary Tree Pruning](https://leetcode-cn.com/problems/binary-tree-pruning/)

Given the `root` of a binary tree, return *the same tree where every subtree (of the given tree) not containing a* `1` *has been removed*. A subtree of a node `node` is `node` plus every node that is a descendant of `node`.

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png)

```c++
Input: root = [1,null,0,0,1]
Output: [1,null,0,null,1]
Explanation: 
Only the red nodes satisfy the property "every subtree not containing a 1".
The diagram on the right represents the answer.
```

```c++
class Solution {
public:
    // check if subtree node has 1;
    bool containsOne(TreeNode* node) {
        if (node == nullptr) return false;
        // recursion in left and right subtree
        bool a1 = containsOne(node->left);
        bool a2 = containsOne(node->right);
        if (!a1) node->left = nullptr;
        if (!a2) node->right = nullptr;
        // only return true when both cur and children are 1s;
        return node->val == 1 || a1 || a2;
    }
    TreeNode* pruneTree(TreeNode* root) {
        return containsOne(root) ? root : nullptr;
    }
};
```



#### [938. Range Sum of BST](https://leetcode-cn.com/problems/range-sum-of-bst/)

Given the `root` node of a binary search tree and two integers `low` and `high`, return *the sum of values of all nodes with a value in the **inclusive** range* `[low, high]`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)

```c++
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
```

```c++
class Solution {
public:
    int rangeSumBST(TreeNode* root, int L, int R){
        if(!root) return 0;
        if(root->val > R) return rangeSumBST(root->left, L, R);
        else if(root->val < L) return rangeSumBST(root->right, L, R);
        else return root->val
            +rangeSumBST(root->left, L, R)
            +rangeSumBST(root->right, L, R);
    }
};
```



#### [951. Flip Equivalent Binary Trees](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/)

For a binary tree **T**, we can define a **flip operation** as follows: choose any node, and swap the left and right child subtrees. A binary tree **X** is *flip equivalent* to a binary tree **Y** if and only if we can make **X** equal to **Y** after some number of flip operations. Given the roots of two binary trees `root1` and `root2`, return `true` if the two trees are flip equivelent or `false` otherwise.

**Example 1:**

![Flipped Trees Diagram](https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png)

```c++
Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.
```

```c++
class Solution {
public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if (root1 == root2) return true;
        if (!root1 || !root2 || root1->val != root2->val){
            return false;
        } 
        // either left match left and righr match righr
        // or left match right and righr match left
        return (flipEquiv(root1->left, root2->left) 
             && flipEquiv(root1->right, root2->right)
             || flipEquiv(root1->left, root2->right) 
             && flipEquiv(root1->right, root2->left));
    }
};
```



#### 968. Binary Tree Cameras](https://leetcode-cn.com/problems/binary-tree-cameras/)

You are given the `root` of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return *the minimum number of cameras needed to monitor all nodes of the tree*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png)

```c++
Input: root = [0,0,null,0,0]
Output: 1
Explanation: One camera is enough to monitor all nodes if placed as shown.
```

```c++
class Solution {
public:
    int ans = 0;
    int minCameraCover(TreeNode* root) {
        // if dfs(root)==0 means root need to put camera.
        return dfs(root) == 0 ? ans+1 : ans; 
    } 
    // if root is covered:
    // return 0: covered by children
    // return 1: covered by father
    // return 2: covered by new camera
    int dfs(TreeNode* root){
        // treat nullptr as covered by father
        if(root==nullptr) return 1;
        int left = dfs(root->left);
        int right = dfs(root->right);
        // (1) if one of the left or right is 0,then need camera:
        if(left==0 || right==0){
            ans++; 
            return 2;
        }
        // (2) left == right == 1: all covered, no camera
        if(left==1 && right==1){
            return 0;
        }
        return 1; // covered by father
    }
};
```







#### [979. Distribute Coins in Binary Tree](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/)

You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree. In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.Return *the **minimum** number of moves required to make every node have **exactly** one coin*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/01/18/tree1.png)

```c++
Input: root = [3,0,0]
Output: 2
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.
```

```c++
class Solution {
public:
    // What ever there are coins more than 1 or less than 1
    // it will all take 1 steps
    int ans = 0;
    int dfs(TreeNode* node) {
        if (node == nullptr) return 0; 
        int L = dfs(node->left);
        int R = dfs(node->right);
        ans += abs(L) + abs(R);
        return node->val + L + R - 1;
    }
    int distributeCoins(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
```







#### [1120. Maximum Average Subtree](https://leetcode-cn.com/problems/maximum-average-subtree/)

Given the `root` of a binary tree, return *the maximum **average** value of a **subtree** of that tree*. Answers within `10-5` of the actual answer will be accepted. A **subtree** of a tree is any node of that tree plus all its descendants. The **average** value of a tree is the sum of its values, divided by the number of nodes.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/04/09/1308_example_1.png)

```c++
Input: root = [5,6,1]
Output: 6.00000
Explanation: 
For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.
For the node with value = 6 we have an average of 6 / 1 = 6.
For the node with value = 1 we have an average of 1 / 1 = 1.
So the answer is 6 which is the maximum.
```

```c++
class Solution {
public:
    double ans = 0;
    double maximumAverageSubtree(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // bootom-up: return <sum, nums>
    array<int, 2> dfs(TreeNode* root) {
        if(!root) return {0, 0};
        auto L = dfs(root->left);
        auto R = dfs(root->right);
        int sum = root->val + L[0] + R[0];
        ans = max(ans, sum / (1.0 + L[1] + R[1]));
        return {sum, 1 + L[1] + R[1]};
    }
};
```



#### [1145. Binary Tree Coloring Game](https://leetcode-cn.com/problems/binary-tree-coloring-game/)

Two players play a turn based game on a binary tree. We are given the `root` of this binary tree, and the number of nodes `n` in the tree. `n` is odd, and each node has a distinct value from `1` to `n`. Initially, the first player names a value `x` with `1 <= x <= n`, and the second player names a value `y` with `1 <= y <= n` and `y != x`. The first player colors the node with value `x` red, and the second player colors the node with value `y` blue. Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an **uncolored** neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.

You are the second player. If it is possible to choose such a `y` to ensure you win the game, return `true`. If it is not possible, return `false`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png)

```c++
Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
Output: true
Explanation: The second player can choose the node with value 2.
```

**Constraints:**

- The number of nodes in the tree is `n`.
- `1 <= x <= n <= 100`
- `n` is odd.
- 1 <= Node.val <= n
- All the values of the tree are **unique**.

```c++
    // parent
    //  / \
    //    (A)
    //    / \
    //   l   r
    // bc except the first pick, can only paint neighbors
    // so only three position to get most area: parent, l ,r:
    // check if any subtree or parent has nodes > n/2;
class Solution {
public:
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
        function<int(TreeNode*, int)> getNodes = [&](TreeNode* root, int x) {
            if (!root) return 0;
            int l = getNodes(root->left, x);
            int r = getNodes(root->right, x);
            if(root->val == x) {
                l_num = l;
                r_num = r;
            }
            return 1 + l + r;
        };
        getNodes(root, x);
        int parentNodes = n - (1 + l_num + r_num);
        return max(parentNodes, max(l_num, r_num)) > (n/2);
    }
private:
    int l_num;
    int r_num;
};
```



#### [1315. Sum of Nodes with Even-Valued Grandparent](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)

Given the `root` of a binary tree, return *the sum of values of nodes with an **even-valued grandparent***. If there are no nodes with an **even-valued grandparent**, return `0`. A **grandparent** of a node is the parent of its parent if it exists. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg)

```c++
Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 18
Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
```

```c++
class Solution {
public:
    // pass value flag: if father node is even number
    int ans = 0;
    void dfs(TreeNode* root, bool flag){
        if(!root) return;
        if(flag && root->left) ans += root->left->val; 
        if(flag && root->right) ans += root->right->val;
        if(root->val % 2 == 0) flag = true; 
        else flag = false; 
        dfs(root->left, flag);
        dfs(root->right, flag);
    }
    int sumEvenGrandparent(TreeNode* root) {
        if(!root) return 0;
        bool flag = true;
        if(root->val % 2 == 0) flag = true;
        else flag = false;
        // bc root has no father, so dfs from left,right subtree.
        if(root->left) dfs(root->left, flag);
        if(root->right) dfs(root->right, flag);
        return ans;
    }
};
```







#### [1367. Linked List in Binary Tree](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)

Given a binary tree `root` and a linked list with `head` as the first node. 

Return True if all the elements in the linked list starting from the `head` correspond to some *downward path* connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

 **Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png)**

```c++
Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
```

```c++
class Solution {
public:
    bool dfs(ListNode * head,TreeNode * root){
        if(!head) return true;
        if(!root) return false;
        if(root->val != head->val) return false;
        return dfs(head->next,root->left)
            || dfs(head->next,root->right);
    }
    bool isSubPath(ListNode* head, TreeNode* root) {
        if(!head) return true;
        if(!root) return false;
        if(head->val == root->val && dfs(head,root)) return true;
        return isSubPath(head,root->left)
            || isSubPath(head,root->right);
    }
};
```





#### [1448. Count Good Nodes in Binary Tree](https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/)

Given a binary tree `root`, a node *X* in the tree is named **good** if in the path from root to *X* there are no nodes with a value *greater than* X. Return the number of **good** nodes in the binary tree. 

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)**

```c++
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.
```

```c++
// normal recursion 
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, int max_value){
        if(!root) return;
        if(root->val >= max_value) ans++;
        dfs(root->left, max(max_value, root->val));
        dfs(root->right, max(max_value, root->val));
    }
    int goodNodes(TreeNode* root) {
        if(!root) return 0;
        dfs(root, root->val);
        return ans;
    }
};
```

## 5. BST:

### (1) Biggest  SubBST :  most nodes or biggest sum

#### [333. Largest BST Subtree](https://leetcode-cn.com/problems/largest-bst-subtree/) : most nodes

Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.

A **Binary Search Tree (BST)** is a tree in which all the nodes follow the below-mentioned properties:

- The left subtree values are less than the value of their parent (root) node's value.
- The right subtree values are greater than the value of their parent (root) node's value.

**Note:** A subtree must include all of its descendants.

**Follow up:** Can you figure out ways to solve it with O(n) time complexity?

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/10/17/tmp.jpg)**

```c++
Input: root = [10,5,15,1,8,null,7]
Output: 3
Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3.
```

```c++
class Solution {
public:
    int largestBSTSubtree(TreeNode* root) {
        return get<2>(dfs(root));
    }
    // tuple<min_val, max_val, nodes> in tree root:
    tuple<int, int, int> dfs(TreeNode* root) {
        // (1) why return min=INT_MAX, max=INT_MIN;
        // if (cur==nullptr) as left subtree:  max should < root->val;
        // if (cur==nullptr) as right subtree: min should > root->val;
        // node numbers shoul be 0;
        if (root == nullptr) return {INT_MAX, INT_MIN, 0};
        auto [lmin, lmax, lnum] = dfs(root->left);
        auto [rmin, rmax, rnum] = dfs(root->right);
        // (2) root is BST:
        if (lmax < root->val && root->val < rmin) {
            // for return value:
            // (1) why not just use lmin or rmax? for nullptr, lmin, rmax will be init valeue;
            // (2) nodes number will be just lnum+rnum+1;
            return {min(lmin, root->val), max(rmax, root->val), lnum + rnum + 1};
        }
        // (3) if cur tree is not BST: then will not be any of other BST's subtree,
        // so [INT_MIN, INT_MAX], but cur->left or cur->right maybe BST, 
        // so return max(lnum, rnum);
        return {INT_MIN, INT_MAX, max(lnum, rnum)};
    }
};
```



#### [1373. Maximum Sum BST in Binary Tree](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/) : biggest sum

Given a **binary tree** `root`, return *the maximum sum of all keys of **any** sub-tree which is also a Binary Search Tree (BST)*.

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png)

```c++
Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
```

```c++
class Solution {
public:
    int ans = 0;
    int maxSumBST(TreeNode* root) {
        dfs(root);
        return ans;
    }
    tuple<int, int, int> dfs(TreeNode* root) {
        if (root == nullptr) return {INT_MAX, INT_MIN, 0};
        auto [lmin, lmax, lnum] = dfs(root->left);
        auto [rmin, rmax, rnum] = dfs(root->right);
        if (lmax < root->val && root->val < rmin) {
            // bc we need to cnt max sum of BST, so we can not use max(0,lnum) to discard left subtree;
            ans = max(ans,lnum + rnum + root->val);
            return {min(lmin, root->val), max(rmax, root->val), lnum + rnum + root->val};
        }
        return {INT_MIN, INT_MAX, max(lnum, rnum)};
    }
};
```







### (2) BST Inorder

#### [99. Recover Binary Search Tree](https://leetcode-cn.com/problems/recover-binary-search-tree/)

You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. *Recover the tree without changing its structure*.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)

```c++
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.
```

```c++
class Solution {
public:
    TreeNode* x, *y, *pre = nullptr;
    // must be a node swap with one of his child: 
    void recoverTree(TreeNode* root) {
        if(root == nullptr) return;
        dfs(root);
        swap(x->val, y->val);
    }
    void dfs(TreeNode* root){
        if(!root) return ;
        dfs(root->left);
        // inorder:
        if(pre != nullptr){
            if(pre->val > root->val){
                y = root;
                // bc x is what we wanna swap, so x only change at 1st time;
                if(x == nullptr){
                    x = pre;
                }
            }
        }
        pre = root;
        dfs(root->right);
    }
};
```





#### [230. Kth Smallest Element in a BST](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

Given the `root` of a binary search tree, and an integer `k`, return *the* `kth` (**1-indexed**) *smallest element in the tree*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```c++
Input: root = [3,1,4,null,2], k = 1
Output: 1
```

```c++
// (1) method 1: recursion + BST inorder:
class Solution {
public:
    int n = 0;
    int ans = -1;
    // k <= num of nodes <= 10^4
    // node->val >= 0;
    void dfs(TreeNode* root,int k){
        if(!root || ans != -1) return;
        dfs(root->left, k);
        n++; 
        if(n==k) ans = root->val; 
        dfs(root->right, k); 
    }
    int kthSmallest(TreeNode* root, int k) {
        dfs(root,k);
        return ans;
    }
};
```



```c++
// (2) method 2: stack + iteration BST inorder
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> stk;
        // int ans = -1;
        int n = 0;
        TreeNode* cur = root;
        while(!stk.empty() || cur){
            // first trav and push left children, then inorder
            // (1) left
            while(cur){
                stk.push(cur);
                cur = cur->left;
            }
            // (2) root
            cur = stk.top(); stk.pop();
            n++;
            if(n == k) return cur->val;
            // (3) right
            cur=cur->right;
        }
        return 0;
    }
};
```



#### [270. Closest Binary Search Tree Value](https://leetcode-cn.com/problems/closest-binary-search-tree-value/)

Given the `root` of a binary search tree and a `target` value, return *the value in the BST that is closest to the* `target`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg)

```c++
Input: root = [4,2,5,1,3], target = 3.714286
Output: 4
```

```c++
// method 1: O(n) inorder traversal:
class Solution {
public:
    int last;
    double max_val = INT_MAX;
    int closestValue(TreeNode* root, double target) {
        if(root != nullptr){
            if(abs(target - root->val) <= max_val){
                max_val = abs(target-root->val);
                last = root->val;
            }
            closestValue(root->left,target);
            closestValue(root->right,target);
        }
        return last;
    }  
};
```

```c++
// (2) method 2: binary search: branch will only go only left or right, so TC will be O(h) = O(logn);
class Solution {
public:
    int closestValue(TreeNode* root, double target) {
        int ans = root->val;
        while(root)
        {
            if(abs(root->val - target) < abs(ans - target)){
                ans = root->val;
            }
            if(root->val == target) return target;
            else if(target < root->val)
            {
                root = root->left;
            }
            else root = root->right;
        }
        return ans;
    }
};
```



#### [285. Inorder Successor in BST](https://leetcode-cn.com/problems/inorder-successor-in-bst/)

Given the `root` of a binary search tree and a node `p` in it, return *the in-order successor of that node in the BST*. If the given node has no in-order successor in the tree, return `null. The successor of a node `p` is the node with the smallest key greater than `p.val`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG)

```c++
Input: root = [2,1,3], p = 1
Output: 2
Explanation: 1's in-order successor node is 2. Note that both p and the return value is of TreeNode type.
```

```c++
// BST inorder: TC: O(n)
public:
    TreeNode* ans = nullptr;
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        dfs(root, p);
        return ans;
    }
    void dfs(TreeNode* root, TreeNode* p){
        if(root == nullptr || ans != nullptr) return;
        dfs(root->left, p);
        if(ans ==nullptr && root->val > p->val){
            ans = root;
        }
        dfs(root->right, p);
    }
};
```



#### [510. Inorder Successor in BST II](https://leetcode-cn.com/problems/inorder-successor-in-bst-ii/)

Given a `node` in a binary search tree, return *the in-order successor of that node in the BST*. If that node has no in-order successor, return `null`.

The successor of a `node` is the node with the smallest key greater than `node.val`.

You will have direct access to the node but not to the root of the tree. Each node will have a reference to its parent node. Below is the definition for `Node`:

```
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
```

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/02/285_example_34.PNG)

```c++
Input: tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 13
Output: 15
```

```c++
class Solution {
public:
    Node* inorderSuccessor(Node* node) {
        // 1. if node has right subtree, return the bottom left node:
        if(node->right){
            node = node->right;
            while(node->left) node = node->left;
            return node;
        }
        /* 2. find next bigger grandparent node by parent:
        How to prove the first bigger grandparent node is the ans:
            (1) if successor is not in right subtree,node must be in successor's left subtree.
            (2) search by parent pointer, theh first bigger value will be successor.
        This can be proved by contradiction：
            Assume cur node is A:
            Assume the next bigger grandparent value B is not successor;
            Assume there is another A's grandparent C which C < B. 
            Then B must in C's right subtree, but A is child of B, so A in right subtree of C
            so A should > C, but we assume A < C, so the first bigger value will be successor.
        */
        else{
            while(node->parent && node->parent->val < node->val){
                node = node->parent;
            }
            // root->parent = nullptr, so if reach the root, means don't have
            return node->parent;
        }
    }
};
```



#### [783. Minimum Distance Between BST Nodes](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)

Given the `root` of a Binary Search Tree (BST), return *the minimum difference between the values of any two different nodes in the tree*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

```c++
Input: root = [4,2,6,1,3]
Output: 1
```

```c++
// BST inorder
class Solution {
public:
    int res = INT_MAX;
    TreeNode* pre = NULL;
    void inOrder(TreeNode* root){
        if(!root) return;
        inOrder(root->left);
        if(pre) res = min(res, root->val - pre->val);
        pre = root; 
        inOrder(root->right);
    }
    int minDiffInBST(TreeNode* root) {
        inOrder(root);
        return res;
    }
};
```





#### [98. Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)

Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

A **valid BST** is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```c++
Input: root = [2,1,3]
Output: true
```

```c++
// method 1: BST inorder:
class Solution {
public:
    long long pre = LONG_MIN;
    bool flag = true;
    bool isValidBST(TreeNode* root) {
        dfs(root);
        return flag;
    }
    void dfs(TreeNode* root){
        if(!root || !flag) return;
        dfs(root->left);
        // (1) check and update flag
        if(root->val <= pre) flag = false;
        // (2) update pre;
        pre = root->val;
        dfs(root->right);
    }
};
```

```c++
// (2) BST + binary search
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root, INT_MIN, INT_MAX);
    }
    bool dfs(TreeNode* root, long long min_val, long long max_val){
        if(!root) return true;
        if(root->val < min_val || root->val > max_val) return false;
        return dfs(root->left, min_val, root->val-1ll) 
            && dfs(root->right, root->val+1ll, max_val); 
    }
};
```



### (3) BST + Binary Search:

#### [108. Convert Sorted Array to Binary Search Tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a **height-balanced** binary search tree*.

A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```c++
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
```

```c++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.empty()) return NULL;
        return generateTree(nums, 0, nums.size() - 1);
    }
    // mid=(l+r)/2; use mid as root to build BST:
    TreeNode* generateTree(vector<int>& nums, int l, int r){
        if(l > r)   return NULL; /// if not node in [l,r], means nullptr;
        int mid = l + ((r - l) >>1);
        TreeNode* root = new TreeNode(nums[mid]);
        root -> left = generateTree(nums, l, mid - 1);
        root -> right = generateTree(nums, mid + 1, r);
        return root;
    }
};
```



#### [700. Search in a Binary Search Tree](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

You are given the `root` of a binary search tree (BST) and an integer `val`.

Find the node in the BST that the node's value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)

```c++
Input: root = [4,2,7,1,3], val = 2
Output: [2,1,3]
```

```c++
// BST: Binary Search
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val == val) return root;
        return root->val > val 
            ? searchBST(root->left, val) 
            : searchBST(root->right, val);
    }
};
```



#### [701. Insert into a Binary Search Tree](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

You are given the `root` node of a binary search tree (BST) and a `value` to insert into the tree. Return *the root node of the BST after the insertion*. It is **guaranteed** that the new value does not exist in the original BST.

**Notice** that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return **any of them**.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)

```c++
Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:
```

```c++
// recurson:
// (1) if (val > root->val) : val should insert into root->right
//(2)  else if (val > root->val) val should insert into root->right
//(3) else insert here,.
class Solution {
public:
   
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (!root) return new TreeNode(val); 
        if (val > root->val) root->right = insertIntoBST(root->right, val);
        else root->left = insertIntoBST(root->left, val);
        return root;
    }
};
```

```c++
//  (2) method 2: stack + iteration:
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = root;
        while (node != nullptr) 
        { // insert into the right subtree
            if (val > node->val) { // insert right now
                if (node->right == nullptr) {
                    node->right = new TreeNode(val);
                    return root;
                }
                else node = node->right;
            }
            else { // insert into the left subtree
                if (node->left == nullptr) {// insert right now
                    node->left = new TreeNode(val);
                    return root;
                }
                else node = node->left;
            }
        }
        // if tree is empty at first, insert directly:  new TreeNode(val)
        return new TreeNode(val);
    }
};
```



#### [653. Two Sum IV - Input is a BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

Given the `root` of a Binary Search Tree and a target number `k`, return *`true` if there exist two elements in the BST such that their sum is equal to the given target*. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg)

```c++
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
```

```c++
class Solution {
public:
    // BST inorder + Two Sum
    unordered_map<int, int> mp;
    bool ans = false;
    void dfs(TreeNode* root, int target){  
        if(!root) return;
        dfs(root->left, target);
        // check first , then update mp, for cases like: 2+2=4 with only one 2:
        if(mp.find(target - root->val) != mp.end()){ 
            ans = true; 
            return; 
        }  
        mp[root->val]++;  
        dfs(root->right, target);
    }
    bool findTarget(TreeNode* root, int target){
        if(!root) return false; 
        dfs(root, target);
        return ans;
    }
};
```



#### [669. Trim a Binary Search Tree](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lies in `[low, high]`. Trimming the tree should **not** change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a **unique answer**.

Return *the root of the trimmed binary search tree*. Note that the root may change depending on the given bounds.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

```c++
Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]
```

```c++
class Solution {
public:
    // recursion f means the result of trim a tree:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return root;
        //  (1)if root->val > R means all the elements in right subtree is out of bound
        // the result should be trimBST(root->left)
        if (root->val > R) return trimBST(root->left, L, R);
        //  (2)if root->val > R means all the elements in right subtree is out of bound
        // the result should be trimBST(root->right)
        if (root->val < L) return trimBST(root->right, L, R);
        root->left = trimBST(root->left, L, R);
        root->right = trimBST(root->right, L, R);
        return root;
    }   
};
```



#### [173. Binary Search Tree Iterator](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST):

- `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
- `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.
- `int next()` Moves the pointer to the right, then returns the number at the pointer.

Notice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.

You may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)

```c++
Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
```

```c++
// method 1: BST inorder:
// O(n) space but O(1) search time;
class BSTIterator {
private:
    vector<int> nodes;
    int idx; 
public:
    void dfs(TreeNode* root){
        if(root == nullptr) return;
        // inorder: left->root->right
        dfs(root->left);
        nodes.push_back(root->val);
        dfs(root->right);
    }
    BSTIterator(TreeNode* root) {
        dfs(root); // init nodes
        idx = 0; // init idx in nodes
    }
    
    /** @return the next smallest number */
    int next() {
        if(idx >= nodes.size()) return -1;
        return nodes[idx++];
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        // if idx is beyond the vector size
        return (idx <= nodes.size()-1);
    }
};

```

```c++

// (2) method 2: binary search:
// O(h) space and O(1) search time;
class BSTIterator {
private:
    vector<TreeNode*> left_chain;
public:
    BSTIterator(TreeNode* root) {
        // S.back() is the smallest;
        while(root){
            left_chain.push_back(root);
            root = root->left;
        }
    }
    /** @return the next smallest number */
    int next() {
        TreeNode* t = left_chain.back(); left_chain.pop_back();
        int val = t->val; // save for return, bc t will be changed
        // next smallest one is the bottom-left of cur node's right child
        t = t->right;
        while(t){
            left_chain.push_back(t);
            t = t->left;
        }
        return val;
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        // if idx is beyond the vector size
        return !left_chain.empty();
    }
};
```











#### [450. Delete Node in a BST](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

1. Search for a node to remove.
2. If the node is found, delete the node.

**Follow up:** Can you solve it with time complexity `O(height of tree)`?

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```c++
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.
```

```c++
class Solution {
public:
    // return the root after delete key in root:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return nullptr;
        if (root->val < key) { 
            root->right = deleteNode(root->right, key);     
        }
        if (root->val > key) {
            root->left = deleteNode(root->left, key);       
        }
        else if(root->val == key){
            // else : root->val == key, means need to delete root:
            // (1) condition 1: if no left child
            if (!root->left) { 
                TreeNode* tmp = root->right; 
                delete root;
                return tmp; // return root->right
            }
            // (2) condition 2: if no right child
            if (!root->right) { 
                TreeNode* tmp = root->left;    
                delete root;
                return tmp; // return root->right
            }
            // (3) condition 3: if have both children:
            // find smallest value in root's right subtree:
            TreeNode* tmp = root->right;
            while (tmp->left) tmp = tmp->left;  
            // swap value of root and this value
            swap(root->val, tmp->val);
            root->right = deleteNode(root->right, key);
        }
        return root;
    }
};
```





#### [538. Convert BST to Greater Tree](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.

As a reminder, a *binary search tree* is a tree that satisfies these constraints:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

**Note:** This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/05/02/tree.png)

```c++
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

```c++
// post Order: right->root->left and kind of like prefix Sum:
class Solution {
public:
    int last = 0;
    TreeNode* convertBST(TreeNode* root) {
        if(root){
            convertBST(root->right);
            root->val += last;
            last = root->val;
            convertBST(root->left);
            return root;
        }
        return nullptr;
    }
};
```



## 6. Tree Traversal:

#### [430. Flatten a Multilevel Doubly Linked List](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)

You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.

 **Example 1:**

```c++
Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
Output: [1,2,3,7,8,11,12,9,10,4,5,6]
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;
};
*/
Explanation:
The multilevel linked list in the input is as follows:
```

![img](https://assets.leetcode.com/uploads/2018/10/12/multilevellinkedlist.png)

```c++
After flattening the multilevel linked list it becomes:
```

![img](https://assets.leetcode.com/uploads/2018/10/12/multilevellinkedlistflattened.png)

```c++
// (1) method 1: preorder + recursion
class Solution {
public:
    Node* last;
    // preorder + change pointers
    Node* flatten(Node* head) {
        if(head == nullptr) return nullptr;
        // connect cur to last node, and set node->child to nullptr;
        if(last != nullptr) {
            last->next = head;
            head->prev = last;
            last->child = nullptr;
        }
        last = head; // update node to last processed node
        // preorder travs: but head may change in flattern(head->child), so save nextNode;
        // e.g. in example 1: after flatten(3), 3->next is 7 not 4.
        Node* nextNode = head->next;
        flatten(head->child);
        flatten(nextNode);
        return head;
    }
};
```

```c++
// (2) method 2: preorder + iteration
class Solution {
public:
    Node* flatten(Node* head) {
        Node* cur = head;
        stack<Node*> stk;
        while(cur != nullptr) {
            // (1) if has child:
            if(cur -> child != nullptr) {
                if(cur -> next != nullptr) {
                    stk.push(cur -> next);
                }
                Node* child = cur -> child;
                // flatten
                cur -> next = child;
                child -> prev = cur;
                // remove cur's child
                cur -> child = nullptr;
            }
            // (2) if no next and stk is not empty: connect to stk.top();
            else if(cur -> next == nullptr && !stk.empty()) {
                Node* next = stk.top(); stk.pop();
                cur -> next = next;
                next -> prev = cur;
            }
            // move cur to next node:
            cur = cur -> next;
        }
        return head;
    }
};
```

