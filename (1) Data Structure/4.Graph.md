[TOC]



# Union-find

#### Union-find Template

```c++
// Union-find Template：
// Used for Dynamic connectivity of graphs:
// (1) check if there is loop in graph:
// (2) min spanning tree 
class UF{
public:
	int count;
	
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};
```



#### [261. Graph Valid Tree](https://leetcode-cn.com/problems/graph-valid-tree/) **: check if graph is valid tree**

**Need to fulfill two rules:**

**(1) no loop**

**(2) all nodes are connected:**

```c++
class UF{
public:
	
	int count;         // 记录连通分量
	vector<int> parent;// 节点x的节点是parent[x]
	vector<int> size;  // 每个以i为根的树的节点数量;
	// 构造函数，n为图的节点总数
	UF(int n){ // 一开始互不连通
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = i;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};

class Solution {
public:
    // graph with no loop is valid tree
    bool validTree(int n, vector<vector<int>>& edges) 
    {
        UF uf(n);
        for (auto edge: edges)
        {
            int x = edge[0], y = edge[1];
            if (!uf.Union(x, y))    
                return false;            
            
        }
        return uf.count == 1;
    }
};
```





#### [305. Number of Islands II](https://leetcode-cn.com/problems/number-of-islands-ii/) **:  2D matrix to 1D with union-find**

```c++
class UF{
public:
    vector<int> size;  
    vector<int> parent; 
    UF(int n){ 
        parent.resize(n);
        size.resize(n);
        for(int i = 0; i < n; i++){
            parent[i] = i;
            size[i] = 1;
        }
    }
    bool Union(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ) return false;
        if(size[rootP] >= size[rootQ]){
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }
        else{
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        return true;
    }
    int find(int x){
        while(parent[x]!=x){
            parent[x] = parent[parent[x]];// path compress
            x = parent[x];
        }
        return x;
    }
};
class Solution {
public:
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
        // convert 2 dimension to 1 dimension:
        // (i, j) to (i*n+j) n is column!!!
        int size = m * n;
        vector<vector<int>> grid(m, vector<int>(n));
        vector<int> ans;
        UF uf(size);
        int islands = 0;
        for(auto & pos: positions){
            int x = pos[0], y = pos[1];
            // if cur node is already be put, add ans directly
            if(grid[x][y] == 1){
                ans.push_back(islands); continue;
            }
            int idx =  x * n + y;
            uf.parent[idx] = idx; // set new node itself as parent
            grid[x][y] = 1;
            int merge = 0;
            for(int i = 0; i < 4; i++){
                int a = x + dx[i], b = y + dy[i];
                if(a>=0 && a < m && b >= 0 && b < n && grid[a][b]==1){
                    int adj = a * n + b; // need to convert to 1 dimension
                    if(uf.Union(idx, adj) == false) continue;
                    // every merge will decrease one island, so save merge：
                    merge++; 
                }
            }
            // so after check four neighbors, islands-merge, + 1 bc put a new island in:
            islands = islands - merge + 1;
            ans.push_back(islands);
        }
        return ans;
    }
};
```



#### [323. Number of Connected Components in an Undirected Graph](https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/) **: Count**

```c++
class UF{
public:
    vector<int> parent;
    vector<int> size;
    int count;

    UF(int n){
        parent.resize(n);
        size.resize(n);
        for(int i = 0; i < n; i++){
            parent[i] = i;
            size[i] = 1;
        }
        count = n;
    }
    
    int Find(int x){
        while(x != parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    bool Union(int p, int q){
        int rootP = Find(p);
        int rootQ = Find(q);
        if(rootP == rootQ) return false;
        if(size[rootP] >= size[rootQ]){
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }else{
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
        return true;
    }
};

class Solution {
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        UF uf(n);
        for(auto edge: edges){
            uf.Union(edge[0], edge[1]);
        }
        return uf.count;
    }
};
```



#### [399. Evaluate Division](https://leetcode-cn.com/problems/evaluate-division/)

````c++
class UnionFind {
private:
    vector<int> parent;  
    vector<double> weight; // weight point to parent
public:
    UnionFind(int n) {
        parent.resize(n);
        weight.resize(n, 1.0); // weight init as 1 
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (x != parent[x]) {
            int origin = parent[x];
            parent[x] = find(parent[x]); 
            weight[x] *= weight[origin];
        }
        return parent[x];
    }
    // 返回除法结果。如果两个值不存在则-1
    double isConected(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        // if two value has same root, can calculate, or return -1;
        if (rootX == rootY) {
            return weight[x] / weight[y];
        } else {
            return -1.00000;
        }
    }
    void myunion(int x, int y, double value) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return; // has same root
        }
        // make numerator points to root == weight[denominator]*value/ weight[numerator]
        parent[rootX] = rootY;
        // weight[x] is the weight from x to its root:
        // so from rootX to rootY(weight[y]) need to * value/ weight[x];
        weight[rootX] = weight[y] * value / weight[x];
    }
};
class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        // (1) build 
        int equationsSize = equations.size();
        UnionFind uf(2 * equationsSize);
        // bc not all single letters, so can not use letter-'a';
        map<string, int> hashMap;
        int id = 0;
        for (int i = 0; i < equationsSize; ++i) {
            // Numerator, denominator, value
            string var1 = equations[i][0];
            string var2 = equations[i][1];
            if (!hashMap.count(var1)) {
                hashMap[var1] = id;
                ++id;
            }
            if (!hashMap.count(var2)) {
                hashMap[var2] = id;
                ++id;
            }
            // connect Numerator and denominator by value
            uf.myunion(hashMap[var1], hashMap[var2], values[i]);
        }
        // (2) query
        int queriesSize = queries.size();
        vector<double> res(queriesSize, -1.00000);
        for (int i = 0; i < queriesSize; ++i) {
            string var1 = queries[i][0];
            string var2 = queries[i][1];
            // only calculate when two letters connect by equation: else return -1.00000
            if (hashMap.count(var1) && hashMap.count(var2)) {
                res[i] = uf.isConected(hashMap[var1], hashMap[var2]);
            }
        }
        return res;
    }
};
````



#### [547. Number of Provinces](https://leetcode-cn.com/problems/number-of-provinces/)  **same as 323**

```c++
class UF{
public:
    vector<int> parent;
    vector<int> size;
    int count;

    UF(int n){
        parent.resize(n);
        size.resize(n);
        for(int i = 0; i < n; i++){
            parent[i] = i;
            size[i] = 1;
        }
        count = n;
    }
    
    int Find(int x){
        while(x != parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    bool Union(int p, int q){
        int rootP = Find(p);
        int rootQ = Find(q);
        if(rootP == rootQ) return false;
        if(size[rootP] >= size[rootQ]){
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }else{
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
        return true;
    }
};
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        if(isConnected.empty()||isConnected[0].empty()) return -1;
        int n = (int) isConnected.size();
        UF uf(n);
        for(int i = 0; i  < (int)isConnected.size(); i++){
            for(int j = 0; j < (int)isConnected[0].size(); j++){
                if(isConnected[i][j] == 1)
                    uf.Union(i, j);
            }
        }
        return uf.count;
    }
};
```



#### [684. Redundant Connection](https://leetcode-cn.com/problems/redundant-connection/)

In this problem, a tree is an **undirected graph** that is connected and has no cycles.

You are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.

Return *an edge that can be removed so that the resulting graph is a tree of* `n` *nodes*. If there are multiple answers, return the answer that occurs last in the input.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)

```c++
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
```

 **Constraints:**

- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= ai < bi <= edges.length`
- `ai != bi`
- There are no repeated edges.
- The given graph is connected.

```c++
// Union-find Template：
class UF{
public:
	int count;
	
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
		int n = edges.size();
        UF uf(n+1);
        for(auto e : edges){
            int p = e[0];
            int q = e[1];
            if(! uf.Union(p, q)){
                return e;
            }
        }
        return {};
    }
};
```

#### [685. Redundant Connection II](https://leetcode-cn.com/problems/redundant-connection-ii/)

难度困难266

In this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.

The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.

The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.

Return *an edge that can be removed so that the resulting graph is a rooted tree of* `n` *nodes*. If there are multiple answers, return the answer that occurs last in the given 2D-array.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg)

```c++
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg)

```c++
Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
Output: [4,1]
```



**Constraints:**

- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= ui, vi <= n`
- `ui != vi`

```c++
// Union-find Template：
// Used for Dynamic connectivity of graphs:
// (1) check if there is loop in graph:
// (2) min spanning tree 
class UF{
public:
	int count;
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]]; 
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};
class Solution {
public:
    // find the last edge that makes the loop
    vector<int> getRemoveEdge(const vector<vector<int>>& edges) {
        int n = edges.size();
        UF uf(n+1);
        for (int i = 0; i < n; i++) {  
            if (!uf.Union(edges[i][0], edges[i][1])) {  
                return edges[i];
            }
        }
        return {};
    }

    // check if still a tree after remove the edge
    bool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {
        int n = edges.size();
        UF uf(n+1);
        for (int i = 0; i < n; i++) {
            if (i == deleteEdge) continue;
            if (!uf.Union(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树
                return false;
            }
        }
        return true;
    }

    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n = edges.size();  
        vector<int> inDegree (n+1, 0); // has to be n+1, bc 1-index !!!!
        for (int i = 0; i < n; i++) {
            inDegree[edges[i][1]]++; 
        }
        vector<int> vec; 
        // bcof the additional nodes, so there will be one node that indegree==2
        // or there is a loop
        for (int i = n - 1; i >= 0; i--) 
            if (inDegree[edges[i][1]] == 2) 
                vec.push_back(i);
        // (1) if there are indegree==2:
        if (vec.size() > 0) {
            if (isTreeAfterRemoveEdge(edges, vec[0])) {
                return edges[vec[0]];
            } else {
                return edges[vec[1]];
            }
        }
        // otherwise there will be a loop
        return getRemoveEdge(edges);

    }
};
```



#### [765. Couples Holding Hands](https://leetcode-cn.com/problems/couples-holding-hands/)

There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands. The people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`. Return *the minimum number of swaps so that every couple is sitting side by side*. A swap consists of choosing any two people, then they stand up and switch seats.

**Example 1:**

```c++
Input: row = [0,2,1,3]
Output: 1
Explanation: We only need to swap the second (row[1]) and third (row[2]) person.
```

**Example 2:**

```c++
Input: row = [3,2,0,1]
Output: 0
Explanation: All couples are already seated side by side.
```

**Constraints:**

- `2n == row.length`
- `2 <= n <= 30`
- `n` is even.
- `0 <= row[i] < 2n`
- All the elements of `row` are **unique**.

```c++
// Union-find Template：
// Used for Dynamic connectivity of graphs:
// (1) check if there is loop in graph:
// (2) min spanning tree 
class UF{
public:
	int count;
	
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};

class Solution {
public:
    int minSwapsCouples(vector<int>& row) {
        int n = row.size(), m = n / 2; // m is number of couples
        UF uf(n);
        for (int i = 0; i < n; i += 2){
            uf.Union(row[i] / 2, row[i + 1] / 2);
        } 
        int matched = 0;
        for (int i = 0; i < m; i++) {
            if (i == uf.find(i)) matched++;
        }
        // unmatched = total couples - matched
        return m - matched;
    }
};
```



#### [990. Satisfiability of Equality Equations](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

```c++
class UF{
public:
	int count;
	vector<int> parent; 
	vector<int> size;  
	UF(int n){
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	int find(int x){
		while(parent[x]!=x){
			parent[x] = parent[parent[x]]; 
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they are connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        // use x-'a' to get numbers:
        UF uf(26); // init 26 letters
        // (1) connect all letters from "=="
        for(auto eq : equations){
            auto x = eq[0];
            auto y = eq[3];
            if(eq[1] == '='){
                uf.Union(x-'a', y - 'a');
            }
        }
        // (2) check if letters from "!=" are connected
        for(auto eq : equations){
            if(eq[1] == '!'){
                auto x = eq[0];
                auto y = eq[3];
                // if x and y are connected, return false:
                // means "!=" not right
                if(uf.connected(x-'a', y - 'a')) return false;
            }
        }
        return true;
    }
};
```



#### [1135. Connecting Cities With Minimum Cost](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/) **Kruskal + union-find**

```c++
class UF{
public:
	int count;
	
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};


class Solution 
{
public:
    int minimumCost(int N, vector<vector<int>>& connections) {
        //------------------ kruskal 算法
        // sort cost from small to big
        sort(connections.begin(), connections.end(), 
             [&](auto &a, auto &b) { return a[2] < b[2];});
        int ans = 0;
        UF uf(N);
        for(auto connection : connections){
            int x    = connection[0]-1;
            int y    = connection[1]-1;
            int cost = connection[2];
            if(uf.Union(x, y) == false) continue;
            ans += cost;
            // if all nodes are connected, return ans;
            if(uf.count == 1) return ans; 
        }
        return -1;
    }
};
```



#### [1202. Smallest String With Swaps](https://leetcode-cn.com/problems/smallest-string-with-swaps/)

You are given a string `s`, and an array of pairs of indices in the string `pairs` where `pairs[i] = [a, b]` indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given `pairs` **any number of times**. Return the lexicographically smallest string that `s` can be changed to after using the swaps.

**Example 1:**

```c++
Input: s = "dcab", pairs = [[0,3],[1,2]]
Output: "bacd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[1] and s[2], s = "bacd"
```

**Example 2:**

```c++
Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]
Output: "abcd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[0] and s[2], s = "acbd"
Swap s[1] and s[2], s = "abcd"
```

**Constraints:**

- `1 <= s.length <= 10^5`
- `0 <= pairs.length <= 10^5`
- `0 <= pairs[i][0], pairs[i][1] < s.length`
- `s` only contains lower case English letters.

```c++
// Union-find Template：
// Used for Dynamic connectivity of graphs:
// (1) check if there is loop in graph:
// (2) min spanning tree 
class UF{
public:
	int count;
	
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};
class Solution {
public:
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
        string ans = "";
        int n = s.size();
        vector<char> rs(n);
        UF uf(n);
        for (const auto& e : pairs) uf.Union(e[0], e[1]);
        // (1) build map for every connected parts:
        unordered_map<int, vector<int> > ump;
        for (int i = 0; i < n; i++) ump[uf.find(i)].push_back(i);
        // (2) sort one connected parts by alphabet
        for (auto& [parent, children] : ump) {
            vector<int> origin = children;
            sort(children.begin(), children.end(), [&](auto a, auto b) {
                return s[a] < s[b];
            });
            // (3) After sort the chars still need to be assigned to origin index:
            for (int i = 0; i < origin.size(); i++) { 
                rs[origin[i]] = s[children[i]];
            }
        }
        return string(rs.begin(), rs.end());
    }
};
```



#### [1319. Number of Operations to Make Network Connected](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

There are `n` computers numbered from `0` to `n-1` connected by ethernet cables `connections` forming a network where `connections[i] = [a, b]` represents a connection between computers `a` and `b`. Any computer can reach any other computer directly or indirectly through the network.

Given an initial computer network `connections`. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the *minimum number of times* you need to do this in order to make all the computers connected. If it's not possible, return -1.  

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png)**

```c++
Input: n = 4, connections = [[0,1],[0,2],[1,2]]
Output: 1
Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2020/01/02/sample_2_1677.png)**

```c++
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
Output: 2
```

**Constraints:**

- `1 <= n <= 10^5`
- `1 <= connections.length <= min(n*(n-1)/2, 10^5)`
- `connections[i].length == 2`
- `0 <= connections[i][0], connections[i][1] < n`
- `connections[i][0] != connections[i][1]`
- There are no repeated connections.
- No two computers are connected by more than one cable.

```c++
// (1) if cables are not enough, can not connect all
// (2) the minimum operations will be uf.count-1;
class UF{
public:
	int count;
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n; // init as n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};

class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        UF uf(n);
        int size = connections.size();
        // if the cables is not enough to connect all:
        if(size < n - 1) return -1;
        for(auto& c : connections){
            uf.Union(c[0], c[1]);
        }
        return uf.count - 1;
    }
}; 
```



#### [1579. Remove Max Number of Edges to Keep Graph Fully Traversable](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)

Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:

- Type 1: Can be traversed by Alice only.
- Type 2: Can be traversed by Bob only.
- Type 3: Can by traversed by both Alice and Bob.

Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return *the maximum number of edges you can remove, or return* `-1` *if it's impossible for the graph to be fully traversed by Alice and Bob.*

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/08/19/ex1.png)**

```c++
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
```

**Example 2:**

**![img](https://assets.leetcode.com/uploads/2020/08/19/ex2.png)**

```c++
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
```

**Example 3:**

**![img](https://assets.leetcode.com/uploads/2020/08/19/ex3.png)**

```c++
Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.
```

**Constraints:**

- `1 <= n <= 10^5`
- `1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
- `edges[i].length == 3`
- `1 <= edges[i][0] <= 3`
- `1 <= edges[i][1] < edges[i][2] <= n`
- All tuples `(typei, ui, vi)` are distinct.

```c++
```







#### [1631. Path With Minimum Effort](https://leetcode-cn.com/problems/path-with-minimum-effort/)

You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., **0-indexed**). You can move **up**, **down**, **left**, or **right**, and you wish to find a route that requires the minimum **effort**.

A route's **effort** is the **maximum absolute difference** in heights between two consecutive cells of the route.

Return *the minimum **effort** required to travel from the top-left cell to the bottom-right cell.*

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/04/ex1.png)

```c++
Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/10/04/ex2.png)

```c++
Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2020/10/04/ex3.png)

```c++
Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.
```

 

**Constraints:**

- `rows == heights.length`
- `columns == heights[i].length`
- `1 <= rows, columns <= 100`
- `1 <= heights[i][j] <= 106`

```c++
// Union-find Template：
// Used for Dynamic connectivity of graphs:
// (1) check if there is loop in graph:
// (2) min spanning tree 
class UF{
public:
	int count;
	
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){  // O(n)
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);  // O(logn)
		int rootQ = find(q);  // O(logn)
		if(rootP == rootQ) return false;
		// union two trees + 路径压缩优化：size小的树，接在size大的树上
		if(size[rootP] > size[rootQ]){
			parent[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}else{
			parent[rootP] = rootQ;
			size[rootQ] += size[rootP];
		}
		count--;
        return true;
	}
	// return root of x
	int find(int x){  // O(logn)
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){  // O(logn)
        return find(p) == find(q);
	}
};

class Solution {
public:
    // Total TC is  O(row * col * log(row * col)):
    int minimumEffortPath(vector<vector<int>>& heights) {
        int row = heights.size();
        int col = heights[0].size();
        // TC for building edges: 
        // edges : at most O(row * col * 2)
        vector<tuple<int, int, int>> edges; // <from, to, cost>
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                // hash: 2D to 1D
                int id = i * col + j;
                // add all edges: 
                // except first row and first col 
                if (i > 0) { 
                    // add the edge to the above block:
                    // so index of above block is id-col, cur is id:
                    edges.emplace_back(id - col, id, abs(heights[i][j] - heights[i - 1][j]));
                }
                if (j > 0) { 
                    // add the edge to the left block:
                    // so index of left block is id-1, cur is id:
                    edges.emplace_back(id - 1, id, abs(heights[i][j] - heights[i][j - 1]));
                }
            }
        }
        // sort: O(row * col * log(row * col))
        sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {
            return get<2>(e1) < get<2>(e2);
        });

        UF uf(row * col);
        int ans = 0;
        // Union-find = O(row * col * log(row*col))
        for (const auto [x, y, v]: edges) { 
            uf.Union(x, y); 
            // when start and end connected, the cost of the edge will be ans
            if (uf.connected(0, row * col - 1)) {
                ans = v;
                break;
            }
        }
        return ans;
    }
};
```



#### [1971. Find if Path Exists in Graph](https://leetcode-cn.com/problems/find-if-path-exists-in-graph/)

There is a **bi-directional** graph with `n` vertices, where each vertex is labeled from `0` to `n - 1` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. You want to determine if there is a **valid path** that exists from vertex `start` to vertex `end`. Given `edges` and the integers `n`, `start`, and `end`, return `true` *if there is a **valid path** from* `start` *to* `end`*, or* `false` *otherwise**.*

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png)

```c++
Input: n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2
Output: true
Explanation: There are two paths from vertex 0 to vertex 2:
- 0 → 1 → 2
- 0 → 2 
```

**Constraints:**

- `1 <= n <= 2 * 105`
- `0 <= edges.length <= 2 * 105`
- `edges[i].length == 2`
- `0 <= ui, vi <= n - 1`
- `ui != vi`
- `0 <= start, end <= n - 1`
- There are no duplicate edges.
- There are no self edges.

```c++
// Union-find Template：
// Used for Dynamic connectivity of graphs:
// (1) check if there is loop in graph:
// (2) min spanning tree 
class UF{
public:
	int count;
	vector<int> parent;// parent[x] is the parent or grandparent node of x
	vector<int> size; // size of the tree has root i;
	UF(int n){ 
		count = n;
        parent.resize(n);
        size.resize(n);
		for(int i = 0; i < n; i++){
			parent[i] = i;
			size[i] = 1;
		}
	}
	bool Union(int p, int q){
		int rootP = find(p);
		int rootQ = find(q);
		if(rootP == rootQ) return false;
		parent[rootQ] = rootP;
		count--;
        return true;
	}
	// return root of x
	int find(int x){
		// parent[root] == root
		while(parent[x]!=x){
			parent[x] = parent[parent[x]];// 路径压缩
			x = parent[x];
		}
		return x;
	}
	// if p,q has the same root, they r connected;
	bool connected(int p, int q){
        return find(p) == find(q);
	}
};

class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int start, int end) {
        UF uf(n);
        for(auto& e : edges){
            uf.Union(e[0], e[1]);
        }
        return uf.connected(start, end);
    }
};
```



# Topological sort:

```c++
topological sort: 排的是拓扑序，其实就是依赖关系，所以只有有向无环图才能拓扑排序。 
比如说编译的依赖会用到拓扑序，避免产生循环依赖，循环依赖的检测其实就是拓扑排序；
  
有向图有入度 和 出度的概念：
	如果存在一条有向边A->B， 则A增加了一个出度，B增加一个入度，每次只能选择入度为0的边
BFS：
1）每次让入度为0的课入队，是没有依赖的课；
2）然后逐个出列，出列代表着课被选，需要减小相关课的入度。
3）如果相关课的入度新变为0，安排它入列，再出列...直到没有入度为0的课可以入列

准备工作：
1）每门课的入度需要被记录，我们关心入度值的变化。
2）课程之间的依赖关系也要被记录，我们关心选当前课会减少哪些课的入度。
3）因此我们需要选择合适的数据结构，去存这些数据：
4）入度数组：课号 0， n-1作为索引，通过遍历的条件表，求出对应的初始入度。
5）邻接表： 用哈希表记录依赖关系： key：课号， value：依赖这门课的后续课（数组）;

怎么判断能否修完所有课？
1. BFS 结束时，如果仍有课的入度不为0，无法被选，完成不了所有课。否则，能找到一种顺序把所有课上完；
2. 或者：用一个变量 count 记录入列的顶点个数，最后判断 count 是否等于总课程数；

总结：拓扑排序问题
	根据依赖关系，构建邻接表、入度数组。
	选取入度为 0 的数据，根据邻接表，减小依赖它的数据的入度。
	找出入度变为 0 的数据，重复第 2 步。
	直至所有数据的入度为 0，得到排序，如果还有数据的入度不为 0，说明图中存在环。
```

#### [207. Course Schedule:  if can take all courses ?](https://leetcode-cn.com/problems/course-schedule/)

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

- For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return `true` if you can finish all courses. Otherwise, return `false`.

**Example 1:**

```c++
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
```

**Example 2:**

```c++
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
```

**Constraints:**

- `1 <= numCourses <= 105`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- All the pairs prerequisites[i] are **unique**.

```c++
class Solution {
public:
    bool canFinish(int n, vector<vector<int>>& pre) {
        // (1) indegree + adjacent list
        vector<vector<int>> adj(n, vector<int>());
        vector<int> indegree(n, 0);
        for(auto x : pre){
            indegree[x[0]]++;
            adj[x[1]].push_back(x[0]);
        }
        // (2) build and update queue: BFS
        queue<int> q;
        int courseCanTake = 0;
        // put all indegree==0 in queue:
        for(int i = 0; i < n; i++){
            if(indegree[i] == 0){
                q.push(i);
            }
        }
        // BFS
        while(!q.empty()){
            courseCanTake++;
            auto cur = q.front(); q.pop();
            // traversal all cur->adj
            for(int i = 0; i < adj[cur].size(); i++){
                indegree[adj[cur][i]]--;
                if(indegree[adj[cur][i]] == 0){
                    q.push(adj[cur][i]);
                }
            }
        }
        return courseCanTake == n;
    }
};
```



#### [210. Course Schedule II :   order of taking all courses](https://leetcode-cn.com/problems/course-schedule-ii/)

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

- For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return *the ordering of courses you should take to finish all courses*. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
```

**Example 2:**

```c++
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
```

**Example 3:**

```c++
Input: numCourses = 1, prerequisites = []
Output: [0] 
```

**Constraints:**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `ai != bi`
- All the pairs `[ai, bi]` are **distinct**.

```c++
class Solution {
public:
    // different from Course Schedule I:
    // (1) Including to check if can take all courses
    // (2) need order of taking all courses:
    // just need to add course during BFS:
    vector<int> findOrder(int n, vector<vector<int>>& pre) {
        vector<int> ans;
        // (1) indegree + adj list
        vector<vector<int>> adj(n, vector<int>());
        vector<int> indegree(n, 0);
        for(auto x : pre){ // take b before a: indegree[a]++;
            indegree[x[0]]++;
            adj[x[1]].push_back(x[0]);
        }
        // (2) build and update queue: BFS
        queue<int> q;
        int cnt = 0;
        for(int i = 0; i < n; i++){
            if(indegree[i] == 0){
                q.push(i);
            }
        }
        while(!q.empty()){
            cnt++;
            auto tmp = q.front(); q.pop();
            ans.push_back(tmp);
            for(int i = 0; i < adj[tmp].size(); i++){
                indegree[adj[tmp][i]]--;
                if(indegree[adj[tmp][i]] == 0){
                    q.push(adj[tmp][i]);
                }
            }
        }
        if(cnt == n) return ans;
        return {};
    }
};
```

#### [310. Minimum Height Trees](https://leetcode-cn.com/problems/minimum-height-trees/)

A tree is an undirected graph in which any two vertices are connected by *exactly* one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).

Return *a list of all **MHTs'** root labels*. You can return the answer in **any order**. The **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)

```c++
Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)

```c++
Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
```

**Constraints:**

- `1 <= n <= 2 * 104`
- `edges.length == n - 1`
- `0 <= ai, bi < n`
- `ai != bi`
- All the pairs `(ai, bi)` are distinct.
- The given input is **guaranteed** to be a tree and there will be **no repeated** edges.

```c++
class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1) return { 0 };
        if (n == 2) return { 0,1 };
        vector<int> indegree(n, 0); 
        vector<vector<int>> graph(n); 
        for(auto & e : edges){
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
            indegree[e[0]]++;
            indegree[e[1]]++;
        }
        queue<int> Q; 
        for (int i = 0; i < n; i++)
            if (indegree[i] == 1)
                Q.push(i);

        // the middle point of the longest path will be the ans
        // but when the path's length is odd, there is one possible root
        // when the path's length is even, there are two possible roots;
        // but at most two possible in total
        while (n > 2) {
            int cnt = Q.size();
            n -= cnt; // delete the number in queue at once, not one by one
            for(int j = 0; j < cnt; j++) {
                int cur = Q.front(); Q.pop();
                indegree[cur]--;
                // put all adjacent nodes that indegree==1 in queue:
                for (int i = 0; i < graph[cur].size(); i++) 
                    if (indegree[graph[cur][i]] != 0) 
                        if (-- indegree[graph[cur][i]] == 1)
                            Q.push(graph[cur][i]);
            }
        }
        vector<int> ans;
        while (!Q.empty()){
            ans.push_back(Q.front()); Q.pop();
        }
        return ans;
    }
};
```





#### [802. Find Eventual Safe States](https://leetcode-cn.com/problems/find-eventual-safe-states/)

There is a directed graph of `n` nodes with each node labeled from `0` to `n - 1`. The graph is represented by a **0-indexed** 2D integer array `graph` where `graph[i]` is an integer array of nodes adjacent to node `i`, meaning there is an edge from node `i` to each node in `graph[i]`. A node is a **terminal node** if there are no outgoing edges. A node is a **safe node** if every possible path starting from that node leads to a **terminal node**. Return *an array containing all the **safe nodes** of the graph*. The answer should be sorted in **ascending** order.

**Example 1:**

![Illustration of graph](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png)

```c++
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.
```

**Example 2:**

```c++
Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4. 
```

**Constraints:**

- `n == graph.length`
- `1 <= n <= 104`
- `0 <= graph[i].length <= n`
- `0 <= graph[i][j] <= n - 1`
- `graph[i]` is sorted in a strictly increasing order.
- The graph may contain self-loops.
- The number of edges in the graph will be in the range `[1, 4 * 104]`.

```c++
class Solution {
public:
    // reverse topological sort:
    // start from the terminal nodes and if a node's indegree can
    // be reduced to 0, means it all comes from the safe nodes:
    vector<int> eventualSafeNodes(vector<vector<int>> &graph) {
        int n = graph.size();
        // (1) build reverseGraph and indegree for it: 
        vector<vector<int>> rg(n);
        vector<int> inDeg(n);
        for (int x = 0; x < n; ++x) {
            for (int y : graph[x]) {
                rg[y].push_back(x);
            }
            inDeg[x] = graph[x].size();
        }
        // (2) topological sort using BFS:
        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if (inDeg[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int y = q.front();
            q.pop();
            for (int x : rg[y]) {
                if (--inDeg[x] == 0) {
                    q.push(x);
                }
            }
        }

        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            if (inDeg[i] == 0) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};
```



# Graph DFS & BFS:



#### [332. Reconstruct Itinerary](https://leetcode-cn.com/problems/reconstruct-itinerary/)

You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from `"JFK"`, thus, the itinerary must begin with `"JFK"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

- For example, the itinerary `["JFK", "LGA"]` has a smaller lexical order than `["JFK", "LGB"]`.

You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

```c++
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)

```c++
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.
```

 **Constraints:**

- `1 <= tickets.length <= 300`
- `tickets[i].length == 2`
- `fromi.length == 3`
- `toi.length == 3`
- `fromi` and `toi` consist of uppercase English letters.
- `fromi != toi`

```c++
class Solution {
public:
    vector<string> ans;
    unordered_map<string, priority_queue<string, vector<string>, greater<>>> ump;
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        // build map: <start, priority_queue<dests>>
        for(auto& x: tickets)  ump[x[0]].push(x[1]);
        dfs("JFK");
        // bc ans is reversed, so return reversed of ans
        return vector<string>(ans.rbegin(), ans.rend());
    }

    void dfs(string curr){
        // bc at least one valid itinerary and last dest has no next dests;
        // so we can find last node by this way and ans will be reversed;
        while(ump.count(curr) && ump[curr].size() > 0 ){
            // next will pop_back from ump after use:
            string next = ump[curr].top(); ump[curr].pop();
            dfs(next);
        }
        // only when curr do not have no next dests, push_back curr;
        ans.push_back(curr);
    }
};
```



#### [797. All Paths From Source to Target](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.

The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`). 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

```c++
Input: graph = [[1,2],[3],[3],[]]
Output: [[0,1,3],[0,2,3]]
Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

```c++
Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]
Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**Constraints:**

- `n == graph.length`
- `2 <= n <= 15`
- `0 <= graph[i][j] < n`
- `graph[i][j] != i` (i.e., there will be no self-loops).
- All the elements of `graph[i]` are **unique**.
- The input graph is **guaranteed** to be a **DAG**.

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        if(graph.empty()) return ans;
        path.push_back(0);
        dfs(graph, 0);
        return ans;
    }
    void dfs(vector<vector<int>>& graph, int pos){
        if(pos== graph.size()-1){
            ans.push_back(path);
            return ;
        }
        for(auto x : graph[pos]){
            path.push_back(x);
            dfs(graph, x);
            path.pop_back();
        }
    }
};
```

#### [841. Keys and Rooms](https://leetcode-cn.com/problems/keys-and-rooms/)

There are `n` rooms labeled from `0` to `n - 1` and all the rooms are locked except for room `0`. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.

When you visit a room, you may find a set of **distinct keys** in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.

Given an array `rooms` where `rooms[i]` is the set of keys that you can obtain if you visited room `i`, return `true` *if you can visit **all** the rooms, or* `false` *otherwise*.

**Example 1:**

```c++
Input: rooms = [[1],[2],[3],[]]
Output: true
Explanation: 
We visit room 0 and pick up key 1.
We then visit room 1 and pick up key 2.
We then visit room 2 and pick up key 3.
We then visit room 3.
Since we were able to visit every room, we return true.
```

**Example 2:**

```c++
Input: rooms = [[1,3],[3,0,1],[2],[0]]
Output: false
Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.
```

**Constraints:**

- `n == rooms.length`
- `2 <= n <= 1000`
- `0 <= rooms[i].length <= 1000`
- `1 <= sum(rooms[i].length) <= 3000`
- `0 <= rooms[i][j] < n`
- All the values of `rooms[i]` are **unique**.

```c++
class Solution {
public:
    int cnt = 0;
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();
        vector<int> visited(n, 0);
        dfs(rooms, 0, visited);
        return cnt == n; // check if can visit all rooms
    }
    void dfs(const vector<vector<int>> & rooms, int cur, vector<int>& visited){
        visited[cur] = 1;
        cnt++;
        for(int neigh : rooms[cur]){
            if(visited[neigh] == 0){
                dfs(rooms, neigh, visited);
            }
        }
    }
};
```









# Graph Painting:

#### [785. Is Graph Bipartite?](https://leetcode-cn.com/problems/is-graph-bipartite/)

There is an **undirected** graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:

- There are no self-edges (`graph[u]` does not contain `u`).
- There are no parallel edges (`graph[u]` does not contain duplicate values).
- If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).
- The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.

A graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.

Return `true` *if and only if it is **bipartite***. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)

```c++
Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.
```

**Constraints:**

- `graph.length == n`
- `1 <= n <= 100`
- `0 <= graph[u].length < n`
- `0 <= graph[u][i] <= n - 1`
- `graph[u]` does not contain `u`.
- All the values of `graph[u]` are **unique**.
- If `graph[u]` contains `v`, then `graph[v]` contains `u`.

```c++
class Solution {
public:
    // Paint method:
  	// For Bipartite: Any two nodes of a edge can be paint to two colors.
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> colors(n, -1);
        for (int i = 0; i< n; i++){
            if (colors[i] == -1){
                if (!dfs(graph, colors, i, 0))
                    return false;
            }
        }
        return true;
    }

    bool dfs(vector<vector<int>>& graph, vector<int>& colors,int index, int c){
        // (1) paint index as color c:
        colors[index] = c;
        for (int i = 0; i < graph[index].size(); i++) {
            int node = graph[index][i];
            if (colors[node] != -1){
                // two connected nodes can't be same color:
                if (colors[node] == c) return false;
            }
            // if neighbors are not painted, try to paint to 1-c;
            // if can't paint to 1-c, return false;
            else{
                if ( ! dfs(graph, colors, node, 1-c))
                    return false;
            }    
        }
        return true;
    }
};
```





#### [1042. Flower Planting With No Adjacent](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)

You have `n` gardens, labeled from `1` to `n`, and an array `paths` where `paths[i] = [xi, yi]` describes a bidirectional path between garden `xi` to garden `yi`. In each garden, you want to plant one of 4 types of flowers.

All gardens have **at most 3** paths coming into or leaving it.

Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.

Return ***any** such a choice as an array* `answer`*, where* `answer[i]` *is the type of flower planted in the* `(i+1)th` *garden. The flower types are denoted* `1`*,* `2`*,* `3`*, or* `4`*. It is guaranteed an answer exists.* 

**Example 1:**

```c++
Input: n = 3, paths = [[1,2],[2,3],[3,1]]
Output: [1,2,3]
Explanation:
Gardens 1 and 2 have different types.
Gardens 2 and 3 have different types.
Gardens 3 and 1 have different types.
Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1]. 
```

**Constraints:**

- `1 <= n <= 104`
- `0 <= paths.length <= 2 * 104`
- `paths[i].length == 2`
- `1 <= xi, yi <= n`
- `xi != yi`
- Every garden has **at most 3** paths coming into or leaving it.

```c++
class Solution {
public:
    vector<int> gardenNoAdj(int N, vector<vector<int>>& paths) {
        vector<vector<int>> G(N);
        for(auto& p : paths){
            G[p[0]-1].push_back(p[1]-1);
            G[p[1]-1].push_back(p[0]-1);
        }
        vector<int> answer(N,0);
        for(int i=0; i<N; i++){
            set<int> color{1,2,3,4};
            for (int j = 0; j < G[i].size(); j++){
                color.erase(answer[G[i][j]]);
            }
            answer[i]= *color.begin(); 
        }
        return answer;
    }
};
```



# Shortest path in Graph:



## 1. Floyd:    Any two nodes:

```c++
1. 特点：
(1) 可以求任意两个结点之间的最短路。
(2) 复杂度较高，但容易实现。
(3) 适用于任何图，不管有向无向，边权正负，但是最短路必须存在（不能有负环）。
2. 思路：
使用矩阵表示节点 u → v 之间的最短路径。
初始化时，w[i][i] 为0， w[i][j] 为边 i → j 的权重，没有边的元素设置为无穷大。
节点 i → j 可能通过 k 中转而缩短距离，遍历计算点 i → k → j 的路径，如果比现有的 i → j 小，则更新，即松弛操作。
3. 复杂度：
时间复杂度 O ( V^3 )
空间复杂度 O ( V^2 )
slow on sparse graph;
 
```

```c++
// Floyd template: 
for (int k = 0; k < n; k++) { // k must be in the outside:
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]); 
                }
            }
        }
```



## 2. Dijkstra :    Single source:

```c++
1. 特点：
(1) 求单源最短路径。
(2) 只适用于非负权图。
(3) 时间复杂度优秀。
(4) 使用了贪心思想。
(5) slower on dense, faster on sparse graph:
2. 步骤：
(1) 初始：
- 已确定最短路的节点为集合P，未确定最短路的节点为集合Q。
- 保存源节点 K 到每个节点的距离，初始化时距离为无穷大。
- 将源节点 K 放入Q，其距离为0。
(2) 循环：
- 从Q取出一个距离最短的节点 u，其最短路径已经确定，因此移到P（贪心思想，因为 K 到其他点的距离更远，不可能找到一个经过其他点再到 u 的更短路径）。
- 松弛 u 的未确定最短路的出节点，即判断经过 u 能否缩短距离。将这些节点放到Q中等待下一轮循环处理。
- 继续循环，直到Q为空。
3. 具体实现：
V is number of vertex, E is number of edges :
(1) for loop: 可以用 int 数组保存每个节点的距离，bool 数组表示节点是否已经加入到P。 
  TC: O(V*V)  SC: O(V*V)
(2) priority_queue as Q，这样每次取出距离最短节点时性能更好。
  TC: O(E^logV) SC: O(V + E)
  (i) for dense graph:   E = O(V ^ 2) 
  (ii) for sparse graph: E = O(V)    
```

```c++
// Dijkstra template:

    vector<int> Dijkstra(vector<vector<int>>& times, int N, int K) {
        vector<int> dis(N+1, -1); // dis[i] = distance from K to i;
        dis[K] = 0;
        typedef pair<int, int> Pair; // first is dis, second is target:
        priority_queue<Pair, vector<Pair>, greater<>> pq;
        pq.emplace(0, K); 
        // Dijkstra: use min edeg as middle to connect K and other nodes:
        while(!pq.empty()) {
            // pq.top() is the min edge to connect visited and unvisited:
            auto [min_dis, target] = pq.top(); pq.pop(); 
            // if min_dis > distarget, can not have smaller distance via target:
            if(min_dis > dis[target]) continue;
            // relax: push all target's neighbors to pq after relaxing; 
            for(auto& edge : times){
                if(edge[0] == target){ 
                    int v = edge[1]; // the other point on edges start from target
                    int w = min_dis + edge[2]; // w : dis from last -> target -> v;
                    if(dis[v] == -1 || dis[v] > w){
                        dis[v] = w;
                        pq.emplace(w, v); // <total dis, end point in path from K>
                    }
                }
            }
        }
        return dis;
    }

```



---

#### [743. Network Delay Time](https://leetcode-cn.com/problems/network-delay-time/)

You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target. We will send a signal from a given node `k`. Return the time it takes for all the `n` nodes to receive the signal. If it is impossible for all the `n` nodes to receive the signal, return `-1`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```c++
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
```

**Example 2:**

```c++
Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
```

**Example 3:**

```c++
Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
```

 **Constraints:**

- `1 <= k <= n <= 100`
- `1 <= times.length <= 6000`
- `times[i].length == 3`
- `1 <= ui, vi <= n`
- `ui != vi`
- `0 <= wi <= 100`
- All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)

```c++
// (1) method 1:
// Floyd: get shortest distance for any two nodes : O(N ^ 3);
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        vector<vector<int>> graph(N+1,vector<int>(N+1,INT_MAX/2));
        for(int i=1; i<=N; i++) graph[i][i]=0;  // to itself is 0 
        for(auto e : times) graph[e[0]][e[1]]=e[2]; // build graph
        // floyd template to get shortest path for any two nodes: O(N^3)
        // the middle node must in outside, bcof state compression dp:
        for(int k=1; k<=N; k++)
            for(int i=1; i<=N; i++)
                for(int j=1; j<=N;j++)
                        graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);
        
        int ans=0;
        // check if K can reach every other nodes + the longest delay time
        for(int i=1; i<=N; i++){
            if(graph[K][i]==INT_MAX/2) return -1;
            ans = max(ans, (int)graph[K][i]);
        }
        return ans;
    }
};
```

```c++
(2) method 2: Dijkstra: single source min_distance: 
O(N^2) using for loop;
O(N*logN) using priority_queue
```

```c++
// (2) Dijkstra using for loop: O(N^2) + visited;
// Good for dense graph:
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        vector<vector<int>> graph(N+1,vector<int>(N+1,INT_MAX/2));
        for(int i = 1; i <= N; i++) graph[i][i]=0;
        for(auto& e : times) graph[e[0]][e[1]]=e[2];
        vector<bool> visited(N+1, false); // true means finished calculate shortest distance
        visited[K]=true; // start from K:
        // Dijkstra:
        for(int i = 1; i < N; i++){ 
            // (1)  O(N) traversal to find the shortest unused edge and the id:
            int min_id = 0, min_dis = INT_MAX;  
            for(int j = 1; j <= N; j++){
                if(visited[j] == false && graph[K][j] < min_dis){
                    min_dis = graph[K][j];
                    min_id  = j;
                }
            }
            visited[min_id] = true; // marked as used:
            // (2) relax: O(N) traversal to get check if K to j can be shorter via min_id:
            for(int j = 1; j <= N; j++)
                if(graph[K][min_id] + graph[min_id][j] < graph[K][j])
                    graph[K][j] = graph[K][min_id] + graph[min_id][j];
        }
        int ans = 0;
        for(int i = 1; i <= N; i++){
            if(graph[K][i] == INT_MAX/2) return -1;
            ans = max(ans, (int)graph[K][i]);
        }
        return ans;
    }
};
```

```c++
// (2) Dijkstra using for priority_queue: O(N*logN) + dis[i];
// vector<int> dis(N+1, INT_MAX/2); // dis[i] = distance from K to i;
// dis[K]=0;
// Good for dense graph:
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        vector<int> dis(N+1, INT_MAX/2); // dis[i] = distance from K to i;
        dis[K]=0;
        typedef pair<int, int> Pair; // first is dis, second is target:
        priority_queue<Pair, vector<Pair>, greater<>> pq; // edges 
        pq.emplace(0, K); 
        // Dijkstra: use min edeg as middle to connect K and other nodes:
        while(!pq.empty()) {
            // pq.top() is the min edge to connect visited and unvisited:
            auto [min_dis, u] = pq.top(); pq.pop(); 
            // if min_dis > distarget, can not have smaller distance via target:
            if(min_dis > dis[u]) continue;
            // relax: push all u's neighbors to pq after relaxing; 
            for(auto& edge : times){
                if(edge[0] == u){ 
                    int v = edge[1]; // the other point on edges start from u
                    if(dis[v] == INT_MAX/2 || dis[v] > min_dis + edge[2]){
                        dis[v] = min_dis + edge[2];
                        pq.emplace(dis[v], v); // <total dis, end point in path from K>
                    }
                }
            }
        }
        
        int ans = 0;
        for(int i = 1; i <= N; i++){
            if(dis[i] == INT_MAX/2) return -1;
            ans = max(ans, dis[i]);
        }
        return ans;
    }
};
```



#### [1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.

Return the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities ***i*** and ***j*** is equal to the sum of the edges' weights along that path. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/01/16/find_the_city_01.png)

```c++
Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
Output: 3
Explanation: The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -> [City 1, City 2] 
City 1 -> [City 0, City 2, City 3] 
City 2 -> [City 0, City 1, City 3] 
City 3 -> [City 1, City 2] 
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/01/16/find_the_city_02.png)

```c++
Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
Output: 0
Explanation: The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -> [City 1] 
City 1 -> [City 0, City 4] 
City 2 -> [City 3, City 4] 
City 3 -> [City 2, City 4]
City 4 -> [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2. 
```

**Constraints:**

- `2 <= n <= 100`
- `1 <= edges.length <= n * (n - 1) / 2`
- `edges[i].length == 3`
- `0 <= fromi < toi < n`
- `1 <= weighti, distanceThreshold <= 10^4`
- All pairs `(fromi, toi)` are distinct.

```c++
// (1) method 1: Floyd: O(V^3)
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<vector<long>> graph(n, vector<long>(n, INT_MAX));
        // (1) build graph: 
        for (const auto& e : edges) {
            graph[e[0]][e[1]] = e[2];
            graph[e[1]][e[0]] = e[2];
        }
        // k must be in the outside: bc this is a State compression dp:
        for (int k = 0; k < n; k++) { 
            for (int i = 0; i < n; i++) {
                if(i == k || graph[i][k] == INT_MAX) continue;
                for (int j = i+1; j < n; j++) {
                    if(i != j){
                        graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]); 
                        graph[j][i] = graph[i][j];
                    }
                }
            }
        }
        int ans = 0, min_val = n;
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && graph[i][j] <= distanceThreshold) {
                    cnt ++;
                }
            }
            if (cnt <= min_val) {
                min_val = cnt;
                ans = i;
            }
        }
        return ans;  
    }
};
```

```c++
// (2) method 2: Dijkstra normal + Dijkstra + priority_queue:
class Solution {
public:
    void Dijkstra_pq(vector<vector<int>>& graph, vector<int>& dis, int n, int start) {
        typedef pair<int, int> Pair; // first is dis, second is target:
        priority_queue<Pair, vector<Pair>, greater<>> pq;
        dis[start] = 0;
        pq.emplace(0, start);
        while (! pq.empty()) {
            auto p = pq.top(); pq.pop();
            int u = p.second;
            if (dis[u] < p.first) continue;
            for (int v=0; v<n; ++v) {
                if (graph[u][v] != INT_MAX && dis[v]>dis[u]+graph[u][v]) {
                    dis[v] = dis[u] + graph[u][v];
                        pq.push({dis[v],v});
                }
            }
        }
    }
    void Dijkstra_normal(vector<vector<int>>& graph, vector<int>& dis, vector<bool>& visited, int n, int start) {
        dis[start] = 0; 
        for (int i=0; i<n; ++i) {
            int u, min_dis = INT_MAX;
            for (int j = 0; j < n; ++j) {
                if (!visited[j] && dis[j] < min_dis) {
                    u = j;
                    min_dis = dis[j];
                }
            }
            if (u == -1) return; // all nodes are not reachable
            visited[u] = true;
            for (int v = 0; v < n; ++v) {
                if (!visited[v] && graph[u][v] != INT_MAX) {
                    if (dis[u] + graph[u][v] < dis[v]) {
                        dis[v] = dis[u] + graph[u][v];
                    }
                }
            }
        }
    }
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<vector<int>>graph(n,vector<int>(n,INT_MAX)); 
        for (vector<int> edge : edges) {
            int u=edge[0], v=edge[1], w=edge[2];
            graph[u][v] = graph[v][u] = w;
        }
        int idx = -1, minCnt = INT_MAX;
        for (int i=0; i<n; ++i) {
            vector<int> dis(n,INT_MAX);  
            vector<bool> visited(n,false);
            // Dijkstra_normal(graph, dis, visited, n, i);
            Dijkstra_pq(graph, dis, n, i);
            int cnt = 0; 
            for (int j=0; j<n; ++j) {
                if (dis[j] <= distanceThreshold && i!=j) {
                    cnt++;
                }
            }
            // if multiple ans: return the city with the greatest number.
            // so update when equal:
            if (cnt <= minCnt) { 
                minCnt = cnt;
                idx = i;
            }
        }
        return idx;
    }
};
```



# Graph DP:

#### [787. Cheapest Flights Within K Stops](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`. 

You are also given three integers `src`, `dst`, and `k`, return ***the cheapest price** from* `src` *to* `dst` *with at most* `k` *stops.* If there is no such route, return `-1`. 

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)

```c++
Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Output: 200
Explanation: The graph is shown.
The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.
```

**Example 2:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)

```c++
Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
Output: 500
Explanation: The graph is shown.
The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.
```

 

**Constraints:**

- `1 <= n <= 100`
- `0 <= flights.length <= (n * (n - 1) / 2)`
- `flights[i].length == 3`
- `0 <= fromi, toi < n`
- `fromi != toi`
- `1 <= pricei <= 104`
- There will not be any multiple flights between two cities.
- `0 <= src, dst, k < n`
- `src != dst`

```c++
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        // f[t][i]: the min cost to reach i by t stops: 
        vector<vector<int>> f(k + 2, vector<int>(n, INT_MAX/2));
        f[0][src] = 0;
        int ans = INT_MAX/2;
        // traversal k stops: from 1 to k+1
        for (int t = 1; t <= k + 1; ++t) {
            for (auto&& flight: flights) {
                int from = flight[0], to = flight[1], cost = flight[2];
                // use less 1 stops to reach from + cost (from->to);
                f[t][to] = min(f[t][to], f[t - 1][from] + cost);
            }
            ans = min(ans, f[t][dst]);
        }
        return (ans == INT_MAX/2 ? -1 : ans);
    }
};
```



# Other graph problems:

#### [997. Find the Town Judge](https://leetcode-cn.com/problems/find-the-town-judge/)

In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then:

1. The town judge trusts nobody.
2. Everybody (except for the town judge) trusts the town judge.
3. There is exactly one person that satisfies properties **1** and **2**.

You are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. Return *the label of the town judge if the town judge exists and can be identified, or return* `-1` *otherwise*.

**Example 1:**

```c++
Input: n = 2, trust = [[1,2]]
Output: 2
```

**Example 2:**

```c++
Input: n = 3, trust = [[1,3],[2,3]]
Output: 3
```

**Example 3:**

```c++
Input: n = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1 
```

**Constraints:**

- `1 <= n <= 1000`
- `0 <= trust.length <= 104`
- `trust[i].length == 2`
- All the pairs of `trust` are **unique**.
- `ai != bi`
- `1 <= ai, bi <= n`

```c++
class Solution {
public:
    // traversal trust array:
    // (1) build beTrust map: the number of people who trust him
    // (2) build notJudge set: who trust others can't be judge;
    int findJudge(int N, vector<vector<int>>& trust) {
        // corner case:
        if(trust.empty()) return N == 1 ? 1 : -1;
        unordered_map<int, int> beTrust;
        unordered_set<int> notJudge;
        for(int i = 0; i < trust.size(); i++){
            beTrust[trust[i][1]]++;
            notJudge.insert(trust[i][0]);
        }
        for(auto& [k, v]: beTrust){
            if(v == N-1 && notJudge.find(k) == notJudge.end()){
                return k;
            }
        }
        return -1;
    }
};
```



#### [277. Find the Celebrity](https://leetcode-cn.com/problems/find-the-celebrity/)

Suppose you are at a party with `n` people (labeled from `0` to `n - 1`), and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know him/her, but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function `bool knows(a, b)` which tells you whether A knows B. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/02/277_example_1_bold.PNG)

```c++
Input: graph = [[1,1,0],[0,1,0],[1,1,1]]
Output: 1
Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.
```

```c++
/* The knows API is defined for you.
      bool knows(int a, int b); */

// Forward declaration of the knows API.
bool knows(int a, int b);

class Solution {
public:
    // (1) every one knows C, but C doesn't know everyone else
    // if knows(i,j) == ture，i can not be C 
    // if knows(i,j) == false，j can not be C
    // so call knows API once can exclude one person:
    // (2) but there may not have C, so need to extra check; 
    int findCelebrity(int n) {
        int i = 0; // potential Celebrity:
        for (int j = 1; j < n; ++j) {
            if (knows(i, j)) {
                // if i knows j, i cannot be celebrity:
                // so emplace i by j:
                i = j;
            }
        }
        for (int j = 0; j < n; ++j) {
            if (i == j) continue; 
            // result knows j or j doesn't know result, return -1;
            if (knows(i, j) || !knows(j, i)) return -1;
        }
        return i;
    }
};
```



#### [1791. Find Center of Star Graph](https://leetcode-cn.com/problems/find-center-of-star-graph/)

There is an undirected **star** graph consisting of `n` nodes labeled from `1` to `n`. A star graph is a graph where there is one **center** node and **exactly** `n - 1` edges that connect the center node with every other node. You are given a 2D integer array `edges` where each `edges[i] = [ui, vi]` indicates that there is an edge between the nodes `ui` and `vi`. Return the center of the given star graph. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/24/star_graph.png)

```c++
Input: edges = [[1,2],[2,3],[4,2]]
Output: 2
Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.
```

**Example 2:**

```c++
Input: edges = [[1,2],[5,1],[1,3],[1,4]]
Output: 1
```

**Constraints:**

- `3 <= n <= 105`
- `edges.length == n - 1`
- `edges[i].length == 2`
- `1 <= ui, vi <= n`
- `ui != vi`
- The given `edges` represent a valid star graph.

```c++
class Solution {
public:
    int findCenter(vector<vector<int>>& edges) {
        unordered_map<int, int> val_freq;
        unordered_set<int> nums;
        for(auto& e : edges){
            int p = e[0];
            int q = e[1];
            val_freq[p]++;
            val_freq[q]++;
            nums.insert(p);
            nums.insert(q);
        }
        for(auto& [k, v] : val_freq){
            if(v == nums.size()-1){
                return k;
            }
        }
        return -1;
    }
};
```



#### [1138. Alphabet Board Path](https://leetcode-cn.com/problems/alphabet-board-path/)

On an alphabet board, we start at position `(0, 0)`, corresponding to character `board[0][0]`.

Here, `board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"]`, as shown in the diagram below.

![img](https://assets.leetcode.com/uploads/2019/07/28/azboard.png)

We may make the following moves:

- `'U'` moves our position up one row, if the position exists on the board;
- `'D'` moves our position down one row, if the position exists on the board;
- `'L'` moves our position left one column, if the position exists on the board;
- `'R'` moves our position right one column, if the position exists on the board;
- `'!'` adds the character `board[r][c]` at our current position `(r, c)` to the answer.

(Here, the only positions that exist on the board are positions with letters on them.)

Return a sequence of moves that makes our answer equal to `target` in the minimum number of moves. You may return any path that does so. 

**Example 1:**

```c++
Input: target = "leet"
Output: "DDR!UURRR!!DDD!"
```

**Example 2:** 

**Constraints:**

- `1 <= target.length <= 100`
- `target` consists only of English lowercase letters.

```c++
/* Bcof 'z' is special, so choose L and U first, then D,R;
    If not 'z', direction has no priority
    But for 'z':
    e.g.1: zb: should go up   first, then go right;
    e.g.2: bz: should go left first, then go down; 
    so as long as going left and up first is fine:
*/
class Solution {
public:
    string alphabetBoardPath(string target) {
        int x = 0, y = 0; // start coord is [0,0];
        string s = "";
        // taversal every letter in target:
        for(auto& c: target){
            int nextX = (c - 'a') / 5;
            int nextY = (c - 'a') % 5;
            if(nextY < y) for(int i = 0; i < y - nextY; i++) s+='L';
            if(nextX < x) for(int i = 0; i < x - nextX; i++) s+='U';
            if(nextX > x) for(int i = 0; i < nextX - x; i++) s+='D';
            if(nextY > y) for(int i = 0; i < nextY - y; i++) s+='R';
            // update new coordinates:
            s+='!';
            x = nextX;
            y = nextY;
        }
        return s;
    }
};
```



