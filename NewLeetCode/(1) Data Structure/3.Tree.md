[TOC]



# Tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
```

## 1. Tree BFS:



#### [102. Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector <vector <int>> ret;
        if (!root) return ret;
        queue <TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            ret.push_back(vector <int> ());
            for (int i = 1; i <= size; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return ret;
    }
};
```



#### [103. Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

Given the `root` of a binary tree, return *the zigzag level order traversal of its nodes' values*. (i.e., from left to right, then right to left for the next level and alternate between).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        if(!root) return ret;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            int currentLevelSize = q.size();
            ret.push_back(vector <int> ());
            for (int i = 1; i <= currentLevelSize; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        for(int i = 1; i < ret.size(); i+=2)
            reverse(ret[i].begin(), ret[i].end());
        return ret;
    }
};
```



#### [107. Binary Tree Level Order Traversal II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

Given the `root` of a binary tree, return *the bottom-up level order traversal of its nodes' values*. (i.e., from left to right, level by level from leaf to root).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
```

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int> > ans;
        if(!root) return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int curNodeSize = q.size();
            ans.push_back(vector<int> ());
            for(int i = 1; i <= curNodeSize; i++){
                auto node = q.front(); q.pop();
                ans.back().push_back(node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        reverse(ans.begin(), ans.end()); 
        return ans;
    }
};
```







#### [116. Populating Next Right Pointers in Each Node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

**Follow up:**

- You may only use constant extra space.
- Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```c++
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Constraints:**

- The number of nodes in the given tree is less than `4096`.
- `-1000 <= node.val <= 1000`

**(1) method 1: DFS **

```c++
class Solution {
public:
    // for the perfect binary tree can use following method:(not for normal tree):
    Node* connect(Node* root) {
        if (root == nullptr || root->left == nullptr) return root;
        // (1) connect two children of cur node
        root->left->next = root->right;
        // (2) if cur has next node then connect cur->right and cur->next->left:
        if (root->next) root->right->next = root->next->left;
        connect(root->left);
        connect(root->right);
        return root;
    }
};
```



**(2) method 2: BFS**

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int q_size = q.size(); 
            Node* tmp = q.front();
            for(int i = 1; i <= q_size; i++){
                auto node = q.front(); q.pop();
                if(i==1) tmp = node;  
                else if(i > 1){
                    tmp->next = node;  
                    tmp = node; 
                }
                tmp->next = NULL;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return root;
    }
};
```

**(3) method 3: same code as LeetCode 117: **

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        // every layer will be a list:
        Node* cur = root; // start from root:
        Node* dummy = new Node(0); // point to the first point in next level:
        Node* pre = dummy; // used for store the former node in current level:
        // if dummy->next is nullptr means all nodes are connected:
        while (cur != nullptr) {
            dummy->next = nullptr;
            pre = dummy;
            // dummy->next is the first node of next level:
            // connect left and right and update pre, finish one level in while:
            while (cur != nullptr) {
                if (cur->left != nullptr) { // deal with left child
                    pre->next = cur->left;
                    pre = pre->next;
                }
                if (cur->right != nullptr) { // deal with right child
                    pre->next = cur->right;
                    pre = pre->next;
                }
                // move to next node in current level:
                cur = cur->next;
            }
            // move cur node to the first node in next level:
            cur = dummy->next;  
        }
        return root;
    }
};
```



#### [117. Populating Next Right Pointers in Each Node II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

Given a binary tree

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. 

**Follow up:**

- You may only use constant extra space.
- Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

```
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

 **Constraints:**

- The number of nodes in the given tree is less than `6000`.
- `-100 <= node.val <= 100`

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        // every layer will be a list:
        Node* cur = root; // start from root:
        Node* dummy = new Node(0); // point to the first point in next level:
        Node* pre = dummy; // used for store the former node in current level:
        // if dummy->next is nullptr means all nodes are connected:
        while (cur != nullptr) {
            dummy->next = nullptr;
            pre = dummy;
            // dummy->next is the first node of next level:
            // connect left and right and update pre, finish one level in while:
            while (cur != nullptr) {
                if (cur->left != nullptr) { // deal with left child
                    pre->next = cur->left;
                    pre = pre->next;
                }
                if (cur->right != nullptr) { // deal with right child
                    pre->next = cur->right;
                    pre = pre->next;
                }
                // move to next node in current level:
                cur = cur->next;
            }
            // move cur node to the first node in next level:
            cur = dummy->next;  
        }
        return root;
    }
};
```

#### [513. Find Bottom Left Tree Value](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

Given the `root` of a binary tree, return the leftmost value in the last row of the tree. 

**Example 1:

![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

```c++
Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7
```

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int ans = 0;
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                auto node = q.front(); q.pop();
                if(i == 0) ans = node->val;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return ans;
    }
};
```





#### [515. Find Largest Value in Each Tree Row](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

Given the `root` of a binary tree, return *an array of the largest value in each row* of the tree **(0-indexed)**. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)

```c++
Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
```



```c++
class Solution {
public:
    // INT_MIN = -2^31
    // INT_MAX = 2^31 -1
    vector<int> largestValues(TreeNode* root) {
        if(!root) return {};
        vector<int> ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            int max_val = INT_MIN;
            for(int i = 0; i < size; i++){
                auto node = q.front(); q.pop();
                max_val = max(max_val, node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            ans.push_back(max_val);
        }
        return ans;
    }
};
```



#### [623. Add One Row to Tree](https://leetcode-cn.com/problems/add-one-row-to-tree/)

Given the `root` of a binary tree and two integers `val` and `depth`, add a row of nodes with value `val` at the given depth `depth`. Note that the `root` node is at depth `1`.

The adding rule is:

- Given the integer `depth`, for each not null tree node `cur` at the depth `depth - 1`, create two tree nodes with value `val` as `cur`'s left subtree root and right subtree root.
- `cur`'s original left subtree should be the left subtree of the new left subtree root.
- `cur`'s original right subtree should be the right subtree of the new right subtree root.
- If `depth == 1` that means there is no depth `depth - 1` at all, then create a tree node with value `val` as the new root of the whole original tree, and the original tree is the new root's left subtree.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg)

```c++
Input: root = [4,2,6,3,1,5], val = 1, depth = 2
Output: [4,1,1,2,null,null,6,3,1,5]
```

```c++
class Solution {
public:
    TreeNode* addOneRow(TreeNode* root, int v, int d) {
        if(!root) return {};
        queue<TreeNode*> q;
        q.push(root);
        int depth = 1;
        // corner case: when add at the first level:
        // connect root to new_left and right == nullptr;
        if(d == 1){ 
            TreeNode* new_root = new TreeNode(v);
            new_root->left = root;
            new_root->right = nullptr;
            return new_root;
        }
        while(!q.empty()){  
            int size = q.size(); 
            for(int i = 1; i <= size; i++){
                auto node = q.front(); q.pop();
                // save next level, bc will change later
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
                if(depth == d-1){ 
                    // In for loop:work on one node of level d-1:
                    TreeNode* l_child = new TreeNode(v);
                    TreeNode* r_child = new TreeNode(v);
                    if(node->left){ 
                        l_child->left = node->left;
                        l_child->right = nullptr;
                    }
                    if(node->right){ 
                        r_child->right = node->right;
                        r_child->left = nullptr;
                    }
                    node->left  = l_child;
                    node->right = r_child;
                }
            }
            depth++; 
            if(depth == d) return root; 
        }
        return root;
    }
};
```





#### [637. Average of Levels in Binary Tree](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

Given the `root` of a binary tree, return *the average value of the nodes on each level in the form of an array*. Answers within `10-5` of the actual answer will be accepted.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)

```c++
Input: root = [3,9,20,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
```

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `-2^31 <= Node.val <= 2^31 - 1`



```c++
class Solution {
public: 
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ret;
        if(!root) return ret;
        queue<TreeNode* > q;
        q.push(root);
        while(!q.empty()){
          	// save size here:
            int size = q.size(); 
          	// use double here !!
            double sum = 0, count = 0;
            for(int i = 1; i <= size; i++){ 
                auto node = q.front(); q.pop();
                sum += node->val; count++;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            ret.push_back(sum/count);
        }
        return ret;
    }
};
```





#### [671. Second Minimum Node In a Binary Tree](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly `two` or `zero` sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property `root.val = min(root.left.val, root.right.val)` always holds.

Given such a binary tree, you need to output the **second minimum** value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)

```c++
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
```

```c++
class Solution {
public:
    // the smallest must be root:
    // recursion to find the first value that is bigger than root->val:
    // return the next value that bigger than val in the tree:
    int dfs(TreeNode* root, int val) {
        if (!root) return -1;
        if (root->val > val) return root->val;
        int left = dfs(root->left, val); // next bigger value in left subtree
        int right = dfs(root->right, val); // next bigger value in right subtree
        if (left < 0) return right;
        if (right < 0) return left;
        return min(left, right); // two bigger value in both left and right
    }
    int findSecondMinimumValue(TreeNode* root) {
        return dfs(root, root->val);
    }
};
```

#### [958. Check Completeness of a Binary Tree](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

Given the `root` of a binary tree, determine if it is a *complete binary tree*. In a **[complete binary tree](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png)

```c++
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
```

```c++
class Solution {
public:
    // two condition make it not complete:
    // (1) if a node only has right child
    // (2) if a node only has left child, or no children, 
    // any node later will be leave node.
    bool isCompleteTree(TreeNode* root) {
        if (!root) return true;
        queue<TreeNode*> q;
        q.push(root);
        bool ifLeaf = false;  
        while (!q.empty()){
            TreeNode* node = q.front(); q.pop();
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
            // (1) condition 1:
            if (!node->left && node->right)  return false;
            // (2) condition 2:
            if (ifLeaf && (node->left || node->right)){ 
                return false;
            }
            // if node has no right child, change ifLeaf
            if(!node->right) ifLeaf = true; 
        }
        return true;
    }
};
```



#### [993. Cousins in Binary Tree](https://leetcode-cn.com/problems/cousins-in-binary-tree/)

Given the `root` of a binary tree with unique values and the values of two different nodes of the tree `x` and `y`, return `true` *if the nodes corresponding to the values* `x` *and* `y` *in the tree are **cousins**, or* `false` *otherwise.*

Two nodes of a binary tree are **cousins** if they have the same depth with different parents.

Note that in a binary tree, the root node is at the depth `0`, and children of each depth `k` node are at the depth `k + 1`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png)

```c++
Input: root = [1,2,3,4], x = 4, y = 3
Output: false
```



```c++
class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        queue<TreeNode*>q;
        q.push(root); 
        int flag = 2;                       
        while(!q.empty()){
            int n = q.size();
            for(int i = 0; i<n; i++){         
                auto root = q.front(); q.pop();    
                if( root->left && 
                    root->right &&
                    ((root->left->val == x  && root->right->val == y)
                    ||(root->left->val == y && root->right->val == x)
                )){           
                    return false; // cousins can not have same parent:
                } 
                if(root->left){
                    q.push(root->left);    
                    // if root->left is x or y flag-- means found one:
                    if(root->left->val == x || root->left->val == y) flag--;    
                }
                if(root->right){    
                    // if root->right is x or y flag-- means found one:
                    q.push(root->right);
                    if(root->right->val==x || root->right->val==y) flag--;
                }  
            }
            // if only found one in current level, return false;
            if(flag==1) return false;   
            // if found both, and not has the same father, return true:
            if(flag==0) return true;   
            // else if flag==2: means have not found any of the two nodes:
        }                            
        return false;  
    }
};
```







## 2.  TreeDepth related



#### [104. Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

Given the `root` of a binary tree, return *its maximum depth*. A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: 3
```



```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;        
        return 1 + max(maxDepth(root->left), 
                       maxDepth(root->right));
    }
};
```



#### [110. Balanced Binary Tree](https://leetcode-cn.com/problems/balanced-binary-tree/)

Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of *every* node differ in height by no more than 1. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: true
```



```c++
class Solution {
public:
    int flag = true;
    // check every node's l-subtree's h and r-subtree's h 
    int dfs(TreeNode* root){
        if(flag == false) return 0;
        if(root == nullptr) return 1;
        int l = dfs(root->left); // height of left subtree
        int r = dfs(root->right);// height of right subtree
        if(abs(l-r) > 1) flag = false; // if height dif is more than 1, means not balanced. 
        return max(l,r)+1;
    }
    bool isBalanced(TreeNode* root) {
        dfs(root);
        return flag;
    }
};
```





#### [111. Minimum Depth of Binary Tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. **Note:** A leaf is a node with no children. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: 2
```

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;  // recur exit
        int l = minDepth(root->left);// min_d of left tree
        int r = minDepth(root->right);// min_d of right tree
        if (!l || !r) return l+r+1;// include 3 conditions
        return min(l, r) + 1; 
    }
};
```



#### [222. Count Complete Tree Nodes](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

Given the `root` of a **complete** binary tree, return the number of the nodes in the tree. According to **[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`. Design an algorithm that runs in less than `O(n)` time complexity.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```c++
Input: root = [1,2,3,4,5,6]
Output: 6
```



```c++
// (1) method 1:
// Time Complexity: O(n), for traversal every node;
class Solution {
public:
    int countNodes(TreeNode* root) {
        return root != nullptr ? 1+countNodes(root->right)+countNodes(root->left):0;
    }
};
```



```c++
// (2) method 2:
// use the feature of complete tree: 
//     if (l_depth == r_depth): left subtree is comoplete; 
//     else right subtree is comoplete;  
//     And number of nodes for complete tree: (1 << depth): 2^h: 
//     bc number of complete tree nodes is 2^h -1,so plus root is 2^h;
// use the feature of complete tree: 
//     if l_depth==r_depth: left subtree is comoplete; 
//     else right subtree is comoplete;  
//     And (1 << l_depth): 2^h: 
// bc number of complete tree nodes is 2^h -1,so plus root is 2^h;
class Solution {
public:
  	// Time complexity: O(logN * logN): 
    // In each recursion 
    //    (1) logN to get tree depth
    // 		(2) spilt half, kind of like binary search. logN
  	// So in total is O(logN * logN);
  
    // (1) depth of left-bottom node for complete tree:
    int countLevels(TreeNode * root) {
        int level = 0;
        while (root != nullptr) {
            level++;
            root = root->left; 
        }
        return level;
    }
    int count(TreeNode * root, int l_depth) {
        if (!root) return 0;
        int r_depth = countLevels(root->right);
        // (1) left tree is complete, recursion in right subtree:
        if (l_depth == r_depth){
            
            return (1<<l_depth) + count(root->right, r_depth-1);
        }
        // (2) right subtree is complete, recursion in left subtree:
        return (1 << r_depth) + count(root->left, l_depth - 1);
    }
    int countNodes(TreeNode* root) {
        return count(root, countLevels(root) - 1);
    }
};
```





























#### [543. Diameter of Binary Tree](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

Given the `root` of a binary tree, return *the length of the **diameter** of the tree*. The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`. The **length** of a path between two nodes is represented by the number of edges between them.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```c++
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
```

```c++
class Solution {
public:
    int depth = 0; // update depth
    // max_depth of root
    int dfs(TreeNode* root){  
        if(!root) return 0;
        int L = dfs(root->left);
        int R = dfs(root->right);
        depth = max (L+R, depth);
        return max(L, R) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return depth;
    }
};
```









#### [865. Smallest Subtree with all the Deepest Nodes](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/)

Given the `root` of a binary tree, the depth of each node is **the shortest distance to the root**.

Return *the smallest subtree* such that it contains **all the deepest nodes** in the original tree.

A node is called **the deepest** if it has the largest depth possible among any node in the entire tree.

The **subtree** of a node is tree consisting of that node, plus the set of all descendants of that node.

**Note:** This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/ 

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)

```c++
Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
```

```c++
class Solution {
public:
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        if(!root) return nullptr;
        int l_dpeth = tree_depth(root->left);
        int r_dpeth = tree_depth(root->right);
        if(l_dpeth > r_dpeth){
            return subtreeWithAllDeepest(root->left);
        }
        else if(l_dpeth < r_dpeth) {
            return subtreeWithAllDeepest(root->right);
        }
        return root;
    }
    int tree_depth(TreeNode* root){
        if(!root) return 0;
        return max(tree_depth(root->left), 
                   tree_depth(root->right)) + 1;
    }
};
```











#### [1302. Deepest Leaves Sum](https://leetcode-cn.com/problems/deepest-leaves-sum/)

Given the `root` of a binary tree, return *the sum of values of its deepest leaves*.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png)

```c++
Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
Output: 15
```

```c++
class Solution {
public:
    int max_depth(TreeNode* root){
        if(!root) return 0;
        return 1+ max(max_depth(root->left), 
                        max_depth(root->right));
    }
    int deepestLeavesSum(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int max_d = max_depth(root);
        int depth = 1;
        int sum = 0;
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++)
            {
                auto node = q.front(); q.pop();
                if(depth == max_d) sum += node->val;
                if(node->left)  q.push(node->left);
                if(node->right) q.push(node->right);
            }
            depth++;
        }
        return sum;
    }
};
```



---



## 3. Tree Path:

### (1) Path Sum

#### [112. Path Sum](https://leetcode-cn.com/problems/path-sum/)

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. A **leaf** is a node with no children.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```c++
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
```

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(!root) return false;
        if(!root->left && !root->right) 
            return (sum == root->val);
        return hasPathSum(root->left, sum - root->val) 
            || hasPathSum(root->right, sum - root->val);
    }
};
```



#### [113. Path Sum II](https://leetcode-cn.com/problems/path-sum-ii/)

Given the `root` of a binary tree and an integer `targetSum`, return *all **root-to-leaf** paths where the sum of the node values in the path equals* `targetSum`*. Each path should be returned as a list of the node **values**, not node references*. A **root-to-leaf** path is a path starting from the root and ending at any leaf node. A **leaf** is a node with no children. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```c++
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
Explanation: There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
```

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return ans;
        vector<int> path;
        dfs(root, targetSum, path);
        return ans;
    }
    void dfs(TreeNode* root, int targetSum, vector<int> path){
        if(root == nullptr) return;
        // backtracking 1: push node
        path.push_back(root->val);
        // reach leaf + root->val == targetSum
        if(!root->left && !root->right && root->val == targetSum){
            ans.push_back(path);
        } 
        // recursion in left and right subtree
        dfs(root->left, targetSum - root->val, path);
        dfs(root->right, targetSum - root->val, path);
        // backtracking 2: pop_back 
        path.pop_back();
    }
};
```



#### [124. Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root. The **path sum** of a path is the sum of the node's values in the path. Given the `root` of a binary tree, return *the maximum **path sum** of any path*.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```c++
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```



```c++
class Solution {
public:
    int ans = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // the longest path from root:
    int dfs(TreeNode* root){
        if(!root) return 0;
        auto left = dfs(root->left);
        auto right = dfs(root->right);
        ans = max(ans, left + right + root->val);
        return max(0, max(left, right) + root->val);
    }
};
```

#### [129. Sum Root to Leaf Numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

You are given the `root` of a binary tree containing digits from `0` to `9` only.  Each root-to-leaf path in the tree represents a number.  For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`. Return *the total sum of all root-to-leaf numbers*. Test cases are generated so that the answer will fit in a **32-bit** integer. A **leaf** node is a node with no children.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```c++
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

```c++
class Solution {
public:
    long long ans; /// long long for int overflow
    void dfs(TreeNode* root, vector<int> path){
        if(root == nullptr) return;
        path.push_back(root->val);
        // only calculate sum when reaching leaves;
        if(root->left == nullptr && root->right == nullptr){
            long long tmp_sum = 0;
            for(int i = 0; i < path.size(); i++){
                tmp_sum *= 10;
                tmp_sum += path[i];
            }
            ans += tmp_sum;
        }
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
        path.pop_back();
  }
    int sumNumbers(TreeNode* root) {
        vector<int> path;
        dfs(root, path);
        return ans;
    }
};
```



#### [437. Path Sum III](https://leetcode-cn.com/problems/path-sum-iii/)

Given the `root` of a binary tree and an integer `targetSum`, return *the number of paths where the sum of the values along the path equals* `targetSum`.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```c++
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
```

```c++
// (1) method 1: normal method: nested dfs
class Solution {
public:
    int ans = 0;
    // path from root with sum;
    void dfs(TreeNode* root, int sum){
        if(root == nullptr) return;
        if(root->val == sum) ans ++;
        dfs(root->left, sum - root->val);
        dfs(root->right, sum - root->val);
    }
    
    // for every node , do dfs(root, sum);
    int pathSum(TreeNode* root, int sum) {
        if(root == nullptr) return 0;
        dfs(root, sum);
        pathSum(root->left, sum);
        pathSum(root->right, sum);
        return ans;
    }
};
```

```c++
// (2) method 2: prefix: TC: O(n):
class Solution {
public:
    int dfs(TreeNode* root, int targetSum, unordered_map<int, int> &m, int cur_sum) 
    {
        if (root == nullptr) return 0;
        int ans = 0;
        cur_sum += root->val;
        int prefix = cur_sum - targetSum;
        if (m.find(prefix) != m.end()) {
            ans += m[prefix];
        }
        ++m[cur_sum];
        ans += dfs(root->left,  targetSum, m, cur_sum) 
             + dfs(root->right, targetSum, m, cur_sum);
        --m[cur_sum];
        return ans;
    }
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;
        unordered_map<int, int> m;
        m[0] = 1;
        return dfs(root, targetSum, m, 0);
    }
};
```









### (2) Normal Tree Path:

#### [257. Binary Tree Paths](https://leetcode-cn.com/problems/binary-tree-paths/)

Given the `root` of a binary tree, return *all root-to-leaf paths in **any order***. A **leaf** is a node with no children.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```c++
Input: root = [1,2,3,null,5]
Output: ["1->2->5","1->3"]
```

```c++
class Solution {
public:
    vector<string> ans;
    void dfs(TreeNode*root, string tmp){
        if(root == nullptr) return;
        tmp += to_string(root->val);
        // if leave nodes, check if could be put into ans.
        if(root->left == nullptr && root->right == nullptr){
            ans.push_back(tmp);
        }
        else tmp += "->"; // add this for all non-leave nodes
        // recursion in left subtree
        dfs(root->left, tmp);
        dfs(root->right, tmp);
        tmp.pop_back();
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string tmp = "";
        dfs(root, tmp);
        return ans;
    }
};
```



#### [863. All Nodes Distance K in Binary Tree](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

Given the `root` of a binary tree, the value of a target node `target`, and an integer `k`, return *an array of the values of all nodes that have a distance* `k` *from the target node.* You can return the answer in **any order**.

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png)

```c++
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
Output: [7,4,1]
Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.
  // All the values Node.val are unique. but doesn't matter
```

```c++

// (1) find_father + bfs:
class Solution {
public:
    unordered_map<TreeNode *, TreeNode *> parent;
    // find father node for every node:
    void dfs_find_parent(TreeNode * node){
        if (node){
            if (node->left) parent[node->left] = node;
            if (node->right) parent[node->right] = node;
            dfs_find_parent(node->left);
            dfs_find_parent(node->right);
        }
    }
    // transfer tree to graph:
    // BFS start from target, to find node at step k;
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) 
    {
        // build graph: 
        dfs_find_parent(root);
        if (k == 0) return vector<int> {target->val};
        vector<int> ans;
        queue<TreeNode *> Q;
        unordered_set<TreeNode *> visited;
        Q.push(target);
        visited.insert(target);
        int level = 0;
        while (!Q.empty() && level < k){ // level > k break;
            level ++;
            int size = (int)Q.size();
            for (int i = 0; i < size; i ++){
                auto x = Q.front(); Q.pop();
                for (auto y : {parent[x],x->left,x->right}){
                    if (y && visited.find(y) == visited.end()){
                        if (level == k){
                            ans.push_back(y->val);
                        }
                        visited.insert(y);
                        Q.push(y);
                    }
                }
            }
        }
        return ans;
    }
};

```



```c++
// (2) find_father + dfs:
class Solution {
public:
    int k;
    unordered_map<TreeNode *, TreeNode *> parent;
    vector<int> res;

    void dfs_find_parent(TreeNode * node){ // O(n)
        if (node){
            if (node->left) parent[node->left] = node;
            if (node->right) parent[node->right] = node;
            dfs_find_parent(node->left);
            dfs_find_parent(node->right);
        }
    }

    void dfs_get_res(TreeNode * node, TreeNode * prev, int cur_dist)
    {
        if (!node) return;
        if (cur_dist == k)
        {
            res.push_back(node->val);
            return;
        }
        // following ifs to make sure not go backwards:
        // e.g. after searched father, don't search from child
        if (parent[node] != prev)
            dfs_get_res(parent[node], node, cur_dist + 1);
        if (node->left != prev)
            dfs_get_res(node->left, node, cur_dist + 1);
        if  (node->right != prev)
            dfs_get_res(node->right, node, cur_dist + 1);
    }

    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) 
    {
        this->k = k;
        dfs_find_parent(root);
        dfs_get_res(target, NULL, 0);
        return res;
    }
};
```







#### [988. Smallest String Starting From Leaf](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)

You are given the `root` of a binary tree where each node has a value in the range `[0, 25]` representing the letters `'a'` to `'z'`. Return *the **lexicographically smallest** string that starts at a leaf of this tree and ends at the root*.As a reminder, any shorter prefix of a string is **lexicographically smaller**.

- For example, `"ab"` is lexicographically smaller than `"aba"`. A leaf of a node is a node that has no children. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/01/30/tree1.png)

```c++
Input: root = [0,1,2,3,4,3,4]
Output: "dba"
```

```c++
class Solution {
public:
    string ans;
    void dfs(TreeNode* node, string path){
        if (!node) return;
        // transfer int to according char : 0 -> 'a'
        path += node->val + 'a'; 
        // (1) when reach a leave node, 
        // reverse the path to get leave to root and update ans;
        if (node->left == nullptr && node->right == nullptr){
            reverse(path.begin(), path.end());
            // use min to compare two string directly 
            ans = min(ans, path); 
            return;
        }
        // (2) if not a leave node, keep recursion:
        dfs(node->left,  path);
        dfs(node->right, path);
    }
    string smallestFromLeaf(TreeNode* root) {
        if (!root) return "";
        // initialize ans as a bigger string 
        // then all possible string in lexicographical;
        ans = "~"; // key point: "~" ascII is 
        dfs(root, "");
        return ans;
    }
};
```

#### [1372. Longest ZigZag Path in a Binary Tree](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)

You are given the `root` of a binary tree. A ZigZag path for a binary tree is defined as follow:

- Choose **any** node in the binary tree and a direction (right or left).
- If the current direction is right, move to the right child of the current node; otherwise, move to the left child.
- Change the direction from right to left or from left to right.
- Repeat the second and third steps until you can't move in the tree.

Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return *the longest **ZigZag** path contained in that tree*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png)

```c++
Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).
```

```c++
class Solution {
public:
    int maxAns = 0;;
    /* dir :  0 => left, 1 => right */
    void dfs(TreeNode* root, bool dir, int len) {
        maxAns = max(maxAns, len); 
        // (1) next step should go right
        if (dir == 0) { 
            // if has left child: len++, change direction:
            if (root->left) dfs(root->left, 1, len + 1); 
            // if has right child: len==1, keep direction:
            // len==1 not 0, bc just pass current node:
            if (root->right) dfs(root->right, 0, 1); 
        } 
        // (2) next step should go left
        else if(dir == 1) {
            if (root->right) dfs(root->right, 0, len + 1);
            if (root->left) dfs(root->left, 1, 1);
        }
    } 
    int longestZigZag(TreeNode* root) {
        if (!root) return 0;
        dfs(root, 0, 0); // root go left
        dfs(root, 1, 0); // root go right
        return maxAns;
    }
};
```



## 4. Subtree:



#### [100. Same Tree](https://leetcode-cn.com/problems/same-tree/)

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```c++
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p && !q) return true;
        if(!p || !q) return false;
        if(p->val != q->val) return false;
        return isSameTree(p->left, q->left)
            && isSameTree(p->right, q->right);
    }
};
```





#### [101. Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree/)

Given the `root` of a binary tree, *check whether it is a mirror of itself* (i.e., symmetric around its center).

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```c++
Input: root = [1,2,2,3,4,4,3]
Output: true
```

```c++
class Solution {
public:
    bool dfs(TreeNode* p, TreeNode *q){
        if(!p || !q) return !p && !q; 
        return (p->val == q->val) && dfs(p->left, q->right) && dfs(p->right, q->left);
    }
    bool isSymmetric(TreeNode* root){
        if(!root) return true;
        return dfs(root->left, root->right);
    }
};
```



#### [108. Convert Sorted Array to Binary Search Tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a **height-balanced** binary search tree*.  A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```c++
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
```

```c++
class Solution {
public:
    TreeNode* build(vector<int>& nums, int l, int r){
        if(l > r) return nullptr;
        int mid = (l+r)/2;
        TreeNode* newNode = new TreeNode(nums[mid]);
        newNode->left = build(nums, l, mid-1);
        newNode->right = build(nums, mid+1, r);
        return newNode;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.empty()) return nullptr;
        return build(nums, 0, nums.size()-1);
    }
};
```





#### [226. Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree/)

Given the `root` of a binary tree, invert the tree, and return *its root*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```c++
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```



#### [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).” 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```c++
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

````c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == nullptr)return root;
        auto l = lowestCommonAncestor(root->left, p, q); 
        auto r = lowestCommonAncestor(root->right, p, q); 
        if(!l) return r;
        if(!r) return l;
        return root;
    }
};
````



#### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).” 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```c++
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == nullptr)return root;
        auto l = lowestCommonAncestor(root->left, p, q); 
        auto r = lowestCommonAncestor(root->right, p, q); 
        if(!l) return r;
        if(!r) return l;
        return root;
    }
};
```



#### [404. Sum of Left Leaves](https://leetcode-cn.com/problems/sum-of-left-leaves/)

Given the `root` of a binary tree, return the sum of all left leaves.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)

```c++
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
```

```c++
class Solution {
public:
    int sum = 0;
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            auto node = q.front(); q.pop();
            if(node->left) q.push(node->left);
            if(node->left 
                && !node->left->left 
                && !node->left->right)
                sum = sum + node->left->val;
            if(node->right) q.push(node->right);
        }
        return sum;
    }
};
```







#### [508. Most Frequent Subtree Sum](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)

Given the `root` of a binary tree, return the most frequent **subtree sum**. If there is a tie, return all the values with the highest frequency in any order.

The **subtree sum** of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg)

```c++
Input: root = [5,2,-3]
Output: [2,-3,4]
```

```c++
class Solution {
public:
    vector<int> ans;
    unordered_map<int,int> m;
    int MAX = 1;  
    // getSum of root
    int getSum(TreeNode* root){
        if(root == nullptr) return 0;  
        int sum = getSum(root->left) 
                + getSum(root->right) 
                + root->val;
        m[sum]++;
        if(m[sum] == MAX) ans.push_back(sum);
        if(m[sum] > MAX){
            MAX = m[sum];
            ans.clear();
            ans.push_back(sum);
        }
        return sum;
    }
    vector<int> findFrequentTreeSum(TreeNode* root) {
        getSum(root);
        return ans;
    }
};
```



#### [563. Binary Tree Tilt](https://leetcode-cn.com/problems/binary-tree-tilt/)

Given the `root` of a binary tree, return *the sum of every tree node's **tilt**.* The **tilt** of a tree node is the **absolute difference** between the sum of all left subtree node **values** and all right subtree node **values**. If a node does not have a left child, then the sum of the left subtree node **values** is treated as `0`. The rule is similar if there the node does not have a right child. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg)

```c++
Input: root = [1,2,3]
Output: 1
Explanation: 
Tilt of node 2 : |0-0| = 0 (no children)
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)
Sum of every tilt : 0 + 0 + 1 = 1
```

```c++
class Solution {
public: 
    int sum = 0;
    // return sum of subtree
    int dfs(TreeNode* root){
        // nullptr node has 0 tilt:
        if(!root) return 0; 
        int l = dfs(root->left); 
        int r = dfs(root->right); 
        sum += abs(l - r); 
        return l + r + root->val;
    }
    int findTilt(TreeNode* root) {
        dfs(root);
        return sum;
    }
};
```



#### [572. Subtree of Another Tree](https://leetcode-cn.com/problems/subtree-of-another-tree/)

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of` subRoot` and `false` otherwise. A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)

```c++
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

```c++
class Solution {
public:
    bool isSametree (TreeNode* p, TreeNode* q){
        if(!p && !q) return true;
        if(!p || !q) return false;
        if(p->val != q->val) return false;
        return isSametree(p->left, q->left)
            && isSametree(p->right, q->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root == nullptr) return false;
        if(root->val == subRoot->val){
            if(isSametree(root, subRoot)){
                return true;
            }
        }
        return isSubtree(root->left, subRoot)
            || isSubtree(root->right, subRoot);
    }
};
```



#### [606. Construct String from Binary Tree](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

Given the `root` of a binary tree, construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg)

```c++
Input: root = [1,2,3,4]
Output: "1(2(4))(3)"
Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"
```

```c++
class Solution {
public:
    string tree2str(TreeNode* t) {
        // recursion exit: 
        // (1) if t == nullptr, return "";
        if(!t) return ""; 
        // (2) if left and right child are all nullptr, return v->val;
        if(!t->left && !t->right) return to_string(t->val); 
        // (3) if t->right = nullptr， return cur node and recursion 
        // result of t->left :  t->val + "(" + tree2str(t->left) + ")"
        if(!t->right){
            return to_string(t->val) +"("+tree2str(t->left)+")";
        }
        // (4) can not omit when miss left child
        // (5) bc when t->left == nullptr, we can omit the "()",
        // so we treat this as the same situation of both children are not nullptr.
        return to_string(t->val) 
            + "(" + tree2str(t->left) + ")(" + tree2str(t->right) + ")"; 
    }
};
```



#### [617. Merge Two Binary Trees](https://leetcode-cn.com/problems/merge-two-binary-trees/)

You are given two binary trees `root1` and `root2`.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return *the merged tree*.

**Note:** The merging process must start from the root nodes of both trees.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```c++
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
```

```c++

class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if(!t1) return t2;
        if(!t2) return t1;
        t1->val += t2->val;
        t1->left = mergeTrees(t1->left, t2->left);
        t1->right = mergeTrees(t1->right, t2->right);
        return t1;
    }
};
```



#### [654. Maximum Binary Tree](https://leetcode-cn.com/problems/maximum-binary-tree/)

You are given an integer array `nums` with no duplicates. A **maximum binary tree** can be built recursively from `nums` using the following algorithm:

1. Create a root node whose value is the maximum value in `nums`.
2. Recursively build the left subtree on the **subarray prefix** to the **left** of the maximum value.
3. Recursively build the right subtree on the **subarray suffix** to the **right** of the maximum value.

Return *the **maximum binary tree** built from* `nums`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```c++
Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
```

```c++
class Solution {
public:
    TreeNode* dfs(vector<int>&nums, int l, int r){
        if(l > r) return nullptr;
        int tmp_max = INT_MIN ; // the max value
        int idx = l; // find the max value in cur part
        // find the biggest element pos in the nums
        for(int i = l; i <= r; i++){
            if(nums[i] > tmp_max){
                tmp_max = nums[i];
                idx = i;
            }
        }
        TreeNode* root = new TreeNode(tmp_max);
        root->left = dfs(nums, l, idx-1);
        root->right = dfs(nums, idx+1, r);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n = (int)nums.size();
        if(n == 0) return nullptr;
        return dfs(nums, 0, n-1);
    }
};
```



#### [655. Print Binary Tree](https://leetcode-cn.com/problems/print-binary-tree/)

Given the `root` of a binary tree, construct a **0-indexed** `m x n` string matrix `res` that represents a **formatted layout** of the tree. The formatted layout matrix should be constructed using the following rules:

- The **height** of the tree is `height` and the number of rows `m` should be equal to `height + 1`.
- The number of columns `n` should be equal to `2height+1 - 1`.
- Place the **root node** in the **middle** of the **top row** (more formally, at location `res[0][(n-1)/2]`).
- For each node that has been placed in the matrix at position `res[r][c]`, place its **left child** at `res[r+1][c-2height-r-1]` and its **right child** at `res[r+1][c+2height-r-1]`.
- Continue this process until all the nodes in the tree have been placed.
- Any empty cells should contain the empty string `""`.

Return *the constructed matrix* `res`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg)

```c++
Input: root = [1,2]
Output: 
[["","1",""],
 ["2","",""]]
```

```c++
class Solution {
public:
  	// m is tree height 
  	// n == 2^(height+1)-1, root is in the middle of first line
    // pass by reference !! use &
    void dfs(TreeNode* root, int l,int r,int height,vector<vector<string> > &v){
        if(!root) return; 
        if(l > r) return; 
        int mid = (l + r)/2;
        v[height][mid] += to_string(root->val);
        dfs(root->left, l, mid-1, height+1, v);
        dfs(root->right, mid+1, r, height+1, v);
    }
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
    vector<vector<string>> printTree(TreeNode* root) {
        int m = maxDepth(root), n = 1;
        for(int i = 0; i < m; i++) n *= 2;
        n -= 1;
        vector<vector<string>> ans(m, vector<string>(n, ""));
        dfs(root, 0, n-1, 0, ans);
        return ans;
    }
};
```



#### [687. Longest Univalue Path](https://leetcode-cn.com/problems/longest-univalue-path/)

Given the `root` of a binary tree, return *the length of the longest path, where each node in the path has the same value*. This path may or may not pass through the root.

**The length of the path** between two nodes is represented by the number of edges between them.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg)

```c++
Input: root = [5,4,5,1,1,5]
Output: 2
```

```c++
class Solution {
public:
    int ans = 0;
    //return the length of the longest path from node:
    int dfs(TreeNode* node) { 
        if (!node) return 0;
        int left = dfs(node->left); 
        int right = dfs(node->right);
        int arrowLeft = 0;  
        int arrowRight = 0; 
        if (node->left && node->left->val == node->val) 
            arrowLeft = left + 1; 
        if (node->right && node->right->val == node->val) 
            arrowRight = right+ 1;
        // why not +1 here, bc 3 nodes length==2;
        ans = max(ans, arrowLeft + arrowRight);
        // why not use left or right instead: 
        // only count when have same value:
        return max(arrowLeft, arrowRight);
    } 
    int longestUnivaluePath(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return ans;
    }
};
```



#### [814. Binary Tree Pruning](https://leetcode-cn.com/problems/binary-tree-pruning/)

Given the `root` of a binary tree, return *the same tree where every subtree (of the given tree) not containing a* `1` *has been removed*. A subtree of a node `node` is `node` plus every node that is a descendant of `node`.

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png)

```c++
Input: root = [1,null,0,0,1]
Output: [1,null,0,null,1]
Explanation: 
Only the red nodes satisfy the property "every subtree not containing a 1".
The diagram on the right represents the answer.
```

```c++
class Solution {
public:
    // check if subtree node has 1;
    bool containsOne(TreeNode* node) {
        if (node == nullptr) return false;
        // recursion in left and right subtree
        bool a1 = containsOne(node->left);
        bool a2 = containsOne(node->right);
        if (!a1) node->left = nullptr;
        if (!a2) node->right = nullptr;
        // only return true when both cur and children are 1s;
        return node->val == 1 || a1 || a2;
    }
    TreeNode* pruneTree(TreeNode* root) {
        return containsOne(root) ? root : nullptr;
    }
};
```



#### [938. Range Sum of BST](https://leetcode-cn.com/problems/range-sum-of-bst/)

Given the `root` node of a binary search tree and two integers `low` and `high`, return *the sum of values of all nodes with a value in the **inclusive** range* `[low, high]`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)

```c++
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
```

```c++
class Solution {
public:
    int rangeSumBST(TreeNode* root, int L, int R){
        if(!root) return 0;
        if(root->val > R) return rangeSumBST(root->left, L, R);
        else if(root->val < L) return rangeSumBST(root->right, L, R);
        else return root->val
            +rangeSumBST(root->left, L, R)
            +rangeSumBST(root->right, L, R);
    }
};
```



#### [951. Flip Equivalent Binary Trees](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/)

For a binary tree **T**, we can define a **flip operation** as follows: choose any node, and swap the left and right child subtrees. A binary tree **X** is *flip equivalent* to a binary tree **Y** if and only if we can make **X** equal to **Y** after some number of flip operations. Given the roots of two binary trees `root1` and `root2`, return `true` if the two trees are flip equivelent or `false` otherwise.

**Example 1:**

![Flipped Trees Diagram](https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png)

```c++
Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.
```

```c++
class Solution {
public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if (root1 == root2) return true;
        if (!root1 || !root2 || root1->val != root2->val){
            return false;
        } 
        // either left match left and righr match righr
        // or left match right and righr match left
        return (flipEquiv(root1->left, root2->left) 
             && flipEquiv(root1->right, root2->right)
             || flipEquiv(root1->left, root2->right) 
             && flipEquiv(root1->right, root2->left));
    }
};
```



#### 968. Binary Tree Cameras](https://leetcode-cn.com/problems/binary-tree-cameras/)

You are given the `root` of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return *the minimum number of cameras needed to monitor all nodes of the tree*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png)

```c++
Input: root = [0,0,null,0,0]
Output: 1
Explanation: One camera is enough to monitor all nodes if placed as shown.
```

```c++
class Solution {
public:
    int ans = 0;
    int minCameraCover(TreeNode* root) {
        // if dfs(root)==0 means root need to put camera.
        return dfs(root) == 0 ? ans+1 : ans; 
    } 
    // if root is covered:
    // return 0: covered by children
    // return 1: covered by father
    // return 2: covered by new camera
    int dfs(TreeNode* root){
        // treat nullptr as covered by father
        if(root==nullptr) return 1;
        int left = dfs(root->left);
        int right = dfs(root->right);
        // (1) if one of the left or right is 0,then need camera:
        if(left==0 || right==0){
            ans++; 
            return 2;
        }
        // (2) left == right == 1: all covered, no camera
        if(left==1 && right==1){
            return 0;
        }
        return 1; // covered by father
    }
};
```







#### [979. Distribute Coins in Binary Tree](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/)

You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree. In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.Return *the **minimum** number of moves required to make every node have **exactly** one coin*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/01/18/tree1.png)

```c++
Input: root = [3,0,0]
Output: 2
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.
```

```c++
class Solution {
public:
    // What ever there are coins more than 1 or less than 1
    // it will all take 1 steps
    int ans = 0;
    int dfs(TreeNode* node) {
        if (node == nullptr) return 0; 
        int L = dfs(node->left);
        int R = dfs(node->right);
        ans += abs(L) + abs(R);
        return node->val + L + R - 1;
    }
    int distributeCoins(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
```







#### [1120. Maximum Average Subtree](https://leetcode-cn.com/problems/maximum-average-subtree/)

Given the `root` of a binary tree, return *the maximum **average** value of a **subtree** of that tree*. Answers within `10-5` of the actual answer will be accepted. A **subtree** of a tree is any node of that tree plus all its descendants. The **average** value of a tree is the sum of its values, divided by the number of nodes.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/04/09/1308_example_1.png)

```c++
Input: root = [5,6,1]
Output: 6.00000
Explanation: 
For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.
For the node with value = 6 we have an average of 6 / 1 = 6.
For the node with value = 1 we have an average of 1 / 1 = 1.
So the answer is 6 which is the maximum.
```

```c++
class Solution {
public:
    double ans = 0;
    double maximumAverageSubtree(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // bootom-up: return <sum, nums>
    array<int, 2> dfs(TreeNode* root) {
        if(!root) return {0, 0};
        auto L = dfs(root->left);
        auto R = dfs(root->right);
        int sum = root->val + L[0] + R[0];
        ans = max(ans, sum / (1.0 + L[1] + R[1]));
        return {sum, 1 + L[1] + R[1]};
    }
};
```



#### [1315. Sum of Nodes with Even-Valued Grandparent](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)

Given the `root` of a binary tree, return *the sum of values of nodes with an **even-valued grandparent***. If there are no nodes with an **even-valued grandparent**, return `0`. A **grandparent** of a node is the parent of its parent if it exists. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg)

```c++
Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 18
Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
```

```c++
class Solution {
public:
    // pass value flag: if father node is even number
    int ans = 0;
    void dfs(TreeNode* root, bool flag){
        if(!root) return;
        if(flag && root->left) ans += root->left->val; 
        if(flag && root->right) ans += root->right->val;
        if(root->val % 2 == 0) flag = true; 
        else flag = false; 
        dfs(root->left, flag);
        dfs(root->right, flag);
    }
    int sumEvenGrandparent(TreeNode* root) {
        if(!root) return 0;
        bool flag = true;
        if(root->val % 2 == 0) flag = true;
        else flag = false;
        // bc root has no father, so dfs from left,right subtree.
        if(root->left) dfs(root->left, flag);
        if(root->right) dfs(root->right, flag);
        return ans;
    }
};
```







#### [1367. Linked List in Binary Tree](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)

Given a binary tree `root` and a linked list with `head` as the first node. 

Return True if all the elements in the linked list starting from the `head` correspond to some *downward path* connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

 **Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png)**

```c++
Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
```

```c++
class Solution {
public:
    bool dfs(ListNode * head,TreeNode * root){
        if(!head) return true;
        if(!root) return false;
        if(root->val != head->val) return false;
        return dfs(head->next,root->left)
            || dfs(head->next,root->right);
    }
    bool isSubPath(ListNode* head, TreeNode* root) {
        if(!head) return true;
        if(!root) return false;
        if(head->val == root->val && dfs(head,root)) return true;
        return isSubPath(head,root->left)
            || isSubPath(head,root->right);
    }
};
```





#### [1448. Count Good Nodes in Binary Tree](https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/)

Given a binary tree `root`, a node *X* in the tree is named **good** if in the path from root to *X* there are no nodes with a value *greater than* X. Return the number of **good** nodes in the binary tree. 

**Example 1:**

**![img](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)**

```c++
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.
```

```c++
// normal recursion 
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, int max_value){
        if(!root) return;
        if(root->val >= max_value) ans++;
        dfs(root->left, max(max_value, root->val));
        dfs(root->right, max(max_value, root->val));
    }
    int goodNodes(TreeNode* root) {
        if(!root) return 0;
        dfs(root, root->val);
        return ans;
    }
};
```

