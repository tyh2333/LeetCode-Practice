[TOC]



## 1. Overlapped intervals:

#### [252. Meeting Rooms](https://leetcode-cn.com/problems/meeting-rooms/)

Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings. 

**Example 1:**

```c++
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
```

```c++
// priority_queue, heap.top(): the meeting finished earliest
// 253. Meeting Rooms II： how many meeting rooms are needed, 
// so in this question, we can think about if one meeting 
// room is enough to use， so return pq.size()==1;

class Solution {
public:
    bool canAttendMeetings(vector<vector<int>>& intervals) {
        if(intervals.size()==0) return true;
        sort(intervals.begin(), intervals.end());
        priority_queue<int, vector<int>, greater<>> pq;
        for(auto meeting : intervals){
            if(!pq.empty() && pq.top() <= meeting[0]){
                pq.pop();
            }
            pq.push(meeting[1]);
        }
        return pq.size()==1;
    }
};
```



#### [253. Meeting Rooms II](https://leetcode-cn.com/problems/meeting-rooms-ii/)

Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return *the minimum number of conference rooms required*. 

**Example 1:**

```c++
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2
```

```c++
class Solution {
public:
    int minMeetingRooms(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());//,
        //[&](vector<int> a, vector<int> b){
            //return a[0]<b[0]|| (a[1]==b[1] && a[1]<b[1]);
        //});
        priority_queue<int, vector<int>, greater<>> pq;
        for(auto x: intervals){
            if(!pq.empty() && pq.top()<= x[0]){
                pq.pop();
            }
            pq.push(x[1]);
        }
        return pq.size();
    }
};
```



#### [435. Non-overlapping Intervals](https://leetcode-cn.com/problems/non-overlapping-intervals/)

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return *the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*. 

**Example 1:**

```c++
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

```c++
class Solution {
public:
    // greedy:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.empty()) return 0;
        // sort intervals by left bound:
        sort(intervals.begin(), intervals.end());
        int num = 1; // how many intervals left = size - num
        int end = intervals[0][1];
        for(auto i : intervals){
            if(i[0] >= end){ // last intervel is non-overlapping
                num++;
                end = i[1];
            }
            else{
                end = min(end, i[1]);
            }
        }
        // need to be deleted: total - non_overlapped;
        return intervals.size() - num;
    }
};
```



#### [452. Minimum Number of Arrows to Burst Balloons](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with `xstart` and `xend` bursts by an arrow shot at `x` if `xstart ≤ x ≤ xend`. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely. Given an array `points` where `points[i] = [xstart, xend]`, return *the minimum number of arrows that must be shot to burst all balloons*.

**Example 1:**

```c++
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
```

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        int n = points.size();
        if(n == 0) return 0;
        sort(points.begin(), points.end());
        int ans = 1;
        int start = points[0][0];
        int end = points[0][1];
        for(int i = 1; i < n; i++){
            if(end < points[i][0]){
                // if meet a no-overlappee, update new interval
                start = points[i][0];
                end = points[i][1];
                ans ++;
            }
            else if(end >= points[i][0]){
                start = points[i][0];
                // new interval may inside old interval,so use min
                end = min(end, points[i][1]); 
            }
        }
        return ans;
    }
};
```



#### [1353. Maximum Number of Events That Can Be Attended](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/)

Given an array of `events` where `events[i] = [startDayi, endDayi]`. Every event `i` starts at `startDayi` and ends at `endDayi`. You can attend an event `i` at any day `d` where `startTimei <= d <= endTimei`. Notice that you can only attend one event at any time `d`.

Return *the maximum number of events* you can attend.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/02/05/e1.png)

```c++
Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
```

```c++
class Solution {
public:
    int maxEvents(vector<vector<int>>& events) {
        int maxDay = 0;
        unordered_map<int, vector<int>> start_to_end;
        // pretreatment need O(n):
        for (auto event : events){  
            if (maxDay < event[1]){
                maxDay = event[1];
            }
            // build mapping: start -- end, can have dup:
            start_to_end[event[0]].push_back(event[1]);
        }
        int ans = 0; 
        priority_queue<int, vector<int>,greater<int>> pq;//minheap
        for (int i = 1; i <= maxDay; ++i){
            // if has meeting start from i, push all end date.
            if (start_to_end.find(i) != start_to_end.end())
            {
                for (auto day : start_to_end[i]) 
                    pq.push(day);
            } 
            // remove all finished meetings
            while (!pq.empty() && pq.top() < i)
            {
                pq.pop();
            }
            // take the meeting has the earliest end time:
            if (!pq.empty())
            {
                pq.pop();
                ++ans;
            }
        }
        return ans;
    }
};
```





## 2. Normal greedy:



#### [31. Next Permutation](https://leetcode-cn.com/problems/next-permutation/)

Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.

**Example 1:**

```c++
Input: nums = [1,2,3]
Output: [1,3,2]
```

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

```c++
// (1) keypoint: 
// non-increasing permutation is the biggest
// non-decreasing permutation is the smallest 
class Solution {
public:
    // e.g. 1 2 3 6 4 2 1; 6 4 2 1 keeps decreasing, 3 breaks
    // o reverse 6 4 2 1 to get 1 2 3 1 2 4 6;
    // and find the next bigger value than 3 is 4,
    // then swap 3 and 4 to get 1 2 4 1 2 3 6;
	void nextPermutation(vector<int>& nums) {
		int pos = nums.size() - 1;
        // find the first element that break the decreasing 
		while (pos > 0 && nums[pos] <= nums[pos - 1]) pos--;
		reverse(nums.begin() + pos, nums.end()); 
		if (pos <= 0) return;
		for (int i = pos; i < nums.size(); i++){ 
			if (nums[i] > nums[pos - 1]){
				swap(nums[i], nums[pos - 1]); 
				break;
			}
		}
	}
};

```



```c++
// (2) method 2: C++ API: next_permutation

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        next_permutation(begin(nums), end(nums));
    }
};
```



#### [134. Gas Station](https://leetcode-cn.com/problems/gas-station/)

There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`. You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**

**Example 1:**

```c++
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
```

```c++
// (1) method 1: bruteforce enum every start point, 
// check if can finish circle with fas_left >= 0 all the time;
// Time complexity: O(n^2);
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        for(int i = 0, j; i < n; i++){
            int gas_left = 0; // gas left in the tank
            for(j = 0; j < n; j++){
                // for circular: cna just % n;
                int k = (i+j)%n; 
                gas_left += gas[k] - cost[k]; // cal gas_left
                if(gas_left < 0) break;
            }
            // if can finish circle, return i
            if(j == n) return i;
        }
        return -1;
    }
};
```



```c++
// (2) optimization of method 1: to O(n)
// same idea, use i += j+1 instead of i++:
// bc with gas_left >= 0 can not from i to j
// then start from i must not go farther than j;
// so skip these j, the TC will be reduced to O(n);

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        for(int i = 0, j; i < n; i+= j+1){
            int gas_left = 0; // gas left in the tank
            for(j = 0; j < n; j++){
                // for circular: cna just % n;
                int k = (i+j)%n; 
                gas_left += gas[k] - cost[k]; // cal gas_left
                if(gas_left < 0) break;
            }
            // if can finish circle, return i
            if(j == n) return i;
        }
        return -1;
    }
};

```



#### [334. Increasing Triplet Subsequence](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

Given an integer array `nums`, return `true` *if there exists a triple of indices* `(i, j, k)` *such that* `i < j < k` *and* `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`. 

**Example 1:**

```c++
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
```

 **Constraints:**

- `1 <= nums.length <= 5 * 105`
- `-2^31 <= nums[i] <= 2^31 - 1`

```c++
// (1) find increasing triplet subsequence:
// use a to save the smallest, b to save the second smallest.
// so if found a value bigger than both a and b, return true!
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int a = INT_MAX;
        int b = INT_MAX;
        for(auto x : nums){
            if(x <= a){
                a = x;
            }else if(x <= b){
                b = x;
            }else return true;
        }
        return false;
    }
};
```



#### [376. Wiggle Subsequence](https://leetcode-cn.com/problems/wiggle-subsequence/)

A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.

- For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.
- In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.

A **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order. Given an integer array `nums`, return *the length of the longest **wiggle subsequence** of* `nums`. 

**Example 1:**

```c++
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
```

```c++
// pretreatment: O(n) + traversal : O(n)
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        // unique(nums.begin(), nums.end()); 
        // remove continous dup elements by replacing to the end
        // and return a iterator that just past the end of the non-dup nums;
        // bc to calculate subsequence, so remove continuous dup
        nums.erase(unique(nums.begin(), nums.end()),nums.end());
        // if len<=2 after erase the dup values, return nums.size
        if(nums.size() <= 2) return nums.size();
        int res = 2;
        for(int i = 1; i+1 < nums.size(); i++){
            int a = nums[i-1], b = nums[i], c = nums[i+1];
            if(a < b && b > c) res ++;
            else if(a > b && b < c) res ++;
        }
        return res;
    }
};
```



#### [406. Queue Reconstruction by Height](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.

Reconstruct and return *the queue that is represented by the input array* `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue). 

**Example 1:**

```c++
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
```

```c++
// greedy: bc shorter one will not have influence of taller
// so arrange taller first, then deal with shorter.
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // sort height from tallest to shortest
        // sort k from shortest to tallest
        sort(people.begin(), people.end(), [&](vector<int>& a, vector<int>& b){
            return a[0] > b[0] || a[0] == b[0] && a[1] < b[1];
        });
        vector<vector<int>> ans;
        for(auto p : people){
            // p[1] is how many taller in front of p
            // ao insert p after pos=res.begin()+p[1]:
            ans.insert(ans.begin() + p[1], p);
        }
        return ans;
    }
};
```



#### [455. Assign Cookies](https://leetcode-cn.com/problems/assign-cookies/)

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.

**Example 1:**

```c++
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
```

```c++
// key: every child could only be assigned no more than one cookie
// so  sort first, then feed the least greedy child first:
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // g is greed factor, s is cookie's size
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int num = 0;
        int j = 0;
        for(int i = 0; i < g.size(); i++){
            // for cur kid, find a cookie for him:
            while(j < s.size()){
                if(g[i] <= s[j]){
                    num++; 
                    j++;
                    break;
                } 
                j++;
            }
        }
        return num;
        
    }
};
```



#### [605. Can Place Flowers](https://leetcode-cn.com/problems/can-place-flowers/)

You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots. Given an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return *if* `n` new flowers can be planted in the `flowerbed` without violating the no-adjacent-flowers rule. 

**Example 1:**

```c++
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
```

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int num = 0,count = 1;
        // set count to 1, assume there is a 0 at the beginning
        for (int i=0; i < flowerbed.size(); i++){
            if (flowerbed[i] == 0) count++;
            else count = 0;
            if (count == 3){ // three continuous 3 cna plant
                num++;
                count = 1;
            }
        }
        // if count==2 in the end, the last one can plant:
        if (count == 2){    
            num++;
        }
        return n <= num;
    }
};
```



#### [621. Task Scheduler](https://leetcode-cn.com/problems/task-scheduler/)

Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer `n` that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks. 

Return *the least number of units of times that the CPU will take to finish all the given tasks*.

 **Example 1:**

```c++
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: 
A -> B -> idle -> A -> B -> idle -> A -> B
There is at least 2 units of time between any two same tasks.
```

```c++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        if (tasks.size() <= 1 || n < 1) return tasks.size();
        //(1) count frequency and maxCount
        vector<int> counts(26, 0);
        int maxCount = INT_MIN;
        for (int i = 0; i < tasks.size(); i++) {
            counts[tasks[i] - 'A']++;
            maxCount = max(maxCount, counts[tasks[i] - 'A']);
        }
        // (2) use formular: ans = (maxCount-1)*(n+1)+ tasks has max_freq;
        // task A is the most_freq one，n=2:
        // A->X->X->A->X->X->A; (X means idle)
        // first i-1 A needs n X
        int ans = (maxCount - 1) * (n + 1);
        int i = 25;
        // if counts[i]==maxCount; ABX ABX AB, need to add cur to the end;
        // e.g.1:
        // n = 2, then no need to care about idle, bc 
        // A B D
        // A B C F
        // A B C D
        // A B C D
        // A B
        while (i >= 0) {
            if(counts[i] == maxCount){
                ans++;
            }
            i--;
        }
        // (2)if the kind of tasks is bigger than n+1, no need to care cool down!!!
        // if ans from formular smaller than task.size(), should return task.size();
        // means task.size() is not enough should return ans;
        // so in one word, return max(ans, task.size());
        return max(ans, (int)tasks.size());
    }
};
```



#### [630. Course Schedule III](https://leetcode-cn.com/problems/course-schedule-iii/)

There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.

You will start on the `1st` day and you cannot take two or more courses simultaneously.

Return *the maximum number of courses that you can take*.

**Example 1:**

```c++
Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]
Output: 3
Explanation: 
There are totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.
```

```c++
class Solution {
public:
    // find max courses number can take: greedy
    int scheduleCourse(vector<vector<int>>& courses) {
        priority_queue<int> pq; 
        // when ti + sum_t <= di; we can pust this (ti,di) in pq;
        // (1) so first we need to sort courses by end date;
        sort(courses.begin(), courses.end(), 
            [&](vector<int>&a, vector<int>& b){
            return a[1]<b[1];
        });
        int cur_time = 0;
        for(auto x : courses){
            // if no conflict, push in pq:
            int duration = x[0];
            int lastDay = x[1];
            if(cur_time + duration <= lastDay){
                // means can have this course
                pq.push(duration);
                cur_time += duration;
            }
            // if have conflict, push current course
            // pop the one which take the most time;
            // means choose not to take this course
            else{
                // push first, or check empty(): if can pop
                pq.push(duration);
                cur_time += duration;
                auto tmp = pq.top(); pq.pop();
                cur_time -= tmp;
            }
        }
        // in the end, pq.size() is ans;
        return pq.size();
    }
};
```



#### [665. Non-decreasing Array](https://leetcode-cn.com/problems/non-decreasing-array/)

Given an array `nums` with `n` integers, your task is to check if it could become non-decreasing by modifying **at most one element**.

We define an array is non-decreasing if `nums[i] <= nums[i + 1]` holds for every `i` (**0-based**) such that (`0 <= i <= n - 2`). 

**Example 1:**

```c++
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
```

```c++
// traversal and change once, return false when count>1
class Solution {
public:
    bool checkPossibility(vector<int>& nums){
        int count = 0;
        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] > nums[i]){
                if(i-2 >= 0 && nums[i-2] > nums[i]){
                    nums[i] = nums[i-1];
                } 
                else nums[i-1] = nums[i];
                count++;
            }
            if(count > 1) return false;
        }
        return true;
    }
};
```





#### [775. Global and Local Inversions](https://leetcode-cn.com/problems/global-and-local-inversions/)

You are given an integer array `nums` of length `n` which represents a permutation of all the integers in the range `[0, n - 1]`. The number of **global inversions** is the number of the different pairs `(i, j)` where:

- `0 <= i < j < n`
- `nums[i] > nums[j]`

The number of **local inversions** is the number of indices `i` where:

- `0 <= i < n - 1`
- `nums[i] > nums[i + 1]`

Return `true` *if the number of **global inversions** is equal to the number of **local inversions***.

 **Example 1:**

```c++
Input: nums = [1,0,2]
Output: true
Explanation: There is 1 global inversion and 1 local inversion.
```

```c++
class Solution {
public:
    // (1) local invert must be global invert !!!
    // (2) all the values are from 0 to n-1;
    // so as long as there is one pair of that:
    // value with index are not continous, return false;
    bool isIdealPermutation(vector<int>& nums) {
        for(int i = 0; i< nums.size(); i++)
            if(abs(nums[i]-i) > 1)
                return false;
        return true;
    }
};
```





#### [860. Lemonade Change](https://leetcode-cn.com/problems/lemonade-change/)

At a lemonade stand, each lemonade costs `$5`. Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a `$5`, `$10`, or `$20` bill. You must provide the correct change to each customer so that the net transaction is that the customer pays `$5`. Note that you don't have any change in hand at first. Given an integer array `bills` where `bills[i]` is the bill the `ith` customer pays, return `true` *if you can provide every customer with correct change, or* `false` *otherwise*. 

**Example 1:**

```c++
Input: bills = [5,5,5,10,20]
Output: true
Explanation: 
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.
```

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int fives = 0, tens = 0;
        for(auto &b : bills){
            if(b == 5) fives++;
            else if(b == 10){
                if(fives) fives--;
                else return false;
                tens++;
            }
            else if(b == 20){
                int t = 15; // change==15 for 20
                if(tens){ // use 10s first
                    t -= 10;
                    tens--;
                }
                // bc maybe not enough 10s, so may use more 5
                while(t && fives){
                    t -= 5;
                    fives--;
                }
                if(t > 0) return false;
            }
        }
        return true;
    }
};
```



#### [874. Walking Robot Simulation](https://leetcode-cn.com/problems/walking-robot-simulation/)

A robot on an infinite XY-plane starts at point `(0, 0)` and faces north. The robot can receive one of three possible types of `commands`:

- `-2`: turn left `90` degrees,
- `-1`: turn right `90` degrees, or
- `1 <= k <= 9`: move forward `k` units.

Some of the grid squares are `obstacles`. The `ith` obstacle is at grid point `obstacles[i] = (xi, yi)`.

If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)

Return *the maximum Euclidean distance that the robot will be from the origin **squared** (i.e. if the distance is* `5`*, return* `25`*)*.

**Note:**

- North means +Y direction.
- East means +X direction.
- South means -Y direction.
- West means -X direction.

 **Example 1:**

```c++
Input: commands = [4,-1,3], obstacles = []
Output: 25
Explanation: The robot starts at (0, 0):
1. Move north 4 units to (0, 4).
2. Turn right.
3. Move east 3 units to (3, 4).
The furthest point away from the origin is (3, 4), which is 32 + 42 = 25 units away.
```

```c++
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        // int dx[4] = {0, 1, 0, -1};
        // int dy[4] = {1, 0, -1, 0};
        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, -1, 0, 1};
        int x = 0, y = 0;
        // At first face north, so dir should be 3
        int dir = 3;
        // use set to make check has TC = O(logN);
        // cannot use unordered_set:
        // bc it doesn't support pair as key:
        set <pair<int, int>> obstacleSet;
        for (auto obstacle: obstacles)
            obstacleSet.insert(make_pair(obstacle[0], obstacle[1]));
        int ans = 0;
        for (int cmd: commands) {
            // (1) turn left 90 degrees
            if (cmd == -2) dir = (dir + 3) % 4; 
            // (2) turn right 90 degrees
            else if (cmd == -1) dir = (dir + 1) % 4; 
            // (3) move forward k
            else {
                for (int k = 0; k < cmd; ++k) {
                    int nx = x + dx[dir];
                    int ny = y + dy[dir];
                    if (obstacleSet.find(make_pair(nx, ny)) 
                        == obstacleSet.end()) {
                        x = nx;
                        y = ny;
                        ans = max(ans, x*x + y*y); 
                    }
                }
            }
        }
        return ans;
    }
};
```



#### [1005. Maximize Sum Of Array After K Negations](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

Given an integer array `nums` and an integer `k`, modify the array in the following way:

- choose an index `i` and replace `nums[i]` with `-nums[i]`.

You should apply this process exactly `k` times. You may choose the same index `i` multiple times.

Return *the largest possible sum of the array after modifying it in this way*. 

**Example 1:**

```c++
Input: nums = [4,2,3], k = 1
Output: 5
Explanation: Choose index 1 and nums becomes [4,-2,3].
```

```c++
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& A, int K) {
        int n = (int)A.size();
        sort(A.begin(),A.end()); // O(nlogn)
        // if all the element are not negative:
        // if K is odd, then make A[0] flip 1 times, return sum;
        if(A[0] >= 0){ 
            if(K%2!=0) A[0]=-A[0];
            return accumulate(A.begin(),A.end(),0); 
        }
        // if has negative: 
        for(int i = 0; i < K && i < n; i++){
            // (1) flip directly:
            if(A[i] < 0) A[i]=-A[i];
            // (2) break; bc can flip 0 infinite times
            else if(A[i] == 0) break;
            // (3) when reach positive:
            else{
                // if K is even: break:
                if((K-i)%2==0) break;
                // if K is odd, should choose a smaller one flip:
                if(A[i] < A[i-1]) A[i]=-A[i];
                else A[i-1] = -A[i-1];
                break;
            }
        }
        // need to consider when n < K:
        // e.g. [-4,-2,-3] K=4: after flip: [4,3,-2],sum=5;
        // if K-n is odd, need to flip the smallest val
        // so sum - 2*A[n-1];
        int sum = accumulate(A.begin(), A.end(),0);
        return ((K - n) % 2 == 1) ? sum - 2*A[n-1] : sum;
        
    }
};
```



#### [1029. Two City Scheduling](https://leetcode-cn.com/problems/two-city-scheduling/)

A company is planning to interview `2n` people. Given the array `costs` where `costs[i] = [aCosti, bCosti]`, the cost of flying the `ith` person to city `a` is `aCosti`, and the cost of flying the `ith` person to city `b` is `bCosti`.

Return *the minimum cost to fly every person to a city* such that exactly `n` people arrive in each city.

 **Example 1:**

```c++
Input: costs = [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation: 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
```

```c++
class Solution {
public:
    // bc we wanna know the minmal cost of all the people assigned to two places;
    // at first, we assume all the people will go city B
    // then we need to change the plan to A in half of the people
    // people who assigned to A, will cost extra =  price_A - price_B, 
    // extra can be either negagtive or positive
    // so we sort according to this extra, 
    // then we choose the first N go city A, the rest of N go city B;
    int twoCitySchedCost(vector<vector<int>>& costs) {
        sort(costs.begin(), costs.end(),[](const vector<int> &o1, const vector<int> &o2){
            return (o1[0]-o1[1] < o2[0]-o2[1]);
        });
        int total = 0; int n = costs.size() / 2;
        // first N go city A, rest of N go city B;
        for (int i = 0; i < n; ++i) total += costs[i][0] + costs[i + n][1];
        return total;
    }
};
```



#### [1046. Last Stone Weight](https://leetcode-cn.com/problems/last-stone-weight/)

You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.

We are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:

- If `x == y`, both stones are destroyed, and
- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.

At the end of the game, there is **at most one** stone left.

Return *the smallest possible weight of the left stone*. If there are no stones left, return `0`. 

**Example 1:**

```c++
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.
```

```c++
// just simulation: choose two heaviest two stones:
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> s; // default, top is the biggest  
        for(int i = 0 ; i < stones.size() ; i ++) 
            s.push(stones[i]);
        // bc pop twice in while, so s.size() > 1:
        while(s.size() > 1){
            int x = s.top(); s.pop();
            int y = s.top(); s.pop();
            if(x > y) s.push(x - y);
        }
        // if can destroy all stones, return 0, 
        // else return the last stone.
        return (s.empty()) ? 0 : s.top();
    }
};
```



#### [1217. Minimum Cost to Move Chips to The Same Position](https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/)

We have `n` chips, where the position of the `ith` chip is `position[i]`. We need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:

- `position[i] + 2` or `position[i] - 2` with `cost = 0`.
- `position[i] + 1` or `position[i] - 1` with `cost = 1`.

Return *the minimum cost* needed to move all the chips to the same position.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2020/08/15/chips_e1.jpg)

```c++
Input: position = [1,2,3]
Output: 1
Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.
Second step: Move the chip at position 2 to position 1 with cost = 1.
Total cost is 1.
```

```c++
//  greedy: only need to compare number of odd and even:
class Solution {
public:
    int minCostToMoveChips(vector<int>& chips) {
        int odd = 0, even = 0;
	    for (int i = 0; i < chips.size(); i++) {
		    if (chips[i] % 2 == 0) even++;
            else if (chips[i] % 2 != 0) odd++;
	    }
	    return min(even, odd);  
    }
};
```



#### [1753. Maximum Score From Removing Stones](https://leetcode-cn.com/problems/maximum-score-from-removing-stones/)

You are playing a solitaire game with **three piles** of stones of sizes `a`, `b`, and `c` respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).

Given three integers `a`, `b`, and `c`, return *the* ***maximum\*** ***score** you can get.*

**Example 1:**

```c++
Input: a = 2, b = 4, c = 6
Output: 6
Explanation: The starting state is (2, 4, 6). One optimal set of moves is:
- Take from 1st and 3rd piles, state is now (1, 4, 5)
- Take from 1st and 3rd piles, state is now (0, 4, 4)
- Take from 2nd and 3rd piles, state is now (0, 3, 3)
- Take from 2nd and 3rd piles, state is now (0, 2, 2)
- Take from 2nd and 3rd piles, state is now (0, 1, 1)
- Take from 2nd and 3rd piles, state is now (0, 0, 0)
There are fewer than two non-empty piles, so the game ends. Total: 6 points.
```

```c++
class Solution {
public:
    int maximumScore(int a, int b, int c) {
        int res = 0;
        vector<int> nums = {a, b, c};
        sort(nums.begin(), nums.end());
        while (nums[0] > 0 || nums[1] > 0) {
            nums[1]--;
            nums[2]--;
            sort(nums.begin(), nums.end());
            res++;
        }
        return res;
    }
};
```





#### [1775. Equal Sum Arrays With Minimum Number of Operations](https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/)

You are given two arrays of integers `nums1` and `nums2`, possibly of different lengths. The values in the arrays are between `1` and `6`, inclusive.

In one operation, you can change any integer's value in **any** of the arrays to **any** value between `1` and `6`, inclusive.

Return *the minimum number of operations required to make the sum of values in* `nums1` *equal to the sum of values in* `nums2`*.* Return `-1` if it is not possible to make the sum of the two arrays equal.

 

**Example 1:**

```c++
Input: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
Output: 3
Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.
- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2].
- Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2].
- Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2].
```

```c++
class Solution {
public:
    int ans = 0;
    int diff;
    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        int s1 = nums1.size(), s2 = nums2.size();
        if(s1*6 < s2 || s2*6 < s1) return -1;
        // e.g. [2] and [3], only need one operation:
        if(s1 == 1 && s2 == 1) return 1;
        int sum1 = 0, sum2 = 0;
        for(auto x : nums1) sum1 += x;
        for(auto x : nums2) sum2 += x;
        if(sum1 == sum2) return 0;
        diff = abs(sum1 - sum2);
        if(sum1 <= sum2) check(nums1, nums2);
        else check(nums2, nums1);
        return ans;
    }
    // greedy: first change 1 to 6 in nums1, 
    // or change 6 to 1 in nums2
    void check(vector<int>& nums1, vector<int>& nums2){
        sort(nums1.begin(),  nums1.end());
        sort(nums2.rbegin(), nums2.rend());
        int n = nums1.size(), m = nums2.size();
        int i, j;
        for(i = 0, j = 0; i < n && j < m;){
            // choose the one can make these two more closer:
            if (6-nums1[i] > nums2[j]-1){
                diff -= (6 - nums1[i]);
                ans++;
                i++;
            }
            else{
                diff -= nums2[j]-1;
                ans++;
                j++;
            }
            if(diff == 0) return;
            if(diff < (6-nums1[i]) || diff < nums2[j]-1){
                ans++;
                diff = 0; 
                return;
            }
        }
        // deal with the rest:
        while(i < n && diff > 0){
            diff -= 6-nums1[i++];
            ans++;
        }
        while(j < m && diff > 0){
            diff -= nums2[j++]-1;
            ans++;
        } 
    }
};
```

